<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kevin Chow&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ouzhrm.github.io/"/>
  <updated>2019-09-23T10:38:18.514Z</updated>
  <id>https://ouzhrm.github.io/</id>
  
  <author>
    <name>Kevin Chow</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>学习redis，读这一篇就够了？</title>
    <link href="https://ouzhrm.github.io/2019/09/23/%E5%AD%A6%E4%B9%A0redis%EF%BC%8C%E8%AF%BB%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%9F/"/>
    <id>https://ouzhrm.github.io/2019/09/23/学习redis，读这一篇就够了？/</id>
    <published>2019-09-23T10:03:41.000Z</published>
    <updated>2019-09-23T10:38:18.514Z</updated>
    
    <content type="html"><![CDATA[<p>耗时1个多月空闲出来的时间学习整理的redis相关知识。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br></pre></td><td class="code"><pre><span class="line">1、什么时候会用到缓存？为什么要用这门技术？</span><br><span class="line"></span><br><span class="line">单机mysql数据库在TPS超过1500的时候可能会宕机或者说无法提供服务，</span><br><span class="line">redis缓存查询TPS在7到10w之间，所以要用redis缓存来保护&quot;脆弱&quot;的mysql单机数据库.</span><br><span class="line"></span><br><span class="line">维护性</span><br><span class="line">     开源，核心代码大概32000多行，社区活跃，后续可维护性较好</span><br><span class="line">扩展性</span><br><span class="line">     客户端支持多语言，比如：php、java、golang</span><br><span class="line">     可以搭集群（哨兵，分片），实现高可用</span><br><span class="line">稳定性、成熟性</span><br><span class="line">     支持持久化（RDB / AOF）</span><br><span class="line">    大多公司在用（阿里巴巴，微博，腾讯等）</span><br><span class="line">性能</span><br><span class="line">    每秒并发量能支持高达10万，速度快，用C语言实现，单线程模型避免上下文</span><br><span class="line">    资源切换及内部竞争条件（持久化会重新开条线程去处理）</span><br><span class="line">    支持协议格式执行命令，支持pipeline(管道)，提高执行效率</span><br><span class="line">丰富性</span><br><span class="line">    支持五种数据类型（string、list、set、zset、hash），而外还有bitmaps、</span><br><span class="line">hyperLogLog、GEO。</span><br><span class="line"></span><br><span class="line">注意：但数据量大访问频率低、联表多、要求有事务属性，不适合用redis。</span><br><span class="line"></span><br><span class="line">2、这门技术相对于其他的同类技术，为什么选用这门技术？两者或者多者的比较？有哪些优缺点？</span><br><span class="line">    举例：</span><br><span class="line">如自身的相关数值：数据量、TPS、响应时间。</span><br><span class="line">缓存相关的有：本地缓存、分布式缓存（redis、mamcached）、客户端缓存、</span><br><span class="line">数据库缓存、CDN缓存。</span><br><span class="line">选型指标：容量、并发量、响应时间、使用成本、扩展性、容灾。</span><br><span class="line"></span><br><span class="line">本地缓存不建议用在分布式服务中，一来是占其他服务内存，也带有不可控性，</span><br><span class="line">二是导致资源浪费。（相同资源备份在多个服务中）。</span><br><span class="line"></span><br><span class="line">客户端缓存可能会给用户带来不好的体验。</span><br><span class="line"></span><br><span class="line">数据库缓存带不可操作性（一些计算的结果，或者是频繁访问的数据）。</span><br><span class="line"></span><br><span class="line">CDN缓存。</span><br><span class="line"></span><br><span class="line">Redis之与Memcached的比较</span><br><span class="line">一、性能</span><br><span class="line">  由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储</span><br><span class="line">  小数据时比Memcached性能更高。而在100k以上的数据时，Memcached性能要高于Redis，</span><br><span class="line">  虽然Redis最近也在存储大数据的性能上进行优化，但是比起Memcached，还是稍有逊色。</span><br><span class="line">二、内存使用效率</span><br><span class="line">  使用简单的key-value存储的话，Memcached的内存利用率更高，而如果Redis采用hash结</span><br><span class="line">  构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcached。</span><br><span class="line">三、数据备份恢复</span><br><span class="line">  memcached挂掉后，数据不可恢复；redis数据丢失后可以通过aof恢复，Redis支持数据</span><br><span class="line">的备份，即master-slave主从模式的数据备份。redis支持持久化。</span><br><span class="line">四、内存管理机制</span><br><span class="line">对于像Redis和Memcached这种基于内存的数据库系统来说，内存管理的效率高低是影</span><br><span class="line">响系统性能的关键因素。Memcached的内存管理制效率高，而且不会造成内存碎片，但</span><br><span class="line">是它最大的缺点就是会导致空间浪费。因为每个Chunk都分配了特定长度的内存空间，</span><br><span class="line">所以变长数据无法充分利用这些空间。比如将100个字节的数据缓存到128个字节的Chunk</span><br><span class="line">中，剩余的28个字节就浪费掉了</span><br><span class="line">Redis采用的是包装的malloc/free,会造成内存碎片。</span><br><span class="line">五、集群、分布式存储</span><br><span class="line">Memcached不支持分布式，只能在客户端通过像一致性哈希(内置)这样的分布式算法来</span><br><span class="line">实现Memcached的分布式存储。Redis Cluster是一个实现了分布式且允许单点故障的</span><br><span class="line">Redis高级版本，它没有中心节点，具有线性可伸缩的功能。</span><br><span class="line">   （优秀博客：https://mp.weixin.qq.com/s/4J3oM1j5hcLq4w4TdSEMPg）</span><br><span class="line"></span><br><span class="line">使用场景上比较</span><br><span class="line">mamcached多核，qps能上到几十万级别，但数据结构单一，仅仅支持key/value简单</span><br><span class="line">的数据类型，无法持久化，水平扩展需要编写分布策略，无法进行数据水平复制。</span><br><span class="line">redis单核，qps能上十万，数据结构丰富，支持持久化（aof文件），支持集群和哨</span><br><span class="line">兵机制（master/slave），支持水平数据复制。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3、这门技术可以运用在什么场景上？</span><br><span class="line"></span><br><span class="line">放热数据，提高查询效率</span><br><span class="line">分布式锁</span><br><span class="line">统计（如2亿用户，统计某个用户是否为活跃用户,用到bitmaps）、排行榜(zset)</span><br><span class="line">分布式限流（根据ip地址）</span><br><span class="line">推荐（共同好友或歌曲推荐求交集，此外，还有差集和并集）、点赞、收藏数（set命令）</span><br><span class="line">消息队列（一般不会用）</span><br><span class="line">session统一处理</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4、如何运用这门技术？（常用命令、集群、分片、哨兵），怎么去优化？？这门技术是怎么实现的？</span><br><span class="line">redis用法及介绍：https://juejin.im/post/5a912b3f5188257a5c608729</span><br><span class="line">redis集群哨兵搭建（亲自搭建过，过程会有些bug ,自行谷歌修复）：</span><br><span class="line">https://blog.csdn.net/shouhuzhezhishen/article/details/69221517</span><br><span class="line"></span><br><span class="line">redis分片（将数据拆分几部分，按照一定的路由规则存到对应的redis节点中）</span><br><span class="line">客户端分片：在客户端进行一致性哈希，选择路由到那一台redis机器上访问。</span><br><span class="line">代理服务器分片：Twemproxy 是 Twitter 开发的代理服务器。</span><br><span class="line">服务端分片：将所有的存储空间分成16384个slot,数据按照一定的路由规则存到这些</span><br><span class="line">对应的slot中，可以理解成在master-slave上加一层，如果动态扩缩容，可以采</span><br><span class="line">用预分片（32/64个节点，不用的节点没数据占内存空间1M左右）。客户端在查找</span><br><span class="line">key的所在节点时也是通过CRC16校验后对16384取模。</span><br><span class="line"></span><br><span class="line">redis优化：</span><br><span class="line">一、尽量别用持久化（TODO：集群需要开启持久化，就是那三个save配置）。</span><br><span class="line">二、不要设置过期时间，耗cpu和内存性能。</span><br><span class="line">    在 redis.conf 中有一行配置： maxmemory-policy volatile-lru</span><br><span class="line">    当内存不足时，自动移除最近最少使用的元素（默认策略）</span><br><span class="line">三、keys，hgetall，smembers等长时间命令一般不再生产环境使用，</span><br><span class="line">因为是单线程，容易阻塞</span><br><span class="line">四、获取多个value, 能用批量执行命令就用批量执行命令（如mget），能减少多次访问</span><br><span class="line">网络和执行命令的时间，或者用pipeline.</span><br><span class="line">五、设置慢查询的值，定期查询慢查询日志</span><br><span class="line">config set slowlog-max-len 1000  //1000微秒=1ms</span><br><span class="line">config set slowlog-log-slower-than 1000   </span><br><span class="line">六、默认会进行内存压缩，用cpu换时间的方式。（集合中）如果某个值超过了配置文件中</span><br><span class="line">设置的最大值，redis将自动把它（集合）转换为正常的散列表。</span><br><span class="line">更改阈值的方法：</span><br><span class="line">hash-max-zipmap-entries 64 (2.6以上使用hash-max-ziplist-entries)</span><br><span class="line">hash-max-zipmap-value 512  (2.6以上使用hash-max-ziplist-value)</span><br><span class="line">list-max-ziplist-entries 512</span><br><span class="line">list-max-ziplist-value 64</span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line">set-max-intset-entries 512</span><br><span class="line"></span><br><span class="line">七、尽可能使用散列表（hashes），存储对象能用hashes就不用string,这样能能省接近90%内存。</span><br><span class="line"></span><br><span class="line">TODO: redis内部具体实现原理。</span><br><span class="line"> Redis设计与实现（作者：黄建宏）</span><br><span class="line">redis底层原理：https://blog.csdn.net/wcf373722432/article/details/78678504</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line"> * Redis 对象 </span><br><span class="line"> */  </span><br><span class="line">typedef struct redisObject &#123;  </span><br><span class="line">  </span><br><span class="line">    // 类型（五种，string、list、hash、set、zset）  </span><br><span class="line">    unsigned type:4;          </span><br><span class="line">  </span><br><span class="line">    // 不使用(对齐位)  </span><br><span class="line">    unsigned notused:2;  </span><br><span class="line">  </span><br><span class="line">    // 编码方式 (八种，long类型整数、embstr SDS、SDS、字典（映射）、压缩列表、</span><br><span class="line">双端链表、跳跃表、整数集合) </span><br><span class="line">    unsigned encoding:4;  </span><br><span class="line">  </span><br><span class="line">    // LRU 时间（相对于 server.lruclock）  </span><br><span class="line">    unsigned lru:22;  </span><br><span class="line">  </span><br><span class="line">    // 引用计数  </span><br><span class="line">    int refcount;  </span><br><span class="line">  </span><br><span class="line">    // 指向对象的值  </span><br><span class="line">    void *ptr;  </span><br><span class="line">  </span><br><span class="line">&#125; robj;  </span><br><span class="line"></span><br><span class="line">字符串对象的编码可以是int、raw或者embstr。</span><br><span class="line"></span><br><span class="line">字符串对象的长度小于39字节，就用embstr对象。否则用传统的raw对象。</span><br><span class="line">redis并未提供任何修改embstr的方式，即embstr是只读的形式。对embstr的</span><br><span class="line">修改实际上是先转换为raw再进行修改。</span><br><span class="line">embstr和raw的区别在于embstr更能充分的利用空间，不会预留空间，而raw是</span><br><span class="line">预留空间的。</span><br><span class="line"></span><br><span class="line">列表对象的编码是ziplist或linkedlist</span><br><span class="line"></span><br><span class="line">ziplist是压缩列表，空间连续，能节省空间，对象元素不大时用ziplist，</span><br><span class="line">但缺点也明显，插入复杂度是O(n)，linkedlist是双端链表。</span><br><span class="line"></span><br><span class="line">哈希对象的底层实现可以是ziplist或者hashtable。</span><br><span class="line"></span><br><span class="line">ziplist中的哈希对象是按照key1,value1,key2,value2这样的顺序存放来存储的</span><br><span class="line">hashtable的是由dict这个字典结构来实现的，dict包含两个指针，指向两个哈希表，</span><br><span class="line">分别是dicht[0] 是用于真正存放数据，dicht[1]一般在哈希表元素过多进行</span><br><span class="line">rehash的时候用于中转数据。</span><br><span class="line"></span><br><span class="line">集合对象的编码可以是intset或者hashtable(保证快速新增、删除、查找)。</span><br><span class="line"></span><br><span class="line">有序集合的编码可能两种，一种是ziplist，另一种是skiplist与dict（字典，保证score顺序）的结合。</span><br><span class="line"></span><br><span class="line">ziplist作为集合和作为哈希对象是一样的，member和score顺序存放。按照score</span><br><span class="line">从小到大顺序排列。</span><br><span class="line">skiplist是一种跳跃表，它实现了有序集合中的快速查找。</span><br><span class="line">想如果单一用dict(hashtable)，那可以快速查找（主要）、添加和</span><br><span class="line">删除元素，但没法保持集合的有序性。如果单一用skiplist，有序性</span><br><span class="line">可以得到保障，但查找的速度太慢O（logN）。</span><br><span class="line"></span><br><span class="line">redis各个配置参数详解：</span><br><span class="line">https://blog.csdn.net/ljl890705/article/details/51540427</span><br><span class="line">https://www.cnblogs.com/chenmh/p/5121849.html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">redis的持久化</span><br><span class="line"></span><br><span class="line">aof文件不会丢数据，rdb文件会丢数据。</span><br><span class="line">aof文件大，恢复慢，rdb文件快。</span><br><span class="line"></span><br><span class="line">redis架构</span><br><span class="line">单线程模型避免上下文，纯内存操作响应时间大概是100纳秒，采用epoll多路复用的非阻塞io,在连接、读写、关闭上尽可能的节省时间。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">redis回收策略</span><br><span class="line"></span><br><span class="line">volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑</span><br><span class="line">  选最近最少使用的数据淘汰</span><br><span class="line">volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑</span><br><span class="line">  选将要过期的数据淘汰</span><br><span class="line">volatile-random：从已设置过期时间的数据集（server.db[i].expires）</span><br><span class="line"> 中任意选择数据淘汰</span><br><span class="line">allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数</span><br><span class="line"> 据淘汰</span><br><span class="line">allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</span><br><span class="line">no-enviction（驱逐）：禁止驱逐数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">缓存更新策略</span><br><span class="line"></span><br><span class="line">1、被动失效</span><br><span class="line">缓存数据主要是服务读请求的，通常会设置一个过期时间，或者当数据库</span><br><span class="line">状态改变时，通过一个简单的delete操作，使数据失效掉；当下次再去读</span><br><span class="line">取时，如果发现数据过期了或者不存在了，那么就重新去数据库读取，</span><br><span class="line">然后更新到缓存中，这即是所谓的被动失效策略。被动策略有一个很大的</span><br><span class="line">风险，从缓存失效到数据再次被预热到cache这段时间，所有的读请求会</span><br><span class="line">直接打到DB上，对于一个高访问量的系统，很容易被击垮。</span><br><span class="line"></span><br><span class="line">2、主动更新</span><br><span class="line">主动更新，很容易理解，就是数据库存储发生变化时，会直接同步更新到</span><br><span class="line">Cache，主要是为了解决cache空窗期引发的问题。比如电商的卖家修改商</span><br><span class="line">品详情，具有读多写少特点。但如果是读多写多，同样会带来另一个问题，</span><br><span class="line">就是并发更新。多台应用服务器同时访问一份数据是很正常的，这样就会</span><br><span class="line">存在一台服务器读取并修改了缓存数据，但是还没来得及写入的情况下，</span><br><span class="line">另一台服务器也读取并修改旧的数据，这时候，后写入的将会覆盖前面的，</span><br><span class="line">从而导致数据丢失。解决的方式可以有：锁控制，如redisson；版本号。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">影响命中率的可能因素：</span><br><span class="line"></span><br><span class="line">1、设置过期时间太短。</span><br><span class="line">2、空间不足，频繁有效的缓存按照回收策略被剔除</span><br><span class="line">3、key确实不存在</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">性能指标</span><br><span class="line"></span><br><span class="line">缓存空间的使用率</span><br><span class="line">topN 命令的执行次数</span><br><span class="line">缓存的命中率</span><br><span class="line">缓存的接口平均RT，最大RT，最小RT</span><br><span class="line">缓存的QPS</span><br><span class="line">网络出口流量</span><br><span class="line">客户端连接数</span><br><span class="line">key个数统计</span><br><span class="line">演练结果（如果缓存服务全部或个别宕掉的情况）</span><br><span class="line"></span><br><span class="line">5、如何保证高可用和一致性等等？</span><br><span class="line">主从集群+哨兵模式来保证高可用。</span><br><span class="line">先操作数据库，再操作redis ，来保证数据库和缓存之间的一致性。如果redis</span><br><span class="line">操作失败，mysql就会回滚，</span><br><span class="line">不会出现数据不一致的问题。并发问题通过互斥锁的形式解决。</span><br><span class="line"></span><br><span class="line">6、用这门技术可能会有什么坑？亲身经历有什么坑？如何解决？？有没备选或者</span><br><span class="line">应急方案？一些知名的公司是怎么用这门技术的？它们的心得体会及经验是怎么样的？</span><br><span class="line">举例：</span><br><span class="line">https://github.com/aalansehaiyang/technology-talk/blob/master/system-architecture/architecture-experience.md</span><br><span class="line">（可以看看缓存那一块）</span><br><span class="line"></span><br><span class="line">坑一：</span><br><span class="line">僵尸连接: 服务端连接数上限了，但是客户端连接数没有上限，线上部署的时候。</span><br><span class="line">缓兵之计：通过脚本命令清除连接，不用担心客户端，客户端会重连。</span><br><span class="line">我们重新给客户端设了最大超时，如果连接一直处于空闲状态，大概 5 分钟就会</span><br><span class="line">断开与服务器之间的长连接，但奇怪的是服务端不承认客户端的断连状态，一直保</span><br><span class="line">持该连接，结果从客户端的服务器看不到这种连接，但在 Redis 服务器上却看到</span><br><span class="line">大量这种连接，最终导致服务端连接数被占满，无法再创建新连接对外提供服务。</span><br><span class="line">原因：给服务端设置Timeout和客户端设置的Timeout不一致，服务端的时间更长一些。</span><br><span class="line"></span><br><span class="line">坑二：</span><br><span class="line">内存飙升</span><br><span class="line">内存最大值（maxmemory）限制：起初缓存的数据比较少，一直没配最大内存限制。</span><br><span class="line">这是一个小错误。系统除了报 Cluster down 外，并没更清晰的报错，当时我们一</span><br><span class="line">脸迷惘，莫名其妙地查了 1 个多小时后才发现服务器内存被耗光了。后面作分片</span><br><span class="line">处理。或者说部分不确定数据量大小的业务部门搭建自己的redis。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">此外，通过查看监控和查询日志，还可能是客户端滥用monitor命令。</span><br><span class="line">monitor的模型是这样的，它会将所有在Redis服务器执行的命令进行输出，通常来讲</span><br><span class="line">Redis服务器的QPS是很高的，也就是如果执行了monitor命令，Redis服务器在Monitor</span><br><span class="line">这个客户端的输出缓冲区又会有大量“存货”，也就占用了大量Redis内存。</span><br><span class="line">预防方法：禁止掉一些危险的命令(shutdown,flushall, monitor, keys *)。</span><br><span class="line">添加command-rename配置，将一些危险的命令(flushall, monitor, keys * , flushdb)</span><br><span class="line">做rename。</span><br><span class="line"></span><br><span class="line">坑三：</span><br><span class="line">连接数过多</span><br><span class="line">可以用netty重新写一个代理层</span><br><span class="line">或者各个业务部门自己搭建缓存系统，存储各自的业务热数据。</span><br><span class="line">各个业务部门都应该写个预热数据脚本。</span><br><span class="line"></span><br><span class="line">坑四：</span><br><span class="line">aof 文件占满磁盘空间，单机多实例可能存在Swap和OOM的隐患</span><br><span class="line">（提示：aof重写,aof存各种执行命令，aof重写也叫去冗余命令，重新生成一个新的脚本）</span><br><span class="line">此后每天执行BGREWRITEAOF指令脚本（异步操作，不会阻塞单线程）的同时并监控磁盘空</span><br><span class="line">间，减少服务器上 Redis 的实例数并腾空一半内存，因为一台机上部署多个 Redis 实例</span><br><span class="line">会有个隐患，万一多个实例扎堆做 AOF 重写会导致 swap 或者 oom，导致重写失败，这种</span><br><span class="line">失败会不断重复，直至 aof 文件像滚雪球似的变大，最终塞满磁盘，另外重写体积较大的</span><br><span class="line"> aof 文件时，Redis 会进入 IO 阻塞状态，停止对外服务</span><br><span class="line"></span><br><span class="line">坑五：</span><br><span class="line">缓存穿透：指的是对某个一定不存在的数据进行请求，该请求将会穿透缓存到达数据库。</span><br><span class="line">这是一种恶意操作的行为，往往表现在黑客或者懂相关技术的人去操作。</span><br><span class="line">解决方案：</span><br><span class="line">1、对这类请求进行过滤，用布隆过滤器，将数据库中所有的对应redis的key,进行hash, </span><br><span class="line">存到redis的bitmaps存储结构中，</span><br><span class="line">  然后操作redis具体数据前先请求bitmap中有没有相关的数据，没有直接返回。</span><br><span class="line">  具体操作请自行搜索：&quot;布隆过滤器 redis&quot;,</span><br><span class="line">  但用这个难免会有命中误差率，假设“abc”的hash值是587，而“19f”的hash值也是587, </span><br><span class="line">  那么如果19f在数据库中没有对应的数据，也是会穿透的，对于这类问题，</span><br><span class="line">  可以采用回设的方式，如果第一次数据库中没有查询到，设置一个默认值</span><br><span class="line">  存到redis中，第二次甚至往后的n次就可以直接在redis上catch住了。</span><br><span class="line">2、对这些不存在的数据缓存一个空数据或者指定的默认值。</span><br><span class="line"></span><br><span class="line">坑六：</span><br><span class="line">缓存雪崩：指的是由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效</span><br><span class="line">（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库。在有缓存的系统中，</span><br><span class="line">系统非常依赖于缓存，缓存分担了很大一部分的数据请求。当发生缓存雪崩时，数据库</span><br><span class="line">无法处理这么大的请求，导致数据库崩溃。这可以理解成是一种善意行为，是指用户请</span><br><span class="line">求量大而使请求越过缓存跳向数据库导致数据库宕机（TPS:1500左右）的行为。</span><br><span class="line">解决方案：</span><br><span class="line">1、为了防止缓存在同一时间大面积过期导致的缓存雪崩，可以通过观察用户行为，合理</span><br><span class="line">设置缓存过期时间（错隔时间，在某个时间内来个随机时间值）来实现；</span><br><span class="line">2、为了防止缓存服务器宕机出现的缓存雪崩，可以使用分布式缓存，分布式缓存中每一</span><br><span class="line">个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用。</span><br><span class="line">3、也可以进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓</span><br><span class="line">存雪崩。</span><br><span class="line"></span><br><span class="line">坑七：</span><br><span class="line">缓存 “无底洞” 现象：指的是为了满足业务要求添加了大量缓存节点，但是性能不但没有</span><br><span class="line">好转反而下降了的现象。</span><br><span class="line">解决方案：</span><br><span class="line">1、优化批量数据操作命令，尽量不设置过期时间及持久化操作，单线程只处理内存操作即可；</span><br><span class="line">2、减少网络通信次数；</span><br><span class="line">3、降低接入成本，使用长连接 / 连接池，NIO 等。</span><br><span class="line"></span><br><span class="line">坑八：</span><br><span class="line">缓存并发：有时候如果网站并发访问高，一个缓存如果失效，可能出现多个进程同时查询DB，</span><br><span class="line">  同时设置缓存的情况，如果并发确实很大，这也可能造成DB压力过大，还有缓存</span><br><span class="line">  频繁更新的问题。</span><br><span class="line">解决方法：互斥锁。我现在的想法是对缓存查询加锁，如果KEY不存在，就加锁，然后查DB</span><br><span class="line">入缓存，然后解锁；</span><br><span class="line">其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询。</span><br><span class="line"></span><br><span class="line">这种情况和刚才说的预先设定值问题有些类似，只不过利用锁的方式，会造成部分请求等待。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如何从零设计缓存服务？</span><br><span class="line"></span><br><span class="line">尽量不用持久化（提前预热），过期时间（带时间戳，必要时起定时任务剔除）。</span><br><span class="line"></span><br><span class="line">并发访问大的页面相关数据要提前预热。</span><br><span class="line"></span><br><span class="line">修改keys，hgetall，smembers，shutdown,flushall, monitor，flushdb等长时</span><br><span class="line">间命令，使其无法使用批量耗时操作命令。</span><br><span class="line"></span><br><span class="line">设置慢查询的值，定期查询慢查询日志。</span><br><span class="line"></span><br><span class="line">尽可能使用散列表，而不是将对象转换成json字符串的形式。</span><br><span class="line"></span><br><span class="line">上线前演练如果缓存宕掉对系统的影响。</span><br><span class="line"></span><br><span class="line">做好监控及告警：命中率、内存使用情况、客户端连接数、峰值，请求和响应时间。</span><br><span class="line"></span><br><span class="line">搭建主从集群和哨兵模式环境。</span><br><span class="line"></span><br><span class="line">设置连接超时时间和请求超时时间。</span><br><span class="line"></span><br><span class="line">对数据库中不存在的数据回源给缓存一个空数据或者指定的默认值。</span><br><span class="line"></span><br><span class="line">对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁。</span><br><span class="line"></span><br><span class="line">做好缓存系统的设计和评审指标。</span><br><span class="line"></span><br><span class="line">规范来限制各个应用使用的key有唯一的前缀。</span><br><span class="line"></span><br><span class="line">缓存数据过大，建议序列化，或者拆分。</span><br><span class="line"></span><br><span class="line">额外：</span><br><span class="line">缓存系统的设计和评审指标</span><br><span class="line">举例: 设计缓存系统要考虑的问题：容量评估、客户端长连接数、</span><br><span class="line">  并发量（平均、最高）、最慢响应时间、使用成本、容灾性、</span><br><span class="line">  缓存对象粒度大小（太大要考虑序列化，如果protobuf,kryo）</span><br><span class="line">1、容量规划（根据容量评估的结果来申请和分配缓存资源，否则会造成资源浪费或者缓存空间不够）</span><br><span class="line">缓存内容的数量、大小、数据结构、失效时间</span><br><span class="line">淘汰策略</span><br><span class="line">每秒的读、写峰值</span><br><span class="line"></span><br><span class="line">2、性能优化</span><br><span class="line">线程模型：配置成NIO形式</span><br><span class="line">预热方法</span><br><span class="line">缓存分片（尽量不用，比较复杂）</span><br><span class="line">冷热数据的比例</span><br><span class="line"></span><br><span class="line">3、高可用</span><br><span class="line"></span><br><span class="line">4、缓存监控</span><br><span class="line">缓存服务监控</span><br><span class="line">缓存容量监控（内存使用）</span><br><span class="line">缓存请求监控（大对象会影响请求响应。）</span><br><span class="line">缓存响应时间监控（慢查询）</span><br><span class="line"></span><br><span class="line">5、注意事项举例</span><br><span class="line">是否有可能发生缓存穿透</span><br><span class="line">是否有大对象</span><br><span class="line">是否使用缓存实现分布式锁</span><br><span class="line">是否避免了Race Condition（竞争条件，并发）</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">建议将使用缓存的业务进行分离，核心业务和非核心业务使用不同的</span><br><span class="line">缓存实例，从物理上进行隔离，如果有条件，则请对每个业务使用单</span><br><span class="line">独的实例或者集群，以减小应用之间互相影响的可能性。</span><br><span class="line"></span><br><span class="line">如果缓存设置了超时时间，如果超时设置得较长，从而拖垮服务的线</span><br><span class="line">程池，最终导致服务雪崩的情况。</span><br><span class="line"></span><br><span class="line">如果多个业务共享一套缓存服务，我们得规范来限制各个应用使用的</span><br><span class="line">key有唯一的前缀，并进行隔离设计，避免产生缓存互相覆盖的问题。</span><br><span class="line"></span><br><span class="line">任何缓存的key都必须设定缓存失效时间，且失效时间不能集中在某</span><br><span class="line">一点，否则会导致缓存占满内存或者缓存雪崩。</span><br><span class="line"></span><br><span class="line">对于存储较多value的key，尽量不要使用HGETALL、keys等集合批量</span><br><span class="line">命令操作(可用scan命令)，该操作会造成请求阻塞，影响其他应用的访问。</span><br><span class="line"></span><br><span class="line">缓存的数据不易过大，尤其是Redis，因为Redis使用的是单线程模型，</span><br><span class="line">在单个缓存key的数据过大时，会阻塞其他请求的处理。</span><br><span class="line"></span><br><span class="line">在使用本地缓存（如Ehcache）时，一定要严格控制缓存对象的个数及</span><br><span class="line">声明周期。由于JVM的特性，过多的缓存对象会极大影响JVM的性能，</span><br><span class="line">甚至导致内存溢出等。</span><br><span class="line"></span><br><span class="line">在使用缓存时，一定要有降级处理，否则请求并发过高容易拖垮应用</span><br><span class="line">服务。（代码层面如try catch，设置连接及访问redis的超时时间）</span><br><span class="line"></span><br><span class="line">利益化：面试时会问什么样的问题？（高级开发，架构师，cto不同的角色）</span><br><span class="line">TODO</span><br><span class="line"></span><br><span class="line">通过在github上搜索&quot;架构&quot;或者&quot;java面试&quot; 里面会有对应的资源（redis）可以深入学习。</span><br><span class="line">或者https://github.com/aalansehaiyang/technology-talk/blob/master/system-architecture/architecture-experience.md</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;耗时1个多月空闲出来的时间学习整理的redis相关知识。&lt;br&gt;
    
    </summary>
    
      <category term="缓存" scheme="https://ouzhrm.github.io/categories/%E7%BC%93%E5%AD%98/"/>
    
    
      <category term="redis" scheme="https://ouzhrm.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>学习一门技术的思路过程</title>
    <link href="https://ouzhrm.github.io/2019/08/22/%E5%AD%A6%E4%B9%A0%E6%9F%90%E4%B8%80%E9%97%A8%E6%8A%80%E6%9C%AF%E7%9A%84%E6%80%9D%E8%B7%AF%E8%BF%87%E7%A8%8B/"/>
    <id>https://ouzhrm.github.io/2019/08/22/学习某一门技术的思路过程/</id>
    <published>2019-08-22T03:40:58.000Z</published>
    <updated>2019-08-22T04:10:32.691Z</updated>
    
    <content type="html"><![CDATA[<p>在学习一门技术之前，<br>是不是应该思考这门技术对我们的项目有那些用处，<br>解决了那些痛点，如何系统的去学习这门技术？<br>好，废话不多说，聊聊我最近的一些思考！<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">干货来了，可以按照下面的顺序问题去学习！</span><br><span class="line">1、为什么要用这门技术？之前的项目遇到过什么样的问题？</span><br><span class="line">2、这门技术相对于其他的同类技术，为什么选用这门技术？两者或者多者的比较？有哪些优缺点？</span><br><span class="line">    举例：</span><br><span class="line">如自身的相关数值：数据量、TPS、响应时间。</span><br><span class="line">缓存相关的有：本地缓存、分布式缓存（redis、mamcached）、客户端缓存、数据库缓存。</span><br><span class="line">选型指标：容量、并发量、响应时间、使用成本、扩展性、容灾。</span><br><span class="line">3、这门技术可以运用在什么场景上？</span><br><span class="line">4、如何运用这门技术？这门技术是怎么实现的？？</span><br><span class="line">5、如何保证高可用和一致性等等？</span><br><span class="line">6、用这门技术可能会有什么坑？亲身经历有什么坑？如何解决？？有没备选或者应急方案？？</span><br><span class="line">举例：</span><br><span class="line">https://github.com/aalansehaiyang/technology-talk/blob/master/system-architecture/architecture-experience.md</span><br><span class="line">（可以看看缓存那一块）</span><br><span class="line">7、利益化：面试时会问什么样的问题？（高级开发，架构师，cto不同的角色）</span><br><span class="line"></span><br><span class="line">参考示例文章如：https://data.qq.com/article?id=2879</span><br></pre></td></tr></table></figure></p><font color="#A52A2A" size="2"><br>思路决定出路，思想决定高度！<br>磨刀不误砍柴工！<br>高级开发看到技术，架构看到未来，cto看到价值！<br></font>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在学习一门技术之前，&lt;br&gt;是不是应该思考这门技术对我们的项目有那些用处，&lt;br&gt;解决了那些痛点，如何系统的去学习这门技术？&lt;br&gt;好，废话不多说，聊聊我最近的一些思考！&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://ouzhrm.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>springcloud集成protocol buffer传输协议一些总结</title>
    <link href="https://ouzhrm.github.io/2018/12/04/springcloud%E9%9B%86%E6%88%90protocol-buffer%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/"/>
    <id>https://ouzhrm.github.io/2018/12/04/springcloud集成protocol-buffer传输协议一些总结/</id>
    <published>2018-12-04T13:36:07.000Z</published>
    <updated>2018-12-04T14:29:40.897Z</updated>
    
    <content type="html"><![CDATA[<p>protocol buffer是什么？<br>protocol buffer是google定义的一种传输格式协议，类似json和xml，它的<br>优势在于它的传输体积小，解析速度快，如果传输的数据特别大，它传输的<br>速度及解析的速度是json和xml解析的指数级别。之前有记得看过一本书，<br>是用Gzip压缩数据来传输，从而实现传输体积小的目的，但是它有一个缺点<br>就是解压缩的时候特别耗计算机cpu性能。而protocol buffer它是通过对对<br>象进行序列化和反序列化的。<br><a id="more"></a></p><p>protocol buffer序列化和反序列化的原理？<br>本质还是对象与字节之间转换的传输，比如入参通过把字节转换成对象，<br>通过双方定义的格式，而出参是通过将对象转换成字节。也就是在网络中<br>传输还是通过字节的形式，可以想象一下字母转换成0101010001类似的格<br>式。笔者对四层tcp/ip网络协议，七层osi网络协议不是特别理解，大家<br>有特别懂的，私信我一下，万分感激。字节具体可以理解成二进制串。类似<br>映射键值对那种，中间加个长度。如k1-1-v1-k2-6-v2-…（这一块后面我再<br>仔细研究，深入它为什么解析速度会这么快的原理）</p><p>springcloud是怎么集成protocol buffer的？（重点描述！！）<br>因为用spring全家桶的原因，eureka作为配置和注册发现中心，feign消费方<br>是怎么通过protobuf来调用生产方的呢？<br>1.下载protobuf<br><a href="https://github.com/google/protobuf/releases" target="_blank" rel="noopener">https://github.com/google/protobuf/releases</a><br>选择protoc-xxx-win32.zip下载<br>2.将解压出来的protoc.exe放在C:\Windows\System32目录下，<br>同时在windows环境变量中新建proto_path变量，值为C:\Windows\System32\protoc.exe的路径<br>3.在所使用的proto文件路径下打开cmd窗口执行以下命令<br>4.执行protoc –version命令检查是否安装成功<br>protoc –version<br>5.然后写proto文件，生成一个RetreatCouponReqConvert.proto文件<br>文件内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto2&quot;;</span><br><span class="line">package com.carlife.coupon.proto.model; //输出路径</span><br><span class="line">option java_outer_classname = &quot;RetreatCouponReqConvertModel&quot;;  //输出的类名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">message RetreatCouponReqConvert&#123;</span><br><span class="line">    required string orderId = 1 ;</span><br><span class="line">    required string couponCode   = 2 ;</span><br><span class="line">    required string srcPartnerId   = 3 ;</span><br><span class="line">    required string sign   = 4 ;</span><br><span class="line">    required string caller   = 5 ;</span><br><span class="line">    required string noise   = 6 ;</span><br><span class="line">    required string reqId   = 7 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个文件对应的java文件如：RetreatCouponReqConvert.java<br>内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class RetreatCouponReqConvert extends BaseReq implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">  private static final Long serialVersionUID = 5797586702757567145L;</span><br><span class="line"></span><br><span class="line">  @NotBlank</span><br><span class="line">  @ApiModelProperty(value = &quot;订单id&quot;,required = true)</span><br><span class="line">  private String orderId; // required</span><br><span class="line"></span><br><span class="line">  @NotBlank</span><br><span class="line">  @ApiModelProperty(value = &quot;券码&quot;,required = true)</span><br><span class="line">  private String couponCode; // required</span><br><span class="line"></span><br><span class="line">  @NotBlank</span><br><span class="line">  @ApiModelProperty(value = &quot;退款商户ID&quot;,required = true)</span><br><span class="line">  private String srcPartnerId;</span><br><span class="line">  </span><br><span class="line">   /**</span><br><span class="line">     * 签名</span><br><span class="line">     */</span><br><span class="line">    @ApiModelProperty(value = &quot;【必填】签名&quot;)</span><br><span class="line">    @NotBlank</span><br><span class="line">    private String sign;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 调用者，和签名一起传入，用于校验</span><br><span class="line">     */</span><br><span class="line">    @ApiModelProperty(value = &quot;【必填】调用者，和签名一起传入，用于校验&quot;)</span><br><span class="line">    @NotBlank</span><br><span class="line">    private String caller;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 随机数（例如 访问时间戳）</span><br><span class="line">     */</span><br><span class="line">    @ApiModelProperty(value = &quot;【必填】随机数（例如 访问时间戳）&quot;)</span><br><span class="line">    @NotBlank</span><br><span class="line">    private String noise;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 访问请求ID</span><br><span class="line">     */</span><br><span class="line">    @ApiModelProperty(value = &quot;【必填】访问请求ID&quot;)</span><br><span class="line">    @NotBlank</span><br><span class="line">    private String reqId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后跑一下这个文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.carlife.common.utils;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * protoc.exe -I=proto的输入目录 --java_out=java类输出目录 proto的输入目录包括包括proto文件</span><br><span class="line"> * </span><br><span class="line"> * @author Administrator</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class GenerateClass &#123;</span><br><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">String protoFile = &quot;RetreatCouponReqConvert.proto&quot;;</span><br><span class="line">String path = &quot;D:/cashier-master/cashier-master/cashier-sdk/src/main/java/com/carlife/coupon/proto&quot;;</span><br><span class="line">String out =  &quot;D:/cashier-master/cashier-master/cashier-sdk/src/main/java&quot;;</span><br><span class="line">String strCmd = &quot;C:/Windows/System32/protoc.exe -I=&quot; + path +</span><br><span class="line">&quot; --java_out=&quot; + out + &quot; &quot; + path + &quot;/&quot; + protoFile;</span><br><span class="line">System.out.println(strCmd);</span><br><span class="line">Runtime.getRuntime().exec(strCmd);</span><br><span class="line">System.out.println(&quot;完成&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果RetreatCouponReqConvertModel.java没有生成，粘strCmd出来到git命令行窗口跑,找下原因</p><p>依赖jar包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.protobuf&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;protobuf-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.6.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.googlecode.protobuf-java-format&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;protobuf-java-format&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.protobuf&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;protobuf-java-util&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.6.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;gson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.8.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>feign（调用者）端在启动如SpringApplication.java启动文件同级目录下增加以下配置文件</p><p>内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package com.carlife;</span><br><span class="line"></span><br><span class="line">import feign.codec.Decoder;</span><br><span class="line">import feign.codec.Encoder;</span><br><span class="line">import org.springframework.beans.factory.ObjectFactory;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.autoconfigure.web.HttpMessageConverters;</span><br><span class="line">import org.springframework.cloud.netflix.feign.support.ResponseEntityDecoder;</span><br><span class="line">import org.springframework.cloud.netflix.feign.support.SpringDecoder;</span><br><span class="line">import org.springframework.cloud.netflix.feign.support.SpringEncoder;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.http.converter.protobuf.ProtobufHttpMessageConverter;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class ProtoFeignConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ObjectFactory&lt;HttpMessageConverters&gt; messageConverters;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    ProtobufHttpMessageConverter protobufHttpMessageConverter() &#123;</span><br><span class="line">        return new ProtobufHttpMessageConverter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Encoder springEncoder()&#123;</span><br><span class="line">        return new SpringEncoder(this.messageConverters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Decoder springDecoder()&#123;</span><br><span class="line">        return new ResponseEntityDecoder(new SpringDecoder(this.messageConverters));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>生产者（被调用者）端同样在启动如SpringApplication.java启动文件同级目录下增加以下配置文件<br>内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.carlife.coupon;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.http.converter.protobuf.ProtobufHttpMessageConverter;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class ProtoBufServerConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    ProtobufHttpMessageConverter protobufHttpMessageConverter() &#123;</span><br><span class="line">        return new ProtobufHttpMessageConverter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后一步，编写消费接口和生产接口<br>消费接口类似的内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(method = RequestMethod.POST, value = &quot;/retreatCouponPb&quot;, consumes = &quot;application/x-protobuf&quot;,produces=&quot;application/x-protobuf&quot;)</span><br><span class="line">RetreatCouponRspModel.RetreatCouponRsp retreatCouponPb(RetreatCouponReqConvertModel.RetreatCouponReqConvert req);</span><br></pre></td></tr></table></figure></p><p>生产接口类似的内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(value = &quot;retreatCouponPb&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public RetreatCouponRspModel.RetreatCouponRsp retreatCouponPb(@RequestBody RetreatCouponReqConvertModel.RetreatCouponReqConvert req) &#123;</span><br><span class="line">String couponCode = req.getCouponCode();</span><br><span class="line">System.out.println(&quot;couponCode : &quot;+couponCode);</span><br><span class="line">RetreatCouponRspModel.RetreatCouponRsp.Builder builder = RetreatCouponRspModel.RetreatCouponRsp.newBuilder();</span><br><span class="line">builder.setMsg(&quot;-----OK----&quot;);</span><br><span class="line">builder.setCode(RspMsgCodeEnum.SUCCESS.getValue());</span><br><span class="line">return builder.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后用下面来调用消费接口即可，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(value = &quot;testProto&quot;)</span><br><span class="line">public void testProto(@RequestBody RefundOrderReq refundOrderReq) &#123;</span><br><span class="line">RetreatCouponReqConvertModel.RetreatCouponReqConvert build = RetreatCouponReqConvertModel.RetreatCouponReqConvert.newBuilder()</span><br><span class="line">.setCaller(&quot;123&quot;).setCouponCode(&quot;888888888888888888&quot;)</span><br><span class="line">.setNoise(&quot;123&quot;).setOrderId(&quot;123&quot;).setReqId(&quot;123&quot;)</span><br><span class="line">.setSign(&quot;123&quot;).setSrcPartnerId(&quot;123&quot;).build();</span><br><span class="line">RetreatCouponRspModel.RetreatCouponRsp retreatCouponRsp = couponProviderV2.retreatCouponPb(build);</span><br><span class="line">System.out.println(&quot;code = &quot;+retreatCouponRsp.getCode()+&quot;msg = &quot;+retreatCouponRsp.getMsg());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上可能不是写的很详细，深感抱歉，但希望能帮助到有需要的人。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;protocol buffer是什么？&lt;br&gt;protocol buffer是google定义的一种传输格式协议，类似json和xml，它的&lt;br&gt;优势在于它的传输体积小，解析速度快，如果传输的数据特别大，它传输的&lt;br&gt;速度及解析的速度是json和xml解析的指数级别。之前有记得看过一本书，&lt;br&gt;是用Gzip压缩数据来传输，从而实现传输体积小的目的，但是它有一个缺点&lt;br&gt;就是解压缩的时候特别耗计算机cpu性能。而protocol buffer它是通过对对&lt;br&gt;象进行序列化和反序列化的。&lt;br&gt;
    
    </summary>
    
    
      <category term="springcloud" scheme="https://ouzhrm.github.io/tags/springcloud/"/>
    
      <category term="protocol buffer" scheme="https://ouzhrm.github.io/tags/protocol-buffer/"/>
    
      <category term="eureka" scheme="https://ouzhrm.github.io/tags/eureka/"/>
    
  </entry>
  
  <entry>
    <title>mybatis源码分析《二》 - 接口实现原理</title>
    <link href="https://ouzhrm.github.io/2018/07/31/mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%8A%E4%BA%8C%E3%80%8B-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://ouzhrm.github.io/2018/07/31/mybatis源码分析《二》-接口实现原理/</id>
    <published>2018-07-31T12:34:37.000Z</published>
    <updated>2018-07-31T12:38:13.257Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><img src="/images/mybatis_jiekou_shixianyuanli/mybatis_jiekou_01.png" alt="图片不存在了，请联系博主更新图片"><br><img src="/images/mybatis_jiekou_shixianyuanli/mybatis_jiekou_02.png" alt="图片不存在了，请联系博主更新图片"><br><img src="/images/mybatis_jiekou_shixianyuanli/mybatis_jiekou_03.png" alt="图片不存在了，请联系博主更新图片"><br><img src="/images/mybatis_jiekou_shixianyuanli/mybatis_jiekou_04.png" alt="图片不存在了，请联系博主更新图片"><br><img src="/images/mybatis_jiekou_shixianyuanli/mybatis_jiekou_05.png" alt="图片不存在了，请联系博主更新图片"><br><img src="/images/mybatis_jiekou_shixianyuanli/mybatis_jiekou_06.png" alt="图片不存在了，请联系博主更新图片"><br><img src="/images/mybatis_jiekou_shixianyuanli/mybatis_jiekou_07.png" alt="图片不存在了，请联系博主更新图片"><br><img src="/images/mybatis_jiekou_shixianyuanli/mybatis_jiekou_08.png" alt="图片不存在了，请联系博主更新图片"><br><img src="/images/mybatis_jiekou_shixianyuanli/mybatis_jiekou_09.png" alt="图片不存在了，请联系博主更新图片"><br><img src="/images/mybatis_jiekou_shixianyuanli/mybatis_jiekou_10.png" alt="图片不存在了，请联系博主更新图片"><br><img src="/images/mybatis_jiekou_shixianyuanli/mybatis_jiekou_11.png" alt="图片不存在了，请联系博主更新图片"><br><img src="/images/mybatis_jiekou_shixianyuanli/mybatis_jiekou_12.png" alt="图片不存在了，请联系博主更新图片"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;/images/mybatis_jiekou_shixianyuanli/mybatis_jiekou_01.png&quot; alt=&quot;图片不存在了，请联系博主更新图片&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/myba
      
    
    </summary>
    
    
      <category term="mybatis" scheme="https://ouzhrm.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis源码分析《一》 - 整体结构</title>
    <link href="https://ouzhrm.github.io/2018/07/24/mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%8A%E4%B8%80%E3%80%8B-%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84/"/>
    <id>https://ouzhrm.github.io/2018/07/24/mybatis源码分析《一》-整体结构/</id>
    <published>2018-07-24T03:09:58.000Z</published>
    <updated>2019-09-23T10:06:22.764Z</updated>
    
    <content type="html"><![CDATA[<p>在学习mybatis之前我们先了解一下jdbc。<br>Jdbc操作数据库的步骤：<br>1、    加载驱动<br>2、    获取数据库连接<br>3、    根据数据库连接操作数据库，实现增删改查<br>4、    关闭资源。<br><a id="more"></a><br>举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">String URL = &quot;jdbc:mysql://127.0.0.1:3306/bootdo?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;;</span><br><span class="line">String USER = &quot;root&quot;;</span><br><span class="line">String PASSWORD = &quot;root&quot;;</span><br><span class="line">//1.加载驱动程序</span><br><span class="line">try &#123;</span><br><span class="line">    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">//2.获得数据库链接</span><br><span class="line">Connection conn = DriverManager.getConnection(URL, USER, PASSWORD);</span><br><span class="line">//3.通过数据库的连接操作数据库，实现增删改查（使用Statement类）</span><br><span class="line">Statement st = conn.createStatement();</span><br><span class="line"></span><br><span class="line">ResultSet resultSet = st.executeQuery(&quot;select * from student&quot;);</span><br><span class="line">long age = 0;</span><br><span class="line">while (resultSet.next()) &#123;</span><br><span class="line">    age = resultSet.getLong(&quot;age&quot;);</span><br><span class="line">    age++;</span><br><span class="line">&#125;</span><br><span class="line">boolean rs = st.execute(&quot;update student set age = &quot; + age + &quot; where id = 13&quot;);</span><br><span class="line">System.out.println(rs);</span><br><span class="line">//关闭资源</span><br><span class="line">st.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure></p><p>mybatis是由jdbc演变而来的，目的是简化jdbc操作步骤，提高jdbc操作性能。</p><h4 id="mybatis解决了jdbc的什么问题？"><a href="#mybatis解决了jdbc的什么问题？" class="headerlink" title="mybatis解决了jdbc的什么问题？"></a>mybatis解决了jdbc的什么问题？</h4><p>1、    使用连接池代替了获取数据库连接，有效的循环利用连接资源。<br>我们知道，以mysql为例，如果mysql的连接数大于设置的最大连接数，就会因资源占用<br>而导致数据库宕机。<br>我们可以修改mysql最大连接数：打开my.ini，修改max_connections=100(默认为100)。<br>此外还有执行sql来设置最大连接数，此处就不多讲。<br>2、    操作方便，使用简单，简单数据库操作可以使用面向接口编程，特别适合一些大型<br>企业项目，减少重复性代码。<br>3、    待补充。。</p><h4 id="mybatis的整体结构"><a href="#mybatis的整体结构" class="headerlink" title="mybatis的整体结构"></a>mybatis的整体结构</h4><p>在分析mybatis源码之前，我们先看看mybatis的整体结构，这样在深入读源码的时候不会绕晕。<br>mybatis可以整体分成四层分析。</p><p>接口层，也是最上层，提供了给咋们用的增删改查的接口，而接口的调用方式分成，<br>第一种基于Mapper接口，也就是我们常常说的dao层映射到xml映射文件，或者采用<br>注解的形式，接口化编程的风格，也是我们集成spring的时候最常用的一种形式。<br>此外第二种是mybatis传统的调用方式，如sqlSession.selectList(statementId， Map形式的参数)，<br>statementId一般是类的全限定名。</p><p>数据处理层，分别是参数映射，sql解析，sql执行，结果集映射。参数映射是java数据格式转<br>化成sql参数格式，期间也会通过TypeHandler来操作java格式和sql格式参数之间的转换。但<br>主要的操作是在ParameterHandler这个类中进行的。它会调起TypeHandler进行操作。Sql解析，<br>也就是将sql和参数拼凑起来形成一个完整的可执行的sql，它的操作是在sqlSource中进行的。<br>而sql执行，是在Executor类中执行的，它底层封装了Statement相关实现类。调用的是statement<br>类的execute方法或者是executeQuery方法。最后是结果集映射，我们知道jdbc执行sql后生成的<br>结果集，我们还得自己去转成java数据格式或者封装对象属性相关的数据。这时mybatis提供了<br>结果集映射成java类型的ResultSetHandler类，期间也会调用TypeHandler来完成原生结果集转<br>换成我们想要的java数据格式。</p><p>框架支撑层，无非就是连接池、事务、和缓存，这些来支撑我们执行sql提供了一系列相关的保障。<br>连接池保证了咋们的宝贵的连接资源可重复利用。事务保证了执行sql的一致性、隔离性、永久性、</p><p>原子性。缓存提高了相同查询结果的性能。<br>引导层，不多说了，怎么用这个框架，引导去用的相关问题。</p><h4 id="下面是结构图："><a href="#下面是结构图：" class="headerlink" title="下面是结构图："></a>下面是结构图：</h4><p><img src="/images/jiegoutu.png" alt="图片不存在了，请联系博主更新图片"></p><h4 id="下面是各层次的调用图。"><a href="#下面是各层次的调用图。" class="headerlink" title="下面是各层次的调用图。"></a>下面是各层次的调用图。</h4><p><img src="/images/cengcidiaoyongtu.png" alt="图片不存在了，请联系博主更新图片"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在学习mybatis之前我们先了解一下jdbc。&lt;br&gt;Jdbc操作数据库的步骤：&lt;br&gt;1、    加载驱动&lt;br&gt;2、    获取数据库连接&lt;br&gt;3、    根据数据库连接操作数据库，实现增删改查&lt;br&gt;4、    关闭资源。&lt;br&gt;
    
    </summary>
    
    
      <category term="mybatis" scheme="https://ouzhrm.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>代码规范的一些总结</title>
    <link href="https://ouzhrm.github.io/2018/07/10/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/"/>
    <id>https://ouzhrm.github.io/2018/07/10/代码规范的一些总结/</id>
    <published>2018-07-10T09:41:09.000Z</published>
    <updated>2018-07-10T09:43:25.008Z</updated>
    
    <content type="html"><![CDATA[<p>IDEA先安装alibaba coding插件和FindBug的插件。<br>然后下面的一些问题：<br>阿里巴巴代码规范插件扫描出来的问题：</p><p>1、不能name.equals(“”)，而应该””.equals(name) ，否则容易报空指针<br><a id="more"></a><br>2、不能这样写：<br>if(x&gt;1) return msg;<br>或者<br>if(x&gt;1)<br>return msg;<br>应该<br>if(x&gt;1){<br>return msg;<br>}</p><p>3、不能使用过时的类和方法<br>如：org.apache.http.conn.ssl.SSLContexts这个类已经过时了</p><p>4、常量因为都是大写<br>如：<br>public static final String Algorithm_Dsa= “DSA”;<br>而应该：<br>public static final String ALGORITHM_DSA = “DSA”;</p><p>5、变量应该遵循驼峰<br>如：public static String sign(Object data, String private_key) throws Exception {}<br>而应该<br>public static String sign(Object data, String privateKey) throws Exception {}</p><p>6、long型常量应该以大写L结尾<br>如：public static final long TIME_LENGTH= 864000l;<br>而应该：<br>public static final long TIME_LENGTH= 864000L;</p><p>7、重写equals()、toString()、hashcode()方法上方应该加@Override</p><p>8、枚举类对应的字段都要加上注释，不然以后自己都可能会忘记。</p><p>9、集合初始化时，应该指定集合初始值大小。如果HashMap不填默认长度为16，默认阈值为0.75，一旦超过12个元素就会触发扩容。<br>毕竟集合扩容也挺耗性能的嘛</p><p>10、所有类都必须添加创建者信息，不然出了问题不好确定时，还得去git上查历史记录。</p><p>11、等等….</p><p>此外还有FindBugs插件的使用，这里具体就不说了，挺好用额，扫出来的问题能更好的提高代码的健壮性。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;IDEA先安装alibaba coding插件和FindBug的插件。&lt;br&gt;然后下面的一些问题：&lt;br&gt;阿里巴巴代码规范插件扫描出来的问题：&lt;/p&gt;
&lt;p&gt;1、不能name.equals(“”)，而应该””.equals(name) ，否则容易报空指针&lt;br&gt;
    
    </summary>
    
    
      <category term="代码规范" scheme="https://ouzhrm.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>数据传输中的安全性的一点思考</title>
    <link href="https://ouzhrm.github.io/2018/06/30/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/"/>
    <id>https://ouzhrm.github.io/2018/06/30/数据传输中的安全性的一点思考/</id>
    <published>2018-06-30T04:20:55.000Z</published>
    <updated>2018-07-01T07:17:30.292Z</updated>
    
    <content type="html"><![CDATA[<p>本次总结主要以技术为主，到了6月30号了，转眼间，收银台项目已经建立起来有两个多月了，<br>从刚开始的我负责，到两个人负责，现在是4个人负责，建立起来了支付组。后边还得继续<br>招小伙伴，很累，但也收获很多，现在收银台包含支付网关、券系统、账户系统、交易系统、<br>收银台入口等多个模块，说白了，只要涉及到钱的功能，都得过我们这一边。废话不多说，<br>技术撸上：<br><a id="more"></a><br>首先是安全性，收银台跟钱相关的，所以我们把安全性作为项目第一位考虑的，数据对内部<br>要防篡改，对外部数据传输要加密，为什么安全性排第一位呢？就是数据传输过程中，黑客把数据<br>拦截了下来，然后对数据进行一番改造，假设充值时，把0.1元字段改成10000元，黑客实际支付了<br>0.1元，然后在提现时就可能提出10000元来，当然这是简单的假设举例，而实际上提现更为复杂，<br>经过多重校验和多重审核。我们实现的是防篡改和防破解的思想是这样的：先用工具生成非对称性的<br>公私钥对，私钥加密，公钥解密，数据在网络传输前先用私钥加密，到达服务端时用公钥解密，而防<br>破解私钥，我们在数据的传输前加入一个随机数字段，这样保证每一次密文都是不一样的。但我们如<br>果供对内部的系统调用则主要是防篡改，干货来了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></td><td class="code"><pre><span class="line">package com.carlife.common.sign.utils;</span><br><span class="line"></span><br><span class="line">import com.carlife.cashier.vo.CashierPrepayReq;</span><br><span class="line">import sun.misc.BASE64Decoder;</span><br><span class="line">import sun.misc.BASE64Encoder;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.security.*;</span><br><span class="line">import java.security.interfaces.DSAPrivateKey;</span><br><span class="line">import java.security.interfaces.DSAPublicKey;</span><br><span class="line">import java.security.spec.PKCS8EncodedKeySpec;</span><br><span class="line">import java.security.spec.X509EncodedKeySpec;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 签名验签算法:DSA</span><br><span class="line"> * 1、生成密钥对</span><br><span class="line"> * 2、签名</span><br><span class="line"> * 3、验签</span><br><span class="line"> */</span><br><span class="line">public class DSASignaureUtil &#123;</span><br><span class="line">    public static final String  Algorithm_DSA=&quot;DSA&quot;;</span><br><span class="line">    //默认密钥字节数</span><br><span class="line">    private static final int key_size=1024;</span><br><span class="line">    //默认种子</span><br><span class="line">    public static final String default_seed=&quot;0f22507a10bbddd07d8a3082122966e3&quot;;</span><br><span class="line"></span><br><span class="line">    public static final String public_key = &quot;DSAPublicKey&quot;;</span><br><span class="line">    public static final String private_key = &quot;DSAPrivateKey&quot;;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 生成密钥种子</span><br><span class="line">     * @param seed</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static Map initKey(String seed) throws Exception&#123;</span><br><span class="line">        KeyPairGenerator keygen = KeyPairGenerator.getInstance(Algorithm_DSA);</span><br><span class="line">        //　初始化随机产生器</span><br><span class="line">        SecureRandom secureRandom = new SecureRandom();</span><br><span class="line">        secureRandom.setSeed(seed.getBytes());</span><br><span class="line">        keygen.initialize(key_size,secureRandom);</span><br><span class="line">        KeyPair keys = keygen.genKeyPair();</span><br><span class="line">        DSAPublicKey publicKey = (DSAPublicKey) keys.getPublic();</span><br><span class="line">        DSAPrivateKey privateKey = (DSAPrivateKey) keys.getPrivate();</span><br><span class="line">        Map map = new HashMap(2);</span><br><span class="line">        map.put(public_key,publicKey);</span><br><span class="line">        map.put(private_key,privateKey);</span><br><span class="line"></span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * description: 加签名方法 &lt;p&gt;</span><br><span class="line">    * param: [data, private_key] &lt;p&gt;</span><br><span class="line">    * return: java.lang.String &lt;p&gt;</span><br><span class="line">    * author: shicong yang&lt;p&gt;</span><br><span class="line">    * date: 2018/6/28 &lt;p&gt;</span><br><span class="line">    */</span><br><span class="line">    public static String sign(Object data,String private_key)throws Exception&#123;</span><br><span class="line">       return  sign(getData(data),private_key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 用私钥对信息生成数字签名</span><br><span class="line">     * @param data 加密数据</span><br><span class="line">     * @param privateKey 私钥</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static String sign(byte[] data,String privateKey)throws Exception&#123;</span><br><span class="line">        //　解密由base64编码的私钥</span><br><span class="line">        byte[] keyBytes = decryptBASE64(privateKey);</span><br><span class="line">        //　构造PKCS8EncodedKeySpec对象</span><br><span class="line">        //PKCS#8:描述私有密钥信息格式，该信息包括公开密钥算法的私有密钥以及可选的属性集等[27]。</span><br><span class="line">        PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes);</span><br><span class="line">        //　KEY_ALGORITHM　指定的加密算法</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(Algorithm_DSA);</span><br><span class="line">        //　取私钥匙对象</span><br><span class="line">        PrivateKey priKey = keyFactory.generatePrivate(pkcs8KeySpec);</span><br><span class="line">        //用私钥对信息生成数字签名</span><br><span class="line">        Signature signature = Signature.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        signature.initSign(priKey);</span><br><span class="line">        signature.update(data);</span><br><span class="line"></span><br><span class="line">        return encryptBASE64(signature.sign());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean verify(Object data,String publicKey,String sign) throws Exception &#123;</span><br><span class="line">        return verify(getData(data),publicKey,sign);</span><br><span class="line">    &#125;</span><br><span class="line">    /***</span><br><span class="line">     * 校验数字签名</span><br><span class="line">     * @param data 加密数据</span><br><span class="line">     * @param publicKey 公钥</span><br><span class="line">     * @param sign 数据签名</span><br><span class="line">     * @return 校验成功返回true　失败返回false</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static boolean verify(byte[] data,String publicKey,String sign) throws Exception &#123;</span><br><span class="line">        // 　解密由base64编码的公钥</span><br><span class="line">        byte[] keyBytes = decryptBASE64(publicKey);</span><br><span class="line">        // 　构造X509EncodedKeySpec对象</span><br><span class="line">        X509EncodedKeySpec keySpec = new X509EncodedKeySpec(keyBytes);</span><br><span class="line">        // 　ALGORITHM　指定的加密算法</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(Algorithm_DSA);</span><br><span class="line">        // 　取公钥匙对象</span><br><span class="line">        PublicKey pubKey = keyFactory.generatePublic(keySpec);</span><br><span class="line">        Signature signature = Signature.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        signature.initVerify(pubKey);</span><br><span class="line">        signature.update(data);</span><br><span class="line">        // 　验证签名是否正常</span><br><span class="line">        return signature.verify(decryptBASE64(sign));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 默认生成密钥</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static Map initKey() throws Exception &#123;</span><br><span class="line">        return initKey(default_seed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 取得私钥</span><br><span class="line">     * @param keyMap</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static String getPrivateKey(Map keyMap)throws Exception &#123;</span><br><span class="line">        Key key = (Key) keyMap.get(private_key);</span><br><span class="line">        return encryptBASE64(key.getEncoded());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 取得公钥</span><br><span class="line">     * @param keyMap</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static String getPublicKey(Map keyMap) throws Exception &#123;</span><br><span class="line">        Key key = (Key) keyMap.get(public_key);</span><br><span class="line">        return encryptBASE64(key.getEncoded());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * BASE64解密</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static byte[] decryptBASE64(String key) throws Exception &#123;</span><br><span class="line">        return (new BASE64Decoder()).decodeBuffer(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * BASE64 加密</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static String encryptBASE64(byte[] key) throws Exception &#123;</span><br><span class="line">        return (new BASE64Encoder()).encodeBuffer(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static byte[] getData(Object obj) throws IllegalAccessException &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">        //遍历本类</span><br><span class="line">        Class cls = obj.getClass();</span><br><span class="line">        Field[] fields = cls.getDeclaredFields();</span><br><span class="line">        for (Field f : fields) &#123;</span><br><span class="line">            f.setAccessible(true);</span><br><span class="line">            if (f.get(obj) != null &amp;&amp; f.get(obj) != &quot;&quot; &amp;&amp; !f.getName().equals(&quot;sign&quot;) &amp;&amp; !f.getName().equals(&quot;caller&quot;)) &#123;</span><br><span class="line">                list.add(f.getName() + &quot;=&quot; + f.get(obj) + &quot;&amp;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //遍历超类</span><br><span class="line">        Class superclass = cls.getSuperclass();</span><br><span class="line">        Field[] superclassfields = superclass.getDeclaredFields();</span><br><span class="line">        for (Field f : superclassfields) &#123;</span><br><span class="line">            f.setAccessible(true);</span><br><span class="line">            if (f.get(obj) != null &amp;&amp; f.get(obj) != &quot;&quot; &amp;&amp; !f.getName().equals(&quot;sign&quot;) &amp;&amp; !f.getName().equals(&quot;caller&quot;)) &#123;</span><br><span class="line">                list.add(f.getName() + &quot;=&quot; + f.get(obj) + &quot;&amp;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int size = list.size();</span><br><span class="line">        String[] arrayToSort = list.toArray(new String[size]);</span><br><span class="line">        Arrays.sort(arrayToSort, String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            sb.append(arrayToSort[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        String result = sb.toString();</span><br><span class="line">        result = result.substring(0,result.length() -1);</span><br><span class="line">        System.err.println(result);</span><br><span class="line">        return result.getBytes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line"></span><br><span class="line">        CashierPrepayReq obj = new CashierPrepayReq();</span><br><span class="line">        obj.setOrderNo(&quot;111111&quot;);</span><br><span class="line">        obj.setPayChannel(2);</span><br><span class="line">        obj.setProductLine(&quot;auto&quot;);</span><br><span class="line">        obj.setOrderBody(&quot;测试&quot;);</span><br><span class="line">        obj.setSubject(&quot;测试&quot;);</span><br><span class="line">        obj.setOrderOwnerUserId(&quot;999&quot;);</span><br><span class="line">        obj.setTotalFee(1L);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;入参实体类:&quot;+obj.toString());</span><br><span class="line"></span><br><span class="line">        byte[] data = getData(obj);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String inputStr = &quot;Hello,你好啊！&quot;;</span><br><span class="line">        //byte[] data = inputStr.getBytes();</span><br><span class="line">        // 构建密钥</span><br><span class="line">        Map&lt;String, Object&gt; keyMap = DSASignaureUtil.initKey();</span><br><span class="line">        // 获得密钥</span><br><span class="line">        String publicKey = DSASignaureUtil.getPublicKey(keyMap);</span><br><span class="line">        String privateKey = DSASignaureUtil.getPrivateKey(keyMap);</span><br><span class="line">        System.err.println(&quot;公钥:\r&quot; + publicKey);</span><br><span class="line">        System.err.println(&quot;私钥:\r&quot; + privateKey);</span><br><span class="line">        // 产生签名</span><br><span class="line">        String sign = DSASignaureUtil.sign(data, privateKey);</span><br><span class="line">        System.err.println(&quot;签名:\r&quot; + sign);</span><br><span class="line">        // 验证签名</span><br><span class="line">        boolean status = DSASignaureUtil.verify(data, publicKey, sign);</span><br><span class="line">        System.err.println(&quot;状态:\r&quot; + status);</span><br><span class="line">        if(status)&#123;</span><br><span class="line">            System.out.println(&quot;原文:&quot;+new String(data));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以后，还要讨论收银台的稳定性（服务器宕机就没办法收钱？）、扩展性（需求如何快速加入？）、<br>统一性（收银台几个子系统操作步骤如何规划统一？）、高效性（用户体验？？）等等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本次总结主要以技术为主，到了6月30号了，转眼间，收银台项目已经建立起来有两个多月了，&lt;br&gt;从刚开始的我负责，到两个人负责，现在是4个人负责，建立起来了支付组。后边还得继续&lt;br&gt;招小伙伴，很累，但也收获很多，现在收银台包含支付网关、券系统、账户系统、交易系统、&lt;br&gt;收银台入口等多个模块，说白了，只要涉及到钱的功能，都得过我们这一边。废话不多说，&lt;br&gt;技术撸上：&lt;br&gt;
    
    </summary>
    
    
      <category term="安全" scheme="https://ouzhrm.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>秒杀系统的设计与实践《一》</title>
    <link href="https://ouzhrm.github.io/2018/05/20/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8A%E4%B8%80%E3%80%8B/"/>
    <id>https://ouzhrm.github.io/2018/05/20/秒杀系统的设计与实践《一》/</id>
    <published>2018-05-20T08:24:58.000Z</published>
    <updated>2018-05-20T08:40:06.401Z</updated>
    
    <content type="html"><![CDATA[<p>秒杀系统的设计思路。</p><p>1、下单过程：<br>校验库存<br>更新库存<br>创建订单<br>支付（本文暂先不考虑）<br><a id="more"></a><br>2、表的概要设计<br>库存表：id、名称、库存数、已售数，版本号（防止超卖）。<br>订单表：id、订单名称、库存表id，订单创建时间。</p><p>3、考虑到的问题。<br>首先，超卖问题，也就是说原来计划最大卖30个，结果卖了1000多个。<br>解决方法：采用乐观锁(CAS,比较并交换的意思，只有比较相等才能交换，否则不交换)。<br>更新库存的数据库语句可以这么设计，<br>update 库存表 set 版本号= 版本号+1,已售数 = 已售数+1<br>where 版本号 = 版本号 and id = 传过来的id<br>注：version_old_query是通过id查询出来的。</p><p>其次，数据库宕机和系统报错（查询数据库因为版本号不对，更新库存失败导致的报错）的问题，<br>数据库宕机往往是连接数不够导致的宕机，毕竟并发数比较大。<br>解决方法：限流+缓存。本身redis有限流，快速失败返回的策略，也就是限制访问数，每次访问<br>数只能是固定的，如果访问不到，则直接返回，这个限流类似java的信号量这个类。通过和<br>springmvc集成即可，而采用先查缓存，缓存里如果没有则去查数据库，这样，通过redis限流<br>把大部分流量拦截在上游，使之不能到达数据库，缓存提高查询效率等。很好的解决了数据层的<br>访问问题了，但redis最好采用集群的模式，毕竟秒杀的访问量还是很大的，我认为redis的限流<br>措施往往起到的保护系统的作用，限流最好用nginx、springcloud或者dubbo横向扩展来实现。</p><p>最后，如果进来到下单的并发量还是很大，可以将同步下单改成异步下单的形式。<br>解决方法：采用kafka发送库存的实体，然后马上返回，kafka和springboot集成的消费端，<br>采用线程池消费任务,对库存进行缓存和落地更新及创建订单，然后回调通知。</p><p>—— 未完待续 ——</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;秒杀系统的设计思路。&lt;/p&gt;
&lt;p&gt;1、下单过程：&lt;br&gt;校验库存&lt;br&gt;更新库存&lt;br&gt;创建订单&lt;br&gt;支付（本文暂先不考虑）&lt;br&gt;
    
    </summary>
    
    
      <category term="秒杀" scheme="https://ouzhrm.github.io/tags/%E7%A7%92%E6%9D%80/"/>
    
      <category term="并发" scheme="https://ouzhrm.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="电商" scheme="https://ouzhrm.github.io/tags/%E7%94%B5%E5%95%86/"/>
    
      <category term="订单" scheme="https://ouzhrm.github.io/tags/%E8%AE%A2%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>做收银台模块的经验总结</title>
    <link href="https://ouzhrm.github.io/2018/05/09/%E5%81%9A%E6%94%B6%E9%93%B6%E5%8F%B0%E6%A8%A1%E5%9D%97%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    <id>https://ouzhrm.github.io/2018/05/09/做收银台模块的经验总结/</id>
    <published>2018-05-09T09:37:10.000Z</published>
    <updated>2018-05-20T08:37:15.348Z</updated>
    
    <content type="html"><![CDATA[<p>1、仔细阅读官方文档，如预支付、退款、支付回调、查询模块，相关的请求参数、响应<br>参数以及开发的步骤，api字典等，还有应用公私密钥的生成方式（2048长度、java适用）、<br>注意应用公钥、应用私钥、支付宝公钥这几个别搞混了。<br><a id="more"></a><br>2、引进alipay sdk包的最好用maven方式。不要单独添加到项目来，然后build path<br>依赖一下，不然上线的时候会有很多的麻烦，报ClassNotFound等很多异常。<br>3、公网内网的问题，在回调响应的时候，如果配置成内网的地址，外网会访问不进来的，<br>所以最好配成域名的格式，这里困了大半天，晕。。。<br>4、app支付相关，如果只申请app支付的方式，那么只能用app支付，用官方的android或<br>者ios的demo支付，不然会根据订单号查询不出来，显示这个记录不存在。<br>5、java获取linux和windows系统当前ip的方式是不同的，如果想动态配置ip地址的，<br>这个最好了解一下。</p><p>————-     未完待续    —————</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、仔细阅读官方文档，如预支付、退款、支付回调、查询模块，相关的请求参数、响应&lt;br&gt;参数以及开发的步骤，api字典等，还有应用公私密钥的生成方式（2048长度、java适用）、&lt;br&gt;注意应用公钥、应用私钥、支付宝公钥这几个别搞混了。&lt;br&gt;
    
    </summary>
    
    
      <category term="支付" scheme="https://ouzhrm.github.io/tags/%E6%94%AF%E4%BB%98/"/>
    
  </entry>
  
  <entry>
    <title>再议索引</title>
    <link href="https://ouzhrm.github.io/2018/05/05/%E5%86%8D%E8%AE%AE%E7%B4%A2%E5%BC%95/"/>
    <id>https://ouzhrm.github.io/2018/05/05/再议索引/</id>
    <published>2018-05-05T10:23:03.000Z</published>
    <updated>2018-05-20T08:37:00.932Z</updated>
    
    <content type="html"><![CDATA[<h5 id="关于索引的使用"><a href="#关于索引的使用" class="headerlink" title="关于索引的使用"></a>关于索引的使用</h5><p>1、最适合建索引的列有：where后边的、联接（join）条件相关的列、<br>order by相关的列、group by 相关的列。<br>2、数据量区分度要大些，如男女数据量各占50%的就不需要建索引。<br><a id="more"></a><br>3、索引的长度(体积)尽可能的小。<br>4、复合索引要充分满足最左前缀。如：建的复合索引为</p><p>（state、city、zip），则能命中索引的条件有：<br>state、city、zip<br>state、city<br>state<br>5、索引建的数量要适当，因为索引多的话，查询快了，但是更新慢。<br>6、InnoDB，MYISAM总是使用B+树索引。MEMORY存储引擎默认使用Hash索引.<br>Hash索引在使用“=”，“&lt;=&gt;”比较快，范围查找比较慢，如：id&lt;30或者weight<br> between 100 and 150.而“B树”范围查找比较快</p><h5 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h5><p>1.普通索引 index<br>创建：CREATE INDEX index_name ON table(column(length))。<br>修改：ALTER TABLE table_name ADD INDEX index_name ON (column(length))<br>创建表的时候同时创建索引：<br>CREATE TABLE <code>table</code> (<br>    <code>id</code> int(11) NOT NULL AUTO_INCREMENT ,<br>    <code>title</code> char(255) CHARACTER NOT NULL ,<br>    <code>content</code> text CHARACTER NULL ,<br>    <code>time</code> int(10) NULL DEFAULT NULL ,<br>    PRIMARY KEY (<code>id</code>),<br>    INDEX index_name (title(length))<br>)<br>删除：DROP INDEX index_name ON table。</p><p>2.唯一索引 unique index<br>索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。<br>创建：CREATE UNIQUE INDEX indexName ON table(column(length))<br>修改：ALTER TABLE table_name ADD UNIQUE indexName ON (column(length))<br>创建表的时候直接指定：<br>CREATE TABLE <code>table</code> (<br>    <code>id</code> int(11) NOT NULL AUTO_INCREMENT ,<br>    <code>title</code> char(255) CHARACTER NOT NULL ,<br>    <code>content</code> text CHARACTER NULL ,<br>    <code>time</code> int(10) NULL DEFAULT NULL ,<br>    UNIQUE indexName (title(length))<br>);</p><p>3.主键索引 key index<br>CREATE TABLE <code>table</code> (<br>    <code>id</code> int(11) NOT NULL AUTO_INCREMENT ,<br>    <code>title</code> char(255) NOT NULL ,<br>    PRIMARY KEY (<code>id</code>)<br>);</p><p>4.组合索引<br>ALTER TABLE <code>table</code> ADD INDEX name_city_age (name,city,age); </p><p>5.全文索引 fulltext index<br>主要用来查找文本中的关键字，而不是直接与索引中的值相比较。<br>先建表后加全文索引比建表的同时创建全文索引，写入的速度要快很多。<br>CREATE FULLTEXT INDEX index_content ON article(content)</p><p>CREATE TABLE <code>table</code> (<br>    <code>id</code> int(11) NOT NULL AUTO_INCREMENT ,<br>    <code>title</code> char(255) CHARACTER NOT NULL ,<br>    <code>content</code> text CHARACTER NULL ,<br>    <code>time</code> int(10) NULL DEFAULT NULL ,<br>    PRIMARY KEY (<code>id</code>),<br>    FULLTEXT (content)<br>);</p><p>ALTER TABLE article ADD FULLTEXT index_content(content)。</p><h4 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h4><p>开启慢查询日志，可以让MySQL记录下查询超过指定时间的语句，<br>通过定位分析性能的瓶颈，才能更好的优化数据库系统的性能。</p><p>//查询mysql的查询相关的启动配置参数<br>show variables like ‘query%’;<br>set global slow_query_log=’ON’; //开启慢查询日志<br>//慢查询日志存放位置<br>set global slow_query_log_file=’/usr/local/mysql/data/slow.log’;<br>set global long_query_time=1;//查询超过1秒就记录</p><p>select sleep(4);//执行一条慢查询SQL语句</p><h4 id="MySQL索引方法"><a href="#MySQL索引方法" class="headerlink" title="MySQL索引方法"></a>MySQL索引方法</h4><p>MySQL目前主要有以下几种索引方法：B-Tree，Hash，R-Tree。</p><p>B-Tree索引<br>B-Tree是最常见的索引类型，所有值（被索引的列）都是<strong>排过序</strong>的，<br>每个叶节点到根节点距离相等。所以B-Tree适合用来查找某一<strong>范围</strong><br>内的数据，而且可以直接<strong>支持数据排序</strong>（ORDER BY）<br>B-Tree在MyISAM里的形式和Innodb稍有不同：<br>MyISAM表数据文件和索引文件是分离的，<strong>索引文件仅保存数据记录的磁盘地址</strong><br>InnoDB表数据文件本身就是主索引，叶节点data域保存了完整的数据记录</p><p>Hash索引<br>1.<strong>仅支持”=”,”IN”和”&lt;=&gt;”精确查询，不能使用范围查询</strong>：<br>2.<strong>不支持排序</strong>：<br>3.在任何时候都不能避免表扫描。<br>通过访问表中的实际数据进行相应的比较，并得到相应的结果。<br>4.检索效率<strong>高</strong>，索引的检索可以一次定位，Hash索引的查询效率要远高于B-Tree索引。<br>5.只有Memory引擎支持显式的Hash索引，它也支持B-Tree索引。</p><p>R-Tree索引<br>略</p><p>———–<a href="http://www.cnblogs.com/luyucheng/category/920876.html-------------" target="_blank" rel="noopener">http://www.cnblogs.com/luyucheng/category/920876.html-------------</a><br>——-未完，待续——-</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;关于索引的使用&quot;&gt;&lt;a href=&quot;#关于索引的使用&quot; class=&quot;headerlink&quot; title=&quot;关于索引的使用&quot;&gt;&lt;/a&gt;关于索引的使用&lt;/h5&gt;&lt;p&gt;1、最适合建索引的列有：where后边的、联接（join）条件相关的列、&lt;br&gt;order by相关的列、group by 相关的列。&lt;br&gt;2、数据量区分度要大些，如男女数据量各占50%的就不需要建索引。&lt;br&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="https://ouzhrm.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>工作中如何做好知识积累</title>
    <link href="https://ouzhrm.github.io/2018/04/25/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/"/>
    <id>https://ouzhrm.github.io/2018/04/25/工作中如何做好知识积累/</id>
    <published>2018-04-25T01:54:32.000Z</published>
    <updated>2018-05-20T08:36:20.959Z</updated>
    
    <content type="html"><![CDATA[<p>今天在网上本身奔着美团点评的sql索引优化工具去的，在它们的博客找了找，<br>无意中浏览到<a href="https://tech.meituan.com/study_vs_work.html" target="_blank" rel="noopener">工作中如何做好技术积累</a>这篇文章，好奇心让我点开看了一遍。<br>发现有些还是可以借鉴的，但是有一些让人无法琢磨的，也就是说一半留一半的感觉，<br><a id="more"></a><br>作为同行，都是程序员，这点我是不太喜欢的。下面是我读这篇文章的一些小小总结。<br>1、重视基础理论知识，万变不离其宗。（20%的时间）<br>2、重视工作中的实践。（70%的时间）<br>3、实践中解决问题可以通过博客记录或者分享出来。<br>4、项目最好积极讨论，毕竟和高手过招的机会不是很多。<br>5、项目的空档期，要提高项目的深度，多方位考虑系统的健壮性，可扩展性（功能的增减对系统的影响），<br>可伸缩性（线上服务器的增减对系统的影响）等。注：这点是我读这篇文章收获最大的。<br>6、架构师的几种能力：在线运维、性能优化、架构设计、编程能力</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在网上本身奔着美团点评的sql索引优化工具去的，在它们的博客找了找，&lt;br&gt;无意中浏览到&lt;a href=&quot;https://tech.meituan.com/study_vs_work.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;工作中如何做好技术积累&lt;/a&gt;这篇文章，好奇心让我点开看了一遍。&lt;br&gt;发现有些还是可以借鉴的，但是有一些让人无法琢磨的，也就是说一半留一半的感觉，&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://ouzhrm.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://ouzhrm.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>mysql执行计划</title>
    <link href="https://ouzhrm.github.io/2018/04/24/mysql%20%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/"/>
    <id>https://ouzhrm.github.io/2018/04/24/mysql 执行计划/</id>
    <published>2018-04-24T02:21:51.000Z</published>
    <updated>2018-05-20T08:35:30.414Z</updated>
    
    <content type="html"><![CDATA[<p>实际项目开发中，由于我们不知道实际查询的时候数据库里发生了什么事情，<br>数据库软件是怎样扫描表、怎样使用索引的，因此，在写sql语句的时候就<br>很少考虑到性能的问题。但是当数据规模增大，如千万、亿的时候，我们运<br><a id="more"></a><br>行同样的sql语句时却发现迟迟没有结果，这个时候才知道数据规模已经限<br>制了我们查询的速度。所以，查询优化和索引也就显得很重要了。</p><p>MySql提供了EXPLAIN语法用来进行查询分析，在SQL语句前加一个”EXPLAIN”<br>即可。<br>如：explain select * from table where table.id = 1 </p><p>运行上面的sql语句后你会看到，下面的表头信息：<br>id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra</p><p>id : id列数字越大越先执行，如果说数字一样大，那么就从上往下依次执行</p><p>(select_type看不懂的，可以了解一下即可)<br>select_type列常见的有：<br>A：simple：表示不需要union操作或者不包含子查询的简单select查询。<br>有连接查询时，外层的查询为simple，且只有一个。<br>B：primary：一个需要union操作或者含有子查询的select，位于最外层的<br>单位查询的select_type即为primary。且只有一个。<br>C：union：union连接的两个select查询，第一个查询是dervied派生表，除<br>了第一个表外，第二个以后的表select_type都是union。<br>D：dependent union：与union一样，出现在union 或union all语句中，但<br>是这个查询要受到外部查询的影响。<br>E：union result：包含union的结果集，在union和union all语句中,因为它<br>不需要参与查询，所以id字段为null。<br>F：subquery：除了from字句中包含的子查询外，其他地方出现的子查询都可<br>能是subquery。<br>G：dependent subquery：与dependent union类似，表示这个subquery的查询<br>要受到外部表查询的影响。<br>H：derived：from字句中出现的子查询，也叫做派生表，其他数据库中可能叫<br>做内联视图或嵌套select。</p><p>table ：显示这一行的数据是关于哪张表的。</p><p>type ：显示连接使用了何种类型。从最好到最差的连接类型为const、<br>eq_ref、ref、range、index和ALL。</p><p>const： 表示通过索引一次就找到了。</p><p>eq_ref： 联表操作，外表的一条元组，内表只有唯一一条元组与之对应。</p><p>ref：  联表操作，外表的一条元组，内表可有若干条元组与之对应。</p><p>range： 表示这个连接类型使用索引返回一个范围中的行，比如使<br>用BETWEEN，IN，&gt;=，LIKE等查找东西时发生的情况。</p><p>index：索引全表扫描，把索引从头到尾扫一遍。</p><p>all： 表示为全表扫描； </p><p>possible_keys：查询可能使用到的索引都会在这里列出来</p><p>key :显示MySQL实际决定使用的键。如果没有索引被选择，键是NULL。<br>key=primary的话，表示使用了主键；<br>key=null表示没用到索引。    </p><p>key_len:显示MySQL决定使用的键长度，表示索引中使用的字节数。</p><p>ref ：如果是使用的常数等值查询，这里会显示const；如果是连<br>接查询，被驱动表的执行计划这里会显示驱动表的关联字段；如<br>果是条件使用了表达式或者函数，或者条件列发生了内部隐式转<br>换，这里可能显示为func。</p><p>rows：这里是执行计划中估算的扫描行数，不是精确值    </p><p>extra：关于MYSQL如何解析查询的额外信息。<br>这里可以看到的坏的例子是Using temporary和Using filesort，<br>意思MYSQL根本不能使用索引，结果是检索会很慢。</p><p>这个列可以显示的信息非常多，有几十种，常用的有<br>A：distinct：在select部分使用了distinc关键字</p><p>B：no tables used：不带from字句的查询或者From dual查询</p><p>C：使用not in()形式子查询或not exists运算符的连接查询，<br>这种叫做反连接。即，一般连接查询是先查询内表，再查询外<br>表，反连接就是先查询外表，再查询内表。</p><p>D：using filesort：排序时无法使用到索引时，就会出现这个。<br>常见于order by和group by语句中</p><p>E：using index：查询时不需要回表查询，直接通过索引就可以<br>获取查询的数据。</p><p>F：using join buffer（block nested loop），using join buffer<br>（batched key accss）：5.6.x之后的版本优化关联查询的BNL，BKA<br>特性。主要是减少内表的循环数量以及比较顺序地扫描查询。</p><p>G：using sort_union，using_union，using intersect，<br>using sort_intersection：<br>using intersect：表示使用and的各个索引的条件时，该信息表示是<br>从处理结果获取交集<br>using union：表示使用or连接各个使用索引的条件时，该信息表示从<br>处理结果获取并集<br>using sort_union和using sort_intersection：与前面两个对应的类<br>似，只是他们是出现在用and和or查询信息量大时，先查询主键，然后<br>进行排序合并后，才能读取记录并返回。</p><p>H：using temporary：表示使用了临时表存储中间结果。临时表可以是<br>内存临时表和磁盘临时表，执行计划中看不出来，需要查看status变量，<br>used_tmp_table，used_tmp_disk_table才能看出来。</p><p>I：using where：表示存储引擎返回的记录并不是所有的都满足查询条<br>件，需要在server层进行过滤。查询条件中分为限制条件和检查条件，<br>5.6之前，存储引擎只能根据限制条件扫描数据并返回，然后server层根<br>据检查条件进行过滤再返回真正符合查询的数据。5.6.x之后支持ICP特<br>性，可以把检查条件也下推到存储引擎层，不符合检查条件和限制条件<br>的数据，直接不读取，这样就大大减少了存储引擎扫描的记录数量。<br>extra列显示using index condition</p><p>J：firstmatch(tb_name)：5.6.x开始引入的优化子查询的新特性之一，<br>常见于where字句含有in()类型的子查询。如果内表的数据量比较大，<br>就可能出现这个</p><p>K：loosescan(m..n)：5.6.x之后引入的优化子查询的新特性之一，在in()<br>类型的子查询中，子查询返回的可能有重复记录时，就可能出现这个</p><p>除了这些之外，还有很多查询数据字典库，执行计划过程中就发现不可<br>能存在结果的一些提示信息</p><p>11）filtered<br>使用explain extended时会出现这个列，5.7之后的版本默认就有这个<br>字段，不需要使用explain extended了。这个字段表示存储引擎返回的<br>数据在server层过滤后，剩下多少满足查询的记录数量的比例，注意是<br>百分比，不是具体记录数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实际项目开发中，由于我们不知道实际查询的时候数据库里发生了什么事情，&lt;br&gt;数据库软件是怎样扫描表、怎样使用索引的，因此，在写sql语句的时候就&lt;br&gt;很少考虑到性能的问题。但是当数据规模增大，如千万、亿的时候，我们运&lt;br&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="https://ouzhrm.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql存储引擎的选择及使用场景</title>
    <link href="https://ouzhrm.github.io/2018/04/22/mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E9%80%89%E6%8B%A9%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>https://ouzhrm.github.io/2018/04/22/mysql存储引擎的选择及使用场景/</id>
    <published>2018-04-22T07:16:15.000Z</published>
    <updated>2018-05-20T08:35:53.607Z</updated>
    
    <content type="html"><![CDATA[<p>mysql常用的存储引擎有InnoDB、MYISAM、Archive、Memory<br><strong>InnoDB</strong><br>支持事务以及外键，其他的三种存储引擎是不支持的。锁的粒度是行锁，最大存储<br>容量为64TB，采用MVCC来支持高并发的。默认的隔离级别是可重复读，并通过间隙<br><a id="more"></a><br>锁来防止幻读的。另外最关键的是它支持热备份，其他存储引擎是不支持的，集群<br>的一般选择这种引擎。</p><p><strong>MYISAM</strong><br>MYISAM存储引擎的锁粒度是表锁。物理文件结构是frm文件存储表的结构，myd文件<br>存储表的数据，myi文件存储索引。这三个文件分别放在不同的位置，以获取更快的<br>查询和插入的速度。最大的索引数为64，索引可以为null值，这个值占0~1个字节。<br>每个MyISAM类型的表都有一个AUTO_INCREMENT的内部列，当INSERT和UPDATE操作的<br>时候该列被更新，同时AUTO_INCREMENT列将被刷新。所以说，MyISAM类型表的<br>AUTO_INCREMENT列更新比InnoDB类型的AUTO_INCREMENT更快。<br><strong>Archive</strong><br>Archive引擎支持高并发的批量插入，但是不支持事务、索引和缓存，所以带有不<br>安全性。由于数据可压缩，所以占空间比较小。<br><strong>Memory</strong><br>数据存在内存中，所以数据查询起来的速度很快，但如果断电或者宕机等外界因素<br>的存在，数据会丢失。不支持BLOB或TEXT类型的列，<br>每行的长度是固定的，所以会使部分内存浪费。</p><p>####使用场景<br>InnoDB由于支持事务、热备份等特性，所以对数据严谨性较高的，比如支付、订<br>单、mysql集群等场景使用。<br>MYISAM和archive，如果数据表主要用来插入和查询记录，比如日志的记录，那么<br>用MYISAM或者archive比较合适。<br>Memory主要用于创建临时表，存放查询的中间结果，对数据安全性是否会出现数<br>据丢失等要求不高时，可以用Memory存储引擎。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mysql常用的存储引擎有InnoDB、MYISAM、Archive、Memory&lt;br&gt;&lt;strong&gt;InnoDB&lt;/strong&gt;&lt;br&gt;支持事务以及外键，其他的三种存储引擎是不支持的。锁的粒度是行锁，最大存储&lt;br&gt;容量为64TB，采用MVCC来支持高并发的。默认的隔离级别是可重复读，并通过间隙&lt;br&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="https://ouzhrm.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>高并发环境下mysql的配置参数调优</title>
    <link href="https://ouzhrm.github.io/2018/04/21/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8Bmysql%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98/"/>
    <id>https://ouzhrm.github.io/2018/04/21/高并发环境下mysql的配置参数调优/</id>
    <published>2018-04-21T04:04:47.000Z</published>
    <updated>2018-05-20T08:36:09.642Z</updated>
    
    <content type="html"><![CDATA[<p><strong>skip-locking</strong><br>避免MySQL的外部锁定，减少出错几率增强稳定性。<br><a id="more"></a><br><strong>back_log = 384</strong><br>back_log 参数的值指出在MySQL暂时停止响应新<br>请求之前的短时间内多少个请求可以被存在堆栈中。<br>对于Linux系统推荐设置为小于512的整数。  </p><p><strong>key_buffer_size = 256M</strong><br>key_buffer_size指定用于索引的缓冲区大小，增<br>加它可得到更好的索引处理性能。对于内存在4GB<br>左右的服务器该参数可设置为256M或384M。注意：<br>该参数值设置的过大反而会是服务器整体效率降低！  </p><p><strong>sort_buffer_size = 6M</strong><br><strong>查询排序时所能使用的缓冲区大小</strong>。注意：该参数<br>对应的分配内存是每连接独占，如果有100个连接，<br>那么实际分配的总共排序缓冲区大小为100 × 6 ＝<br>600MB。内存在4GB左右的服务器推荐设置为6-8M。  </p><p><strong>read_buffer_size = 4M</strong><br>读查询操作所能使用的缓冲区大小。<br>和sort_buffer_size一样，该参数对应的分配内存<br>也是每连接独享。 </p><p><strong>join_buffer_size = 8M</strong><br>联合查询操作所能使用的缓冲区大小，和<br>sort_buffer_size一样，该参数对应的分<br>配内存也是每连接独享。  </p><p><strong>query_cache_size = 64M</strong><br>指定MySQL查询缓冲区的大小</p><p><strong>max_connections = 768</strong><br>指定MySQL允许的最大连接进程数。如果在<br>访问论坛时经常出现Too Many Connections<br>的错误提 示，则需要增大该参数值</p><p><strong>wait_timeout = 10</strong><br>指定一个连接请求的最大等待时间，对于4GB左右<br>内存的服务器可以设置为5-10。  </p><p><strong>thread_concurrency = 8</strong><br>该参数取值为服务器逻辑CPU数量<em>2，在本例中，<br>服务器有2颗物理CPU，而每颗物理CPU又支持H.T<br>超线程，所以实际取值为4</em>2=8  </p><p><strong>table_cache=1024</strong><br>物理内存越大,设置就越大.默认为2402,<br>调到512-1024最佳。</p><p><strong>innodb_thread_concurrency=8</strong><br>你的服务器CPU有几个就设置为几,建议用默认一般为8  </p><h5 id="MyISAM和InnoDB优化"><a href="#MyISAM和InnoDB优化" class="headerlink" title="MyISAM和InnoDB优化"></a>MyISAM和InnoDB优化</h5><p><strong>key_buffer_size</strong><br>这对MyISAM表来说非常重要。如果只是使用<br>MyISAM表，可以把它设置为可用内存的 30-40%。<br>合理的值取决于索引大小、数据量以及负载<br>如果很少使用MyISAM表，那么也保留低于16-32MB<br>的key_buffer_size以适应给予磁盘的临时表索引所需。</p><p><strong>innodb_buffer_pool_size</strong><br>Innodb相比MyISAM表对缓冲更为敏感。<br>一般设置它高达70-80%的可用内存。</p><p><strong>innodb_log_file_size </strong><br>在高写入负载尤其是大数据集的情况下很重要。<br>这个值越大则性能相对越高，但是要注意到可能<br>会增加恢复时间。我经常设置为 64-512MB，<br>跟据服务器大小而异</p><p><strong>innodb_log_buffer_size</strong><br> 默认的设置在中等强度写入负载以及较短事务的情<br> 况下，服务器性能还可以。如果存在更新操作峰值<br> 或者负载较大，就应该考虑加大它的值了。如果它的<br> 值设置太高了，可能会浪费内存 — 它每秒都会刷新<br> 一次，因此无需设置超过1秒所需的内存空间。通常<br> 8-16MB 就足够了。越小的系统它的值越小。</p><p><strong>innodb_flush_logs_at_trx_commit </strong><br>把它的值设置为2就可以了，也就是不把日志刷新到磁盘上，<br>而只刷新到操作系统的缓存上。日志仍然会每秒刷新到磁盘中<br>去，因此通常不会丢失每秒1-2次更新的消耗。</p><p><strong>table_cache</strong><br>表缓存<br>如果你有200多个表的话，那么设置为 1024 也许比较合适（<br>每个线程都需要打开表），如果连接数比较大那么就加大它<br>的值。我曾经见过设置为 100,000 的情况。</p><p><strong>thread_cache</strong><br>线程的创建和销毁的开销可能很大，<br>因为每个线程的连接/断开都需要。<br>我通常至少设置为 16。如果应用程序中有大量的跳跃<br>并发连接并且 Threads_Created 的值也比较大，<br>加大它的值目的是在通常的操作中无需创建新线程。</p><p><strong>query_cache</strong><br>如果你的应用程序有大量读，而且没<br>有应用程序级别的缓存，那么这很有用。不要把它设<br>置太大了，因为想要维护它也需要不少开销，这会导<br>致MySQL变慢。通 常设置为 32-512Mb。设置完之后最<br>好是跟踪一段时间，查看是否运行良好。在一定的负载<br>压力下，如果缓存命中率太低了，就启用它。</p><h4 id="下面是一些常见参数优化案例"><a href="#下面是一些常见参数优化案例" class="headerlink" title="下面是一些常见参数优化案例"></a>下面是一些常见参数优化案例</h4><p><strong>thread_concurrency = 4 </strong><br>服务器cpu内核数(真实的并发处理数)</p><h5 id="各种缓存大小"><a href="#各种缓存大小" class="headerlink" title="各种缓存大小"></a>各种缓存大小</h5><p><strong>key_buffer = 384M </strong> 索引块缓存<br><strong>max_allowed_packet = 1M  </strong><br>mysql服务器端和客户端在一次传送数据包的过程当中数据包的大小<br><strong>table_cache = 2048 </strong><br>所有线程打开表的数量<br><strong>sort_buffer_size = 2M</strong> 对排列缓存<br><strong>read_buffer_size = 2M</strong> 读缓存<br><strong>read_rnd_buffer_size = 8M </strong> 随即读排序缓存<br><strong>myisam_sort_buffer_size = 64M </strong><br>排序MyISAM索引分配的缓冲区<br><strong>thread_cache_size = 8 </strong><br>可以复用的保存在缓存中的线程的数量<br><strong>query_cache_size = 32M</strong> 查询缓存<br><strong>tmp_table_size = 256M</strong> 临时表大小<br><strong>max_heap_table_size = 256M</strong> 内存表大小</p><h5 id="延时等待"><a href="#延时等待" class="headerlink" title="延时等待"></a>延时等待</h5><p><strong>interactive_timeout=2880000</strong>  对后续起的交互链接有效；<br><strong>wait_timeout=2880000</strong> 对当前交互链接有效；</p><h5 id="连接数"><a href="#连接数" class="headerlink" title="连接数"></a>连接数</h5><p><strong>max_connections= 5000 </strong> 最大并发数<br><strong>max_connect_errors = 6000 </strong><br>是MySQL中与安全有关的计数器值，它负责阻止过<br>多尝试失败的客户端以防止暴力破解密码的情况。<br><strong>back_log=500</strong> 堆栈队列大小</p><h5 id="域名相关"><a href="#域名相关" class="headerlink" title="域名相关"></a>域名相关</h5><p><strong>skip-name-resolve</strong>  跳过反响解析</p><h5 id="下面是一些查询语句"><a href="#下面是一些查询语句" class="headerlink" title="下面是一些查询语句"></a>下面是一些查询语句</h5><p>在主库上查看主库的状态：<br>show master status;</p><p>查看从库的状态：<br>show slave status；</p><h5 id="数据库主从复制原理："><a href="#数据库主从复制原理：" class="headerlink" title="数据库主从复制原理："></a>数据库主从复制原理：</h5><p>数据库的主从复制就是从master数据库复制到<br>slave数据库，在master与slave之间实现整个<br>复制需要三个线程来完成，其中两个在slave<br>端一个在master端。在master端必须打开binlog<br>功能，因为从数据库需要获得主数据的完整的<br>操作日志然后再自身上顺序的执行日志中的各种操作。</p><p>概要步骤：将master的bin-log写到slave的relay-log中，<br>然后执行里面的语句。</p><p>详细步骤：<br>1、将slave的io线程连上master，请求获得指定日志文<br>件的指定位置之后的操作日志的内容；<br>2、master获得slave的io线程请求后，将请求中读取到<br>的指定日志的指定位置之后的内容返回给slave端的io<br>线程，其中包括binlog 的位置以及名称；<br>3、slave端的io线程在接收到信息后，将接收到的日志<br>内容写入slave端的relay log文件的末端，并将binlog<br>的文件名和位置记录到master-info文件中，以便下一<br>次请求时向master提出请求；<br>4、slave的sql线程会检测到relay log中新增的一些日<br>志内容并加以解析成为可执行的query语句在slave端执<br>行，从而达到master与slave端的数据一致性。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;skip-locking&lt;/strong&gt;&lt;br&gt;避免MySQL的外部锁定，减少出错几率增强稳定性。&lt;br&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="https://ouzhrm.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql常用配置参数</title>
    <link href="https://ouzhrm.github.io/2018/04/19/mysql%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0/"/>
    <id>https://ouzhrm.github.io/2018/04/19/mysql常用配置参数/</id>
    <published>2018-04-19T08:34:21.000Z</published>
    <updated>2018-05-20T08:35:41.330Z</updated>
    
    <content type="html"><![CDATA[<p>mysql在启动的时候，会加载my.ini（Linux系统下是my.cnf），即当mysql服务器启动时它会读取这<br>个文件，设置相关的运行环境参数。<br><a id="more"></a><br>查询当前全部参数设置sql语句为：show variables<br>下面是一些常用的配置参数：<br><strong>port=3306</strong><br>mysql使用的端口号</p><p><strong>atadir=/data/mysql</strong><br>数据文档存储目录,默认为/var/lib/mysql</p><p><strong>skip-slave-start</strong><br>禁止slave复制进程随Mysql数据库启动而启动，默认为未启用</p><p><strong>skip-name-resolve</strong><br>禁止Mysql进行DNS反向解析,默认为未启用,安装的MySql开启了DNS的反向解析,<br>禁止DNS反向解析后,只能通过Mysql授权表中IP来访问,可以提高Mysql访问速度.</p><p><strong>sort_buffer_size = 4M</strong><br>connection级参数，一个连接分配多少内存，默认为256KB。</p><p><strong>join_buffer_size = 2M</strong><br>默认为128KB，用于表间关联缓存的大小，和sort_buffer_size一样，该参数对应的分配内存也是每<br>个连接独享。如果应用中，很少出现join语句，则可以不用太在乎join_buffer_size参数的设置大小。<br>如果join语句不是很少的话，个人建议可以适当增大join_buffer_size到1MB左右，如果内存充足可以<br>设置为2MB</p><p><strong>table_open_cache = 5000</strong><br>打开表的缓存数量，默认为64。也不是定义内存的大小的。而是定义可以缓存多少打开的表的文件<br>句柄信息。如果定义的太小，那么mysql在需要打开新表的时候就要不断的关闭已经打开的表和打开<br>此次需要打开的表。性能会受到影响。</p><p><strong>table_definition_cache = 5000</strong><br>默认值为256 (Myslq5.12后，之前128)，表定义信息缓存是从MySQL5.1.3 版本才开始引入的一个<br>新的缓存区，用来存放表定义信息，设置好的话能提高对表定义信息的访问效率。</p><p><strong>thread_cache_size = 512</strong><br>定义缓存了的线程数量<br>只要设置的大小除以8小于物理内存就可以的。</p><p><strong>query_cache_size = 32M</strong><br>用来缓存特定Query 的结果集（Result Set）信息，默认值为0。在数据库写入量或是更新量也比较<br>大的系统，该参数不适合分配过大。而且在高并发，写入量大的系统，建议把该功能禁掉。</p><p><strong>query_cache_limit = 2M</strong><br>默认值为1MB<br>指定单个查询能够使用的缓冲区大小</p><p><strong>max_allowed_packet = 100M</strong><br>默认值为4M。<br>接受的数据包大小</p><p><strong>max_connect_errors = 1000000</strong><br>默认值为10<br>一个MySQL中与安全有关的计数器值，它负责阻止过多尝试失败的客户端以防止暴力破解密码的<br>情况。max_connect_errors的值与性能并无太大关系，mysqladmin flush-hosts命令来解锁已经<br>被屏蔽的主机</p><p><strong>max_connections = 1500</strong><br>默认值为100<br>MySQL允许最大的进程连接数，如果经常出现Too Many Connections的错误提示，则需要增大此值。</p><p><strong>tmp_table_size = 256M</strong><br>默认值大小为32M<br>临时表使用内存<br>如果一张临时表超出该大小，MySQL产生一个 The table tbl_name is full 形式的错误，如果你<br>做很多高级 GROUP BY 查询，增加 tmp_table_size 值。如果超过该值，则会将临时表写入磁盘。</p><p><strong>max_heap_table_size = 256M</strong><br>定义了用户可以创建的内存表(memory table)的大小。这个值用来计算内存表的最大行数值。这个<br>变量支持动态改变其大小还小于 tmp_table_size 的时候，MySQL 将使用 max_heap_table_size<br>参数所设置大小作为最大的内存临时表大小，而忽略 tmp_table_size 所设置的值。</p><h4 id="——–log———"><a href="#——–log———" class="headerlink" title="——–log———"></a>——–log———</h4><p><strong>slow_query_log=1</strong><br>slow quere log的开关，当值为1的时候说明开启慢查询。</p><p><strong>slow_query_log_file=slow.log</strong><br>慢查询日志位置及其文件名字</p><p><strong>long_query_time = 1</strong><br>慢查询时间 超过1秒则为慢查询</p><p><strong>log-error = mysql-error.log</strong><br>Mysql错误日志开关<br>错误日志位置及错误日志文件名</p><p><strong>log_slave_updates = 1</strong><br>默认为0(关闭状态)<br>控制从库通过I0线程读取主库二进制日志文件，<br>然后通过SQL线程写入的数据时候是否写入从库自身的binlog日志</p><p><strong>relay_log_purge = 0</strong><br>默认为1(自动删除状态)<br>控制SQL线程在执行完一个relay log后是否自动将其删除</p><p><strong>read_only = 1</strong><br>默认为0 (读写状态)<br>设置数据库为只读模式，只对普通用户起作用。对root或拥有super权限的无效果。</p><h4 id="——–binlog———"><a href="#——–binlog———" class="headerlink" title="——–binlog———"></a>——–binlog———</h4><p><strong>expire_logs_days = 30</strong><br>默认为0 (不自动删除)<br>设置binlog自动删除过期时间</p><p><strong>log-bin=mysql-bin</strong><br>默认为关闭<br>Mysql的binlog日志开关<br>设置binlog日志位置及日志文件名</p><p><strong>binlog_format=mixed</strong><br>默认为statement<br>binlog日志格式，建议使用mixed</p><p><strong>server-id = 1055</strong><br>Mysql server唯一标示，一般以时间戳就可以<br>主从同步中使用<br>mysql的同步的数据中是包含server-id的，用于标识该语句最初是从哪个server写入的。</p><h4 id="——–innodb———"><a href="#——–innodb———" class="headerlink" title="——–innodb———"></a>——–innodb———</h4><p><strong>innodb_data_home_dir = /data/mysql/ibdata</strong><br>默认使用MySQL的 datadir 目录为缺省目录<br>InnoDB表的目录共用设置<br>如果设定一个空字串,可以在 innodb_data_file_path 中设定绝对路径</p><p><strong>innodb_file_per_table = 1</strong><br>默认为关闭(值为0)<br>控制是否使用独立表空间模式</p><p><strong>innodb_autoextend_increment = 256</strong><br>默认是8M<br>当自动扩展表空间被填满之时，为扩展而增加的尺寸（MB为单位）<br>mysql 5.6.5版本之前默认值是8Mb，从5.6.6版本之后默认为64Mb，最小值为1Mb，最大值为1000Mb。<br>这个参数受到innodb_file_per_table参数的影响</p><p><strong>innodb_data_file_path=ibdata1:10M;ibdata2:10M:autoexte</strong><br>指定表数据和索引存储的空间，可以是一个或者多个文件。最后一个数据文件必须是自动扩充的，也<br>只有最后一个文件允许自动扩充。<br>例子：<br>假设希望创建一个数据文件ibdata1，初始大小为100MB，并希望在每次达到当前大小限制时，自动增加<br>8MB（8MB是指定autoextend时的默认扩展大小).但是，不希望此文件超过1GB，可以使用如下配置:<br>innodb_data_home_dir =<br>innodb_data_file_path = /data/ ibdata1:100M:autoextend:8M: max:1GB<br>如果此文件增加到预定的1G的限制，可以再增加另外一个数据文件,如下:<br>innodb_data_file_path = /data/ibdata1:100M:autoextend:8M: max:1GB;<br>innodb_data_file_path = /data2/ibdata2:100M:autoextend:8M: max:2GB</p><p><strong>innodb_table_locks = 0</strong><br>默认值为1<br>如果autocommit=1,Innodb的内部表锁可能会导致deadlock,可以通过设置innodb_table_locks=0来解决这<br>个问题，设置innodb_lock_wait_timeout变量,使deadlock超时后rollback</p><p><strong>innodb_lock_wait_timeout = 10</strong><br>MySQL在允许其他事务修改那些最终受事务回滚的数据之前要等待多长时间(秒数)</p><p><strong>innodb_buffer_pool_size = 16G</strong><br>默认为8M<br>InnoDB 用来高速缓冲数据和索引内存缓冲大小<br>可以设置60-80%的内存</p><p><strong>innodb_additional_mem_pool_size = 20M</strong><br>默认值为1MB<br>InnoDB 用来存储数据字典(data dictionary)信息和其它内部数据结构(internal data structures)的存<br>储器组合(memory pool)大小参数对系统整体性能并无太大的影响，只要能存放需要的数据就好，否则只会<br>浪费内存几百个Innodb 表的，推荐20M以内就足以了。<br>此参数在5.7中已经移除</p><p><strong>innodb_read_io_threads = 6</strong><br>后台读线程, 主要处理INNODB 数据文件异步读请求<br>每个read线程最多可以pend 256个任务(Linux平台中)</p><p><strong>innodb_write_io_threads = 6</strong><br>后台写线程数, 主要处理INNODB 数据文件异步写请求<br>每个write线程最多可以pend 256个任务(Linux平台中)</p><p><strong>innodb_flush_method=O_DIRECT</strong><br>默认为fdatasync<br>fdatasync：调用fsync()去刷数据文件与redo log的buffer<br>O_DSYNC：innodb会使用O_SYNC方式打开和刷写redo log,使用fsync()刷写数据文件<br>O_DIRECT：innodb使用O_DIRECT打开数据文件，使用fsync()刷写数据文件跟redo log</p><p><strong>innodb_log_files_in_group = 2</strong><br>默认为2<br>控制日志文件数</p><p><strong>innodb_log_file_size = 1G</strong><br>默认为 5M<br>用来在mysql crash后的恢复.所以设置合理的大小对于mysql的性能非常重要<br>通过show engine innodb status;可以查看mysql checkpoint情况，可以算<br>出上次checkpoint和最后一次checkpoint的中间值，官方文档建议最好不要超过<br>innodb_log_files_in_group*innodb_log_file_size的0.75<br>由此可以推算出innodb_log_file_size比较合适的值。<br>在mysql 5.5和5.5以前innodb的logfile最大设置为4GB,在5.6以后的版本中logfile<br>最大的可以设为512GB<br>当mysql crash后，在重启之前需要将老的innodb logfile删除。</p><p><strong>innodb_log_buffer_size = 48M</strong><br>默认为8M<br>当事务提交时，保存脏数据到内存中，后续再刷新保存到磁盘<br>适当调整此参数大小，可以减少磁盘I/O</p><p><strong>innodb_flush_log_at_trx_commit=2</strong><br>默认为1<br>控制log buffer写入log file和控制flush操作<br>innodb_flush_log_at_trx_commit=0，log buffer将每秒一次地写入log file中，<br>并且log file的flush(刷到磁盘)操作同时进行.该模式下，在事务提交的时候，不<br>会主动触发写入磁盘的操作。<br>innodb_flush_log_at_trx_commit=1，每次事务提交时MySQL都会把log buffer的<br>数据写入log file，并且flush(刷到磁盘)中去.<br>innodb_flush_log_at_trx_commit=2，每次事务提交时MySQL都会把log buffer的<br>数据写入log file.但是flush(刷到磁盘)操作并不会同时进行。该模式下,MySQL会<br>每秒执行一次 flush(刷到磁盘)操作。<br>注意：<br>  由于进程调度策略问题,这个“每秒执行一次 flush(刷到磁盘)操作”并不是保证<br>  100%的“每秒”。</p><p><strong>sync_binlog = 15</strong><br>默认值为0<br>像操作系统刷其他文件的机制一样，MySQL不会同步到磁盘中去而是依赖操作系统<br>来刷新binary log。当sync_binlog =N (N&gt;0) ，MySQL 在每写 N次 二进制日志<br>binary log时，会使用fdatasync()函数将它的写二进制日志binary log同步<br>到磁盘中去。<br>注:<br>   如果启用了autocommit，那么每一个语句statement就会有一次写操作；否则<br>   每个事务对应一个写操作。<br>   一般与innodb_flush_log_at_trx_commit同时设置</p><p><strong>innodb_support_xa = 0</strong><br>0表示关闭<br>分布式事务中此参数确保事务日志写入bin-log 的顺序与是事务的time-line 是<br>一致的</p><p><strong>sql_mode = NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</strong><br>默认为空<br>此参数在mysql数据库版本升级时候用比较合适</p><p><strong>binlog_cache_size=2M</strong><br>默认为32K<br>一个事务，在没有提交（uncommitted）的时候，产生的日志，记录到Cache中；<br>等到事务提交（committed）需要提交的时候，则把日志持久化到磁盘<br>在事务中存储二进制日志sql语句的缓存大小</p><p><strong>tx_isolation = READ-COMMITTED</strong><br>默认为 REPEATABLE READ<br>关于MySQL的事务处理及隔离级别<br>READ-UNCOMMITTED, READ-COMMITTED, REPEATABLE-READ, SERIALIZABLE</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mysql在启动的时候，会加载my.ini（Linux系统下是my.cnf），即当mysql服务器启动时它会读取这&lt;br&gt;个文件，设置相关的运行环境参数。&lt;br&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="https://ouzhrm.github.io/tags/mysql/"/>
    
      <category term="数据库" scheme="https://ouzhrm.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务的四种隔离级别</title>
    <link href="https://ouzhrm.github.io/2018/04/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>https://ouzhrm.github.io/2018/04/19/数据库事务的四种隔离级别/</id>
    <published>2018-04-19T02:24:31.000Z</published>
    <updated>2018-05-20T08:36:39.184Z</updated>
    
    <content type="html"><![CDATA[<p>1.读没提交<br>事务A没有提交，做了一些写入或者更新操作，事务B可以读，但如果事务B发生回滚，那么就会出现脏读现象。<br>脏读可以理解成还没提交你就开始读，真脏的意思。实际做生产的时候一般不会使用这种事务。<br><a id="more"></a><br>2.读提交<br>和读没提交恰好相反，只有事务A提交了，事务B才可以读，大部分数据库支持这一种事务。<br>3.重复读<br>事务B先读一遍数据，事务A写入id为3的数据，事务B再查一遍数据，发现没有发生变化，也就是说事务之间隔离了，<br>但事务B也想写入id为3的数据时，发现无法写入，并提醒id重复,也就是所谓的幻读，似乎发生幻觉了一样。这种<br>隔离级别是事务各干各的，但是又有点联系那种，很模糊。mysql就是默认这种隔离级别的。<br>4.串行化<br>事务A正在查询，事务B写入，会发现事务B无法写入，显示正在等待状态。这是事务隔离级别中最严格的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.读没提交&lt;br&gt;事务A没有提交，做了一些写入或者更新操作，事务B可以读，但如果事务B发生回滚，那么就会出现脏读现象。&lt;br&gt;脏读可以理解成还没提交你就开始读，真脏的意思。实际做生产的时候一般不会使用这种事务。&lt;br&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://ouzhrm.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>《MySQL性能调优与架构设计》学习总结</title>
    <link href="https://ouzhrm.github.io/2018/04/18/%E3%80%8Amysql%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E3%80%8B%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"/>
    <id>https://ouzhrm.github.io/2018/04/18/《mysql高性能架构设计》读书总结/</id>
    <published>2018-04-18T02:21:51.000Z</published>
    <updated>2018-05-20T08:35:15.050Z</updated>
    
    <content type="html"><![CDATA[<h5 id="此书的详细内容"><a href="#此书的详细内容" class="headerlink" title="此书的详细内容"></a>此书的详细内容</h5><p>作者：简朝阳<br>出版社: 电子工业出版社<br>出版年: 2009-6<br><a id="more"></a></p><h2 id="mysql物理文件组成"><a href="#mysql物理文件组成" class="headerlink" title="mysql物理文件组成"></a>mysql物理文件组成</h2><h3 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h3><p>错误日志<br>错误日志记录了MyQL Server 运行过程中所有较为严重的警告和错误信息，以及MySQL<br>Server 每次启动和关闭的详细信息.<br>如果要开启系统记录错误日志的功能，需要在<br>启动时开启-log-error 选项。错误日志的默认存放位置在数据目录下，以hostname.err 命<br>名。但是可以使用命令：–log-error[=file_name]，修改其存放目录和文件名.</p><p>二进制日志<br>二进制日志，也就是我们常说的binlog，也是MySQL Server 中最为重要的日志之一。<br>当我们通过“–log-bin[=file_name]”打开了记录的功能之后，MySQL 会将所有修改数据<br>库数据的query 以二进制形式记录到日志文件中。当然，日志中并不仅限于query 语句这么<br>简单，还包括每一条query 所执行的时间，所消耗的资源，以及相关的事务信息，所以binlog<br>是事务安全的。<br>和错误日志一样，binlog 记录功能同样需要“–log-bin[=file_name]”参数的显式指<br>定才能开启，如果未指定file_name，则会在数据目录下记录为mysql-bin.<strong>**</strong>（*代表0～<br>9 之间的某一个数字，来表示该日志的序号）。</p><p>慢查询日志：slow query log<br>顾名思义，慢查询日志中记录的是执行时间较长的query，也就是我们常说的slow<br>query，通过设–log-slow-queries[=file_name]来打开该功能并设置记录位置和文件名，<br>默认文件名为hostname-slow.log，默认目录也是数据目录。<br>MySQL 还提供了专门用来分析满查询日志的工具程序mysqlslowdump，<br>用来帮助数据库管理人员解决可能存在的性能问题。</p><h3 id="数据文件"><a href="#数据文件" class="headerlink" title="数据文件"></a>数据文件</h3><p>每个数据文件的扩展名却各不一样。如MyISAM 用“.MYD”作为扩展<br>名，Innodb 用“.ibd”，Archive 用“.arc”，CSV 用“.csv”。</p><p>不论是什么存储引擎，每一个表都会有一个以表名命名的“.frm”文件，存放表结构信息。<br>所有的“.frm”文件都存放在所属数据库的文件夹下面。</p><p>“.MYD”文件是MyISAM 存储引擎专用，存放MyISAM 表的数据。</p><p>“.MYI”文件是存放MyISAM 表的索引相关信息。</p><p>.ibd文件和ibdata文件<br>这两种文件都是存放Innodb 数据的文件。独享表空间存储方式使用“.ibd”文件来存放数据，且<br>每个表一个“.ibd”文件，文件存放在和MyISAM 数据相同的位置。如果选用共享存储表空<br>间来存放数据，则会使用ibdata 文件来存放，所有表共同使用一个（或者多个，可自行配<br>置）ibdata 文件。</p><h3 id="Replication（复制）相关文件"><a href="#Replication（复制）相关文件" class="headerlink" title="Replication（复制）相关文件"></a>Replication（复制）相关文件</h3><p>master.info 文件：<br>master.info 文件存在于Slave 端的数据目录下，里面存放了该Slave 的Master 端的相关信息。</p><p>relay log<br>存放Slave 端的I/O 线程从Master 端所读取到的Binary Log 信息，<br>然后由Slave 端的SQL 线程从该relay log 中读取并解析相应的日志<br>信息，转化成Master 所执行的SQL 语句，然后在Slave端应用。</p><p>relay-log.info 文件：<br>类似于master.info，它存放通过Slave 的I/O 线程写入到本地的relay log 的相关信息。</p><h3 id="MySQL-Server-系统架构"><a href="#MySQL-Server-系统架构" class="headerlink" title="MySQL Server 系统架构"></a>MySQL Server 系统架构</h3><p>MySQL 是二层架构，第一层我们通常叫做SQL Layer，处理包括权限判断，sql 解析，执<br>行计划优化，query cache 的处理等等；第二层就是存储引擎层，我们通常叫做Storage<br>Engine Layer，也就是底层数据存取操作实现部分，由多种存储引擎共同组成。</p><h2 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>MySQL 的插件式存储引擎主要包括MyISAM，Innodb，NDB Cluster，Maria，Falcon，<br>Memory，Archive，Merge，Federated 等，其中最著名而且使用最为广泛的MyISAM 和Innodb<br>两种存储引擎。MyISAM 是MySQL 最早的ISAM 存储引擎的升级版本，也是MySQL默认的存储<br>引擎。但它不支持事务，外键等特性，我们可以重新设置InnoDB为默认引擎：在配置文件<br>my.cnf（linux,如果是windows，则是my.ini）中的 [mysqld]下面加入<br>default-storage-engine=INNODB 一句，Innodb 最大的特点是提供了事务控制等特性。</p><p>NDB Cluster 虽然也支持事务，但是主要是用于分布式环境。Memory 存储引擎所有数据<br>和索引均存储于内存中，所以主要是用于一些临时表，或者对性能要求极高，但是允许在<br>丢失数据的特定场景下。Archive 是一个数据经过高比例压缩存放的存储引擎，主要用于<br>存放过期而且很少访问的历史信息，不支持索引。Merge在严格意义上来说，并不能算作<br>一个存储引擎。因为Merge 存储引擎主要用于将几个基表merge 到一起，对外作为一个<br>表来提供服务，基表可以基于其他的几个存储引擎。</p><p>MyISAM 支持以下三种类型的索引：<br>1、B-Tree 索引<br>    B-Tree 索引，顾名思义，就是所有的索引节点都按照balance tree 的数据结构来<br>    存储，所有的索引数据节点都在叶节点。<br>2、R-Tree 索引<br>    R-Tree 索引的存储方式和b-tree 索引有一些区别，主要设计用于为存储空间和多<br>    维数据的字段做索引。<br>3、Full-text 索引<br>    Full-text 索引就是我们长说的全文索引，他的存储结构也是b-tree。主要是为了<br>    解决在我们需要用like 查询的低效问题。<br>    MyISAM 上面三种索引类型中，最经常使用的就是B-Tree 索引了，偶尔会使用到Fulltext，<br>    但是R-Tree 索引一般系统中都是很少用到的。另外MyISAM 的B-Tree 索引有一个较<br>    大的限制，那就是参与一个索引的所有字段的长度之和不能超过1000 字节。</p><p>虽然每一个MyISAM 的表都是存放在一个相同后缀名的.MYD 文件中，但是每个文件的存<br>放格式实际上可能并不是完全一样的，因为MyISAM 的数据存放格式是分为静态（FIXED）固<br>定长度、动态（DYNAMIC）可变长度以及压缩（COMPRESSED）这三种格式。当然三种格式中<br>是否压缩是完全可以任由我们自己选择的，可以在创建表的时候通过ROW_FORMAT 来指定<br>{COMPRESSED | DEFAULT}，也可以通过myisampack 工具来进行压缩，默认是不压缩的。</p><p>Innodb 存储引擎<br>有以下特点：<br>1、支持事务安装<br>2、锁定机制的改进，Innodb 改变了MyISAM 的锁机制，实现了行锁。<br>3、实现外键。</p><p>Innodb 的表空间分为两种形式。一种是共享表空间，也就是所有表和索引数据被存放<br>在同一个表空间（一个或多个数据文件）中，通过innodb_data_file_path 来指定。<br>另外一种是独享表空间，也就是每个表的数据和索引被存放在一个单独的.ibd 文件中。<br>一般建议用独享表空间。</p><p>Innodb 的所有参数基本上都带有前缀“innodb_”，我们也完全可以仅仅通过一个参数<br>（skip-innodb）来屏蔽MySQL 中的Innodb存储引擎，这样即使我们在安装编译的时候<br>将Innodb 存储引擎安装进去了，使用者也无法创建Innodb 的表。</p><p>MERGE 存储引擎，在MySQL 用户手册中也提到了，也被大家认识为MRG_MyISAM 引擎。</p><p>Memory 存储引擎，是将数据存储在内存中的存储引擎。Memory 存储引擎不会将任何<br>数据存放到磁盘上，仅仅存放了一个表结构相关信息的.frm 文件在磁盘上面。所以<br>一旦MySQL Crash 或者主机Crash 之后，Memory 的表就只剩下一个结构了。Memory<br>表支持索引，并且同时支持Hash 和B－Tree 两种格式的索引。由于是存放在内存中，<br>所以Memory 都是按照定长的空间来存储数据的，而且不支持BLOB 和TEXT类型的字段。<br>Memory 存储引擎实现页级锁定。</p><p>ARCHIVE存储引擎：<br>ARCHIVE 存储引擎主要用于通过较小的存储空间来存放过期的很少访问的历史数据。<br>ARCHIVE 表不支持索引，通过一个.frm 的结构定义文件，一个.ARZ 的数据压缩文件还有一<br>个.ARM 的meta 信息文件。由于其所存放的数据的特殊性，ARCHIVE 表不支持删除，修改操<br>作，仅支持插入和查询操作。锁定机制为行级锁定。</p><h2 id="MySQL的权限和安全"><a href="#MySQL的权限和安全" class="headerlink" title="MySQL的权限和安全"></a>MySQL的权限和安全</h2><p>略</p><h2 id="MySQL-备份与恢复"><a href="#MySQL-备份与恢复" class="headerlink" title="MySQL 备份与恢复"></a>MySQL 备份与恢复</h2><p>在介绍备份和恢复之前，先考虑以前几种情况的解决方案？<br>一、数据丢失应用场景<br>1、人为操作失误造成某些数据被误操作；<br>2、软件BUG 造成数据部分或者全部丢失；<br>3、硬件故障造成数据库数据部分或全部丢失；<br>4、安全漏洞被入侵数据被恶意破坏；</p><p>二、非数据丢失应用场景<br>5、特殊应用场景下基于时间点的数据恢复、回滚；<br>6、开发测试环境数据库搭建；<br>7、相同数据库的新环境搭建；<br>8、数据库或者数据迁移；</p><p>在MySQL 中一般都使用以下两种方法来获得可以自定义分隔符的纯文本备份文件。<br>1、通过执行SELECT … TO OUTFILE FROM …命令来实现<br>SELECT * INTO OUTFILE ‘/tmp/dump.text’<br>FIELDS TERMINATED BY ‘,’ OPTIONALLY ENCLOSED BY ‘“‘<br>FROM 表名 limit 100; </p><p>2、通过mysqldump 导出所有数据库<br>mysqldump -uroot -proot –all-databases &gt;/tmp/all.sql</p><p>思考：如何实现mysql数据不丢失备份和高效恢复方案？<br>可以采用让远程服务器实时同步bin-log日志,可以理解为主从复制。</p><p>物理备份；将.ibd文件、.myd文件、.frm等文件复制到mysql相应的位置上去。<br>逻辑备份：使用mysqldump工具，通过命令语句的形式将数据导到一个文件上。<br>热备份：线上备份数据，如主从复制。<br>冷备份：关闭数据库，然后将数据拷贝出来。</p><p>需求：一个论坛帖子总量的统计<br>附加要求：实时更新<br>在很多人看来，这个功能非常容易实现，不就是执行一条SELECT COUNT(*)的<br>Query 就可以得到结果了么？是的，确实只需要如此简单的一个Query 就可<br>以得到结果。但是，如果我们采用不是MyISAM 存储引擎，而是使用的Innodb<br>的存储引擎，那么大家可以试想一下，如果存放帖子的表中已经有上千万的帖<br>子的时候，执行这条Query 语句需要多少成本？恐怕再好的硬件设备，恐怕都<br>不可能在10 秒之内完成一次查询吧。如果我们的访问量再大一点，还有人觉得<br>这是一件简单的事情么？既然这样查询不行，那我们是不是该专门为这个功能<br>建一个表，就只有一个字段，一条记录，就存放这个统计量，每次有新的帖子<br>产生的时候，都将这个值增加1，这样我们每次都只需要查询这个表就可<br>以得到结果了，这个效率肯定能够满足要求。<br>但这种情况下，实时更新就很难确保的满足，可以这样，开启定时任务，定时<br>通过select语句更新表的统计结果。    </p><p>——————–未完待续98页——————–    </p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;此书的详细内容&quot;&gt;&lt;a href=&quot;#此书的详细内容&quot; class=&quot;headerlink&quot; title=&quot;此书的详细内容&quot;&gt;&lt;/a&gt;此书的详细内容&lt;/h5&gt;&lt;p&gt;作者：简朝阳&lt;br&gt;出版社: 电子工业出版社&lt;br&gt;出版年: 2009-6&lt;br&gt;
    
    </summary>
    
      <category term="读书" scheme="https://ouzhrm.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="mysql" scheme="https://ouzhrm.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>《大型网站技术架构 核心原理与案例分析》读书总结</title>
    <link href="https://ouzhrm.github.io/2018/04/18/%E3%80%8A%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E3%80%8B%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"/>
    <id>https://ouzhrm.github.io/2018/04/18/《大型网站技术架构-核心原理与案例分析》读书总结/</id>
    <published>2018-04-18T02:21:51.000Z</published>
    <updated>2018-05-20T08:35:11.460Z</updated>
    
    <content type="html"><![CDATA[<h4 id="我为什么读这本书？"><a href="#我为什么读这本书？" class="headerlink" title="我为什么读这本书？"></a>我为什么读这本书？</h4><p>最近在研究分布式相关，在网上聊的热火朝天，都说这本书入门好。李智慧编写，电子工业出版社出版，<br><a id="more"></a><br>豆瓣读书评分是7.9,一共有1000多人参与评论。我大概花了一个多星期的零碎时间，通读了这本书，大<br>概读到后面的后辈对晚辈的悉心嘱咐的时候，我就在豆瓣读书奉献了这本书的书评，给了三星。并作了<br>一些评论。毫无疑问，这本书真的是很适合入门，网上的兄弟们没骗我，它会在大型网站架构上给你一<br>些很全面的认识以及自己的一些经验之谈。但咋们做技术的，往往注重实用性，关注点在能不能用，怎<br>么用，用的时候注意什么，用的好不好等问题，但在这本书并没有深入。而最后，我想总结的是，这本<br>书更像一本兵书，想发力却又用不上来的那种感觉，又像师父领进门，修行看个人的感觉。如果说非要<br>给这本书来个标签，那可能是，有点失灵，但方向还基本正确的指南针，因为里面多少掺杂一些水分，<br>无关紧要的，能一句话说完，它非要说上1000来字，带点装*，自嗨的那种感觉。    </p><h4 id="这本书带给我的收获"><a href="#这本书带给我的收获" class="headerlink" title="这本书带给我的收获"></a>这本书带给我的收获</h4><p>一般后台的分三层：应用层，服务层，数据层。应用层一般是页面及控制器。服务层是一些可调用的接<br>口，可以理解成service层，而数据库层，也就是操作数据库的，可以理解成dao层。但这仅仅指的是java<br>层面上的理解。</p><p>先说应用层，也就是页面相关的。<br>流量入口，我们一般用nginx进行反向代理，负载均衡。将请求按轮询的方式或者hash方式分发到具体的<br>服务器或者网关。一些热点的静态页面（比如说主页）可以放到nginx缓存或者CDN服务器。而CDN、反向<br>代理服务器的原理都是缓存。当然，如果集群中的某一台服务器宕机了，要实现失效转移，将请求转发<br>到其他正常运行的服务器中。<br>1、页面优化<br>为减少http请求，我们要实现一个静态资源，合并css,js,以及请求数据量大的图片。其次，要通过设置<br>请求头的方式实现浏览器缓存，304重定向，防止图片，js的文件的再次加载。其次可以启用压缩，服务<br>器将文件压缩，浏览器解压缩。减少传输的数据量。其次css放在上面，js放在下面。因为加载页面<br>是从上往下加载的。<br>2、负载均衡<br>有几种方式，反向代理负载均衡，IP负载均衡，数据链路层负载均衡等。这些之后可以去了解一下，这<br>几种都是不同的。这本书也描述的不是特别清楚。然后以及负载均衡的算法，现在业内大部分是通过<br>一致性hash算法来实现请求到底去选择哪一台服务器。</p><p>然后说说服务层<br>当服务层的关系很复杂的时候，我们要对其进行解耦，解耦的方式有以下那么几种：<br>分布式服务：也就是rpc,远程方法调用，国内的Dubbo或者FaceBook通过Thrift来自主研发的框架。<br>原理简单：网络通信+编解码+服务端+客户端。<br>消息队列：消息队列是类似于生产者-消费者模式的。一头生产消息，另一头消费消息，中间来个管理消<br>息与推送消息的。也常常叫做消息中间件，jms。如：activemq，kafka等。在高并发支付场景可以使用。<br>但注意幂等性，消息重发等问题。独立部署web应用：当某一个服务与其他服务关联不大的时候，可以采<br>用单独拿出来，独立部署。</p><p>最后是数据层<br>关系型数据库往往会设计成读写分离（master写，一个或多个slave读）的模式。如mysql本身有主从热备<br>的功能，也就是数据库之间数据同步。先说下概念，热备份是主从复制，而冷备份定期存档。其次还有垂直水<br>平分库分表的方式，按业务模块分，按列，按时间等分出多个数据库或表。性能上，人为能改变的有sql优化、<br>索引设置等。然后是nosql相关的，nosql种类很多，如key-value形式，可用于存session，保证session<br>一致性的redis,文档型非关系型数据库mongoDB,此外还有mamcached等。<br>然后介绍几个概念，<br>缓存预热：将数据提前存到非关系型数据库如redis中，防止项目重新部署之后，关系型数据库如mysql访问<br>量过大而宕机。<br>缓存穿透：是指大量并发访问redis中一个不存在的数据，导致请求都往mysql上串，最终mysql访问量过大<br>而宕机，解决的方式可以是设置将redis不存在的数据立即返回null。</p><h4 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h4><p>自动化是我们的理想形态，如：自动化发布、自动化代码管理、自动化测试（安全、性能、功能），自动化<br>监控和报警（心跳检测、通知），自动化失效转移，超时转移和失效恢复、自动化降级、自动化分配资源等。</p><h4 id="大型网站要实现以下几种性质"><a href="#大型网站要实现以下几种性质" class="headerlink" title="大型网站要实现以下几种性质"></a>大型网站要实现以下几种性质</h4><p>可用性：一年内99.99%的时间里，服务器都能正常的运行及可提供功能访问。<br>伸缩性：线上增减服务器数量时对其它服务器的影响。<br>扩展性：增减功能对其他功能的影响。<br>安全性：保证网站的安全。</p><h4 id="CAP原理"><a href="#CAP原理" class="headerlink" title="CAP原理"></a>CAP原理</h4><p>C：数据一致性，保证请求在某一具体功能点上都能访问到相同或者说正确的数据。<br>A：数据可用性：任何时候请求的数据都能进行读写访问。<br>P：系统跨网络线性伸缩。</p><h4 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h4><p>每天只发布部分服务器，分多天发布。</p><h4 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h4><p>集群服务器之后，请求过来后，访问那一台服务器是具有不确定性的。</p><h5 id="秒杀系统的架构和设计"><a href="#秒杀系统的架构和设计" class="headerlink" title="秒杀系统的架构和设计"></a>秒杀系统的架构和设计</h5><p>1、秒杀系统独立部署，与网站其他功能尽量没有关联，秒杀商品页面静态化，用户请求不需要经过应用服务<br>器进行跳转或者逻辑处理，秒杀页面租借秒杀活动网络带宽，将秒杀商品页面缓存到CDN中。<br>2、部署定时任务服务器，动态生成随机下单页面的URL，推送到javascript服务器中，到点后，静态页面刷<br>新，购买按钮点亮。<br>3、设置全局计数器服务器，每次下单前都要取缓存中的数字进行比对，如果大于缓存中的数字，则直接返<br>回活动结束页面，否则提交到订单处理子系统。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>服务器配置实时更新之后的分布式配置，如用zookeeper共享配置。<br>分布式环境下实现并发访问协同的分布式锁。<br>分布式批量操作等。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;我为什么读这本书？&quot;&gt;&lt;a href=&quot;#我为什么读这本书？&quot; class=&quot;headerlink&quot; title=&quot;我为什么读这本书？&quot;&gt;&lt;/a&gt;我为什么读这本书？&lt;/h4&gt;&lt;p&gt;最近在研究分布式相关，在网上聊的热火朝天，都说这本书入门好。李智慧编写，电子工业出版社出版，&lt;br&gt;
    
    </summary>
    
      <category term="读书" scheme="https://ouzhrm.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="分布式" scheme="https://ouzhrm.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="https://ouzhrm.github.io/2018/04/12/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>https://ouzhrm.github.io/2018/04/12/我的第一篇博客/</id>
    <published>2018-04-12T06:39:32.000Z</published>
    <updated>2018-05-20T08:36:48.513Z</updated>
    
    <content type="html"><![CDATA[<p>接触博客已经3、4年了，但是一直没有搭建过自己的一个独立的博客，曾经在github上，csdn上写过，<br>最高的那篇文章浏览量也已经过万，那是大二的时候了。今天浏览github的时候无意之中看见了搭建<br><a id="more"></a><br>博客的教程，心里突然想到的是，一味的索取他人的知识，没有奉献过自己的知识，顿时感觉到是不是<br>有点自私了？于是乎，经过三天的摸索，终于搭建了一个自己的小博客，写这篇博客的目的是，希望勉<br>励自己，不断前行，尽可能的为互联网事业奉献自己的一份微薄之力。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接触博客已经3、4年了，但是一直没有搭建过自己的一个独立的博客，曾经在github上，csdn上写过，&lt;br&gt;最高的那篇文章浏览量也已经过万，那是大二的时候了。今天浏览github的时候无意之中看见了搭建&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://ouzhrm.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://ouzhrm.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
