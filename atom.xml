<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kevin Chow&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ouzhrm.github.io/"/>
  <updated>2018-04-21T05:19:13.918Z</updated>
  <id>https://ouzhrm.github.io/</id>
  
  <author>
    <name>Kevin Chow</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>高并发环境下mysql的调优</title>
    <link href="https://ouzhrm.github.io/2018/04/21/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8Bmysql%E7%9A%84%E8%B0%83%E4%BC%98/"/>
    <id>https://ouzhrm.github.io/2018/04/21/高并发环境下mysql的调优/</id>
    <published>2018-04-21T04:04:47.000Z</published>
    <updated>2018-04-21T05:19:13.918Z</updated>
    
    <content type="html"><![CDATA[<p><strong>skip-locking</strong><br>避免MySQL的外部锁定，减少出错几率增强稳定性。  </p><p><strong>back_log = 384</strong><br>back_log 参数的值指出在MySQL暂时停止响应新<br>请求之前的短时间内多少个请求可以被存在堆栈中。<br>对于Linux系统推荐设置为小于512的整数。  </p><p><strong>key_buffer_size = 256M</strong><br>key_buffer_size指定用于索引的缓冲区大小，增<br>加它可得到更好的索引处理性能。对于内存在4GB<br>左右的服务器该参数可设置为256M或384M。注意：<br>该参数值设置的过大反而会是服务器整体效率降低！  </p><p><strong>sort_buffer_size = 6M</strong><br><strong>查询排序时所能使用的缓冲区大小</strong>。注意：该参数<br>对应的分配内存是每连接独占，如果有100个连接，<br>那么实际分配的总共排序缓冲区大小为100 × 6 ＝<br>600MB。内存在4GB左右的服务器推荐设置为6-8M。  </p><p><strong>read_buffer_size = 4M</strong><br>读查询操作所能使用的缓冲区大小。<br>和sort_buffer_size一样，该参数对应的分配内存<br>也是每连接独享。 </p><p><strong>join_buffer_size = 8M</strong><br>联合查询操作所能使用的缓冲区大小，和<br>sort_buffer_size一样，该参数对应的分<br>配内存也是每连接独享。  </p><p><strong>query_cache_size = 64M</strong><br>指定MySQL查询缓冲区的大小</p><p><strong>max_connections = 768</strong><br>指定MySQL允许的最大连接进程数。如果在<br>访问论坛时经常出现Too Many Connections<br>的错误提 示，则需要增大该参数值</p><p><strong>wait_timeout = 10</strong><br>指定一个连接请求的最大等待时间，对于4GB左右<br>内存的服务器可以设置为5-10。  </p><p><strong>thread_concurrency = 8</strong><br>该参数取值为服务器逻辑CPU数量<em>2，在本例中，<br>服务器有2颗物理CPU，而每颗物理CPU又支持H.T<br>超线程，所以实际取值为4</em>2=8  </p><p><strong>table_cache=1024</strong><br>物理内存越大,设置就越大.默认为2402,<br>调到512-1024最佳。</p><p><strong>innodb_thread_concurrency=8</strong><br>你的服务器CPU有几个就设置为几,建议用默认一般为8  </p><h5 id="MyISAM和InnoDB优化"><a href="#MyISAM和InnoDB优化" class="headerlink" title="MyISAM和InnoDB优化"></a>MyISAM和InnoDB优化</h5><p><strong>key_buffer_size</strong><br>这对MyISAM表来说非常重要。如果只是使用<br>MyISAM表，可以把它设置为可用内存的 30-40%。<br>合理的值取决于索引大小、数据量以及负载<br>如果很少使用MyISAM表，那么也保留低于16-32MB<br>的key_buffer_size以适应给予磁盘的临时表索引所需。</p><p><strong>innodb_buffer_pool_size</strong><br>Innodb相比MyISAM表对缓冲更为敏感。<br>一般设置它高达70-80%的可用内存。</p><p><strong>innodb_log_file_size </strong><br>在高写入负载尤其是大数据集的情况下很重要。<br>这个值越大则性能相对越高，但是要注意到可能<br>会增加恢复时间。我经常设置为 64-512MB，<br>跟据服务器大小而异</p><p><strong>innodb_log_buffer_size</strong><br> 默认的设置在中等强度写入负载以及较短事务的情<br> 况下，服务器性能还可以。如果存在更新操作峰值<br> 或者负载较大，就应该考虑加大它的值了。如果它的<br> 值设置太高了，可能会浪费内存 — 它每秒都会刷新<br> 一次，因此无需设置超过1秒所需的内存空间。通常<br> 8-16MB 就足够了。越小的系统它的值越小。</p><p><strong>innodb_flush_logs_at_trx_commit </strong><br>把它的值设置为2就可以了，也就是不把日志刷新到磁盘上，<br>而只刷新到操作系统的缓存上。日志仍然会每秒刷新到磁盘中<br>去，因此通常不会丢失每秒1-2次更新的消耗。</p><p><strong>table_cache</strong><br>表缓存<br>如果你有200多个表的话，那么设置为 1024 也许比较合适（<br>每个线程都需要打开表），如果连接数比较大那么就加大它<br>的值。我曾经见过设置为 100,000 的情况。</p><p><strong>thread_cache</strong><br>线程的创建和销毁的开销可能很大，<br>因为每个线程的连接/断开都需要。<br>我通常至少设置为 16。如果应用程序中有大量的跳跃<br>并发连接并且 Threads_Created 的值也比较大，<br>加大它的值目的是在通常的操作中无需创建新线程。</p><p><strong>query_cache</strong><br>如果你的应用程序有大量读，而且没<br>有应用程序级别的缓存，那么这很有用。不要把它设<br>置太大了，因为想要维护它也需要不少开销，这会导<br>致MySQL变慢。通 常设置为 32-512Mb。设置完之后最<br>好是跟踪一段时间，查看是否运行良好。在一定的负载<br>压力下，如果缓存命中率太低了，就启用它。</p><h4 id="下面是一些常见参数优化案例"><a href="#下面是一些常见参数优化案例" class="headerlink" title="下面是一些常见参数优化案例"></a>下面是一些常见参数优化案例</h4><p><strong>thread_concurrency = 4 </strong><br>服务器cpu内核数(真实的并发处理数)</p><h5 id="各种缓存大小"><a href="#各种缓存大小" class="headerlink" title="各种缓存大小"></a>各种缓存大小</h5><p><strong>key_buffer = 384M </strong> 索引块缓存<br><strong>max_allowed_packet = 1M  </strong><br>mysql服务器端和客户端在一次传送数据包的过程当中数据包的大小<br><strong>table_cache = 2048 </strong><br>所有线程打开表的数量<br><strong>sort_buffer_size = 2M</strong> 对排列缓存<br><strong>read_buffer_size = 2M</strong> 读缓存<br><strong>read_rnd_buffer_size = 8M </strong> 随即读排序缓存<br><strong>myisam_sort_buffer_size = 64M </strong><br>排序MyISAM索引分配的缓冲区<br><strong>thread_cache_size = 8 </strong><br>可以复用的保存在缓存中的线程的数量<br><strong>query_cache_size = 32M</strong> 查询缓存<br><strong>tmp_table_size = 256M</strong> 临时表大小<br><strong>max_heap_table_size = 256M</strong> 内存表大小</p><h5 id="延时等待"><a href="#延时等待" class="headerlink" title="延时等待"></a>延时等待</h5><p><strong>interactive_timeout=2880000</strong>  对后续起的交互链接有效；<br><strong>wait_timeout=2880000</strong> 对当前交互链接有效；</p><h5 id="连接数"><a href="#连接数" class="headerlink" title="连接数"></a>连接数</h5><p><strong>max_connections= 5000 </strong> 最大并发数<br><strong>max_connect_errors = 6000 </strong><br>是MySQL中与安全有关的计数器值，它负责阻止过<br>多尝试失败的客户端以防止暴力破解密码的情况。<br><strong>back_log=500</strong> 堆栈队列大小</p><h5 id="域名相关"><a href="#域名相关" class="headerlink" title="域名相关"></a>域名相关</h5><p><strong>skip-name-resolve</strong>  跳过反响解析</p><h5 id="下面是一些查询语句"><a href="#下面是一些查询语句" class="headerlink" title="下面是一些查询语句"></a>下面是一些查询语句</h5><p>在主库上查看主库的状态：<br>show master status;</p><p>查看从库的状态：<br>show slave status；</p><h5 id="数据库主从复制原理："><a href="#数据库主从复制原理：" class="headerlink" title="数据库主从复制原理："></a>数据库主从复制原理：</h5><p>数据库的主从复制就是从master数据库复制到<br>slave数据库，在master与slave之间实现整个<br>复制需要三个线程来完成，其中两个在slave<br>端一个在master端。在master端必须打开binlog<br>功能，因为从数据库需要获得主数据的完整的<br>操作日志然后再自身上顺序的执行日志中的各种操作。</p><p>概要步骤：将master的bin-log写到slave的relay-log中，<br>然后执行里面的语句。</p><p>详细步骤：<br>1、将slave的io线程连上master，请求获得指定日志文<br>件的指定位置之后的操作日志的内容；<br>2、master获得slave的io线程请求后，将请求中读取到<br>的指定日志的指定位置之后的内容返回给slave端的io<br>线程，其中包括binlog 的位置以及名称；<br>3、slave端的io线程在接收到信息后，将接收到的日志<br>内容写入slave端的relay log文件的末端，并将binlog<br>的文件名和位置记录到master-info文件中，以便下一<br>次请求时向master提出请求；<br>4、slave的sql线程会检测到relay log中新增的一些日<br>志内容并加以解析成为可执行的query语句在slave端执<br>行，从而达到master与slave端的数据一致性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;skip-locking&lt;/strong&gt;&lt;br&gt;避免MySQL的外部锁定，减少出错几率增强稳定性。  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;back_log = 384&lt;/strong&gt;&lt;br&gt;back_log 参数的值指出在MySQL暂时停止响应新&lt;br&gt;请求
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://ouzhrm.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql常用配置参数</title>
    <link href="https://ouzhrm.github.io/2018/04/19/mysql%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0/"/>
    <id>https://ouzhrm.github.io/2018/04/19/mysql常用配置参数/</id>
    <published>2018-04-19T08:34:21.000Z</published>
    <updated>2018-04-21T01:37:34.303Z</updated>
    
    <content type="html"><![CDATA[<p>mysql在启动的时候，会加载my.ini（Linux系统下是my.cnf），即当mysql服务器启动时它会读取这<br>个文件，设置相关的运行环境参数。<br>查询当前全部参数设置sql语句为：show variables</p><p>下面是一些常用的配置参数：<br><strong>port=3306</strong><br>mysql使用的端口号</p><p><strong>atadir=/data/mysql</strong><br>数据文档存储目录,默认为/var/lib/mysql</p><p><strong>skip-slave-start</strong><br>禁止slave复制进程随Mysql数据库启动而启动，默认为未启用</p><p><strong>skip-name-resolve</strong><br>禁止Mysql进行DNS反向解析,默认为未启用,安装的MySql开启了DNS的反向解析,<br>禁止DNS反向解析后,只能通过Mysql授权表中IP来访问,可以提高Mysql访问速度.</p><p><strong>sort_buffer_size = 4M</strong><br>connection级参数，一个连接分配多少内存，默认为256KB。</p><p><strong>join_buffer_size = 2M</strong><br>默认为128KB，用于表间关联缓存的大小，和sort_buffer_size一样，该参数对应的分配内存也是每<br>个连接独享。如果应用中，很少出现join语句，则可以不用太在乎join_buffer_size参数的设置大小。<br>如果join语句不是很少的话，个人建议可以适当增大join_buffer_size到1MB左右，如果内存充足可以<br>设置为2MB</p><p><strong>table_open_cache = 5000</strong><br>打开表的缓存数量，默认为64。也不是定义内存的大小的。而是定义可以缓存多少打开的表的文件<br>句柄信息。如果定义的太小，那么mysql在需要打开新表的时候就要不断的关闭已经打开的表和打开<br>此次需要打开的表。性能会受到影响。</p><p><strong>table_definition_cache = 5000</strong><br>默认值为256 (Myslq5.12后，之前128)，表定义信息缓存是从MySQL5.1.3 版本才开始引入的一个<br>新的缓存区，用来存放表定义信息，设置好的话能提高对表定义信息的访问效率。</p><p><strong>thread_cache_size = 512</strong><br>定义缓存了的线程数量<br>只要设置的大小除以8小于物理内存就可以的。</p><p><strong>query_cache_size = 32M</strong><br>用来缓存特定Query 的结果集（Result Set）信息，默认值为0。在数据库写入量或是更新量也比较<br>大的系统，该参数不适合分配过大。而且在高并发，写入量大的系统，建议把该功能禁掉。</p><p><strong>query_cache_limit = 2M</strong><br>默认值为1MB<br>指定单个查询能够使用的缓冲区大小</p><p><strong>max_allowed_packet = 100M</strong><br>默认值为4M。<br>接受的数据包大小</p><p><strong>max_connect_errors = 1000000</strong><br>默认值为10<br>一个MySQL中与安全有关的计数器值，它负责阻止过多尝试失败的客户端以防止暴力破解密码的<br>情况。max_connect_errors的值与性能并无太大关系，mysqladmin flush-hosts命令来解锁已经<br>被屏蔽的主机</p><p><strong>max_connections = 1500</strong><br>默认值为100<br>MySQL允许最大的进程连接数，如果经常出现Too Many Connections的错误提示，则需要增大此值。</p><p><strong>tmp_table_size = 256M</strong><br>默认值大小为32M<br>临时表使用内存<br>如果一张临时表超出该大小，MySQL产生一个 The table tbl_name is full 形式的错误，如果你<br>做很多高级 GROUP BY 查询，增加 tmp_table_size 值。如果超过该值，则会将临时表写入磁盘。</p><p><strong>max_heap_table_size = 256M</strong><br>定义了用户可以创建的内存表(memory table)的大小。这个值用来计算内存表的最大行数值。这个<br>变量支持动态改变其大小还小于 tmp_table_size 的时候，MySQL 将使用 max_heap_table_size<br>参数所设置大小作为最大的内存临时表大小，而忽略 tmp_table_size 所设置的值。</p><h4 id="——–log———"><a href="#——–log———" class="headerlink" title="——–log———"></a>——–log———</h4><p><strong>slow_query_log=1</strong><br>slow quere log的开关，当值为1的时候说明开启慢查询。</p><p><strong>slow_query_log_file=slow.log</strong><br>慢查询日志位置及其文件名字</p><p><strong>long_query_time = 1</strong><br>慢查询时间 超过1秒则为慢查询</p><p><strong>log-error = mysql-error.log</strong><br>Mysql错误日志开关<br>错误日志位置及错误日志文件名</p><p><strong>log_slave_updates = 1</strong><br>默认为0(关闭状态)<br>控制从库通过I0线程读取主库二进制日志文件，<br>然后通过SQL线程写入的数据时候是否写入从库自身的binlog日志</p><p><strong>relay_log_purge = 0</strong><br>默认为1(自动删除状态)<br>控制SQL线程在执行完一个relay log后是否自动将其删除</p><p><strong>read_only = 1</strong><br>默认为0 (读写状态)<br>设置数据库为只读模式，只对普通用户起作用。对root或拥有super权限的无效果。</p><h4 id="——–binlog———"><a href="#——–binlog———" class="headerlink" title="——–binlog———"></a>——–binlog———</h4><p><strong>expire_logs_days = 30</strong><br>默认为0 (不自动删除)<br>设置binlog自动删除过期时间</p><p><strong>log-bin=mysql-bin</strong><br>默认为关闭<br>Mysql的binlog日志开关<br>设置binlog日志位置及日志文件名</p><p><strong>binlog_format=mixed</strong><br>默认为statement<br>binlog日志格式，建议使用mixed</p><p><strong>server-id = 1055</strong><br>Mysql server唯一标示，一般以时间戳就可以<br>主从同步中使用<br>mysql的同步的数据中是包含server-id的，用于标识该语句最初是从哪个server写入的。</p><h4 id="——–innodb———"><a href="#——–innodb———" class="headerlink" title="——–innodb———"></a>——–innodb———</h4><p><strong>innodb_data_home_dir = /data/mysql/ibdata</strong><br>默认使用MySQL的 datadir 目录为缺省目录<br>InnoDB表的目录共用设置<br>如果设定一个空字串,可以在 innodb_data_file_path 中设定绝对路径</p><p><strong>innodb_file_per_table = 1</strong><br>默认为关闭(值为0)<br>控制是否使用独立表空间模式</p><p><strong>innodb_autoextend_increment = 256</strong><br>默认是8M<br>当自动扩展表空间被填满之时，为扩展而增加的尺寸（MB为单位）<br>mysql 5.6.5版本之前默认值是8Mb，从5.6.6版本之后默认为64Mb，最小值为1Mb，最大值为1000Mb。<br>这个参数受到innodb_file_per_table参数的影响</p><p><strong>innodb_data_file_path=ibdata1:10M;ibdata2:10M:autoexte</strong><br>指定表数据和索引存储的空间，可以是一个或者多个文件。最后一个数据文件必须是自动扩充的，也<br>只有最后一个文件允许自动扩充。<br>例子：<br>假设希望创建一个数据文件ibdata1，初始大小为100MB，并希望在每次达到当前大小限制时，自动增加<br>8MB（8MB是指定autoextend时的默认扩展大小).但是，不希望此文件超过1GB，可以使用如下配置:<br>innodb_data_home_dir =<br>innodb_data_file_path = /data/ ibdata1:100M:autoextend:8M: max:1GB<br>如果此文件增加到预定的1G的限制，可以再增加另外一个数据文件,如下:<br>innodb_data_file_path = /data/ibdata1:100M:autoextend:8M: max:1GB;<br>innodb_data_file_path = /data2/ibdata2:100M:autoextend:8M: max:2GB</p><p><strong>innodb_table_locks = 0</strong><br>默认值为1<br>如果autocommit=1,Innodb的内部表锁可能会导致deadlock,可以通过设置innodb_table_locks=0来解决这<br>个问题，设置innodb_lock_wait_timeout变量,使deadlock超时后rollback</p><p><strong>innodb_lock_wait_timeout = 10</strong><br>MySQL在允许其他事务修改那些最终受事务回滚的数据之前要等待多长时间(秒数)</p><p><strong>innodb_buffer_pool_size = 16G</strong><br>默认为8M<br>InnoDB 用来高速缓冲数据和索引内存缓冲大小<br>可以设置60-80%的内存</p><p><strong>innodb_additional_mem_pool_size = 20M</strong><br>默认值为1MB<br>InnoDB 用来存储数据字典(data dictionary)信息和其它内部数据结构(internal data structures)的存<br>储器组合(memory pool)大小参数对系统整体性能并无太大的影响，只要能存放需要的数据就好，否则只会<br>浪费内存几百个Innodb 表的，推荐20M以内就足以了。<br>此参数在5.7中已经移除</p><p><strong>innodb_read_io_threads = 6</strong><br>后台读线程, 主要处理INNODB 数据文件异步读请求<br>每个read线程最多可以pend 256个任务(Linux平台中)</p><p><strong>innodb_write_io_threads = 6</strong><br>后台写线程数, 主要处理INNODB 数据文件异步写请求<br>每个write线程最多可以pend 256个任务(Linux平台中)</p><p><strong>innodb_flush_method=O_DIRECT</strong><br>默认为fdatasync<br>fdatasync：调用fsync()去刷数据文件与redo log的buffer<br>O_DSYNC：innodb会使用O_SYNC方式打开和刷写redo log,使用fsync()刷写数据文件<br>O_DIRECT：innodb使用O_DIRECT打开数据文件，使用fsync()刷写数据文件跟redo log</p><p><strong>innodb_log_files_in_group = 2</strong><br>默认为2<br>控制日志文件数</p><p><strong>innodb_log_file_size = 1G</strong><br>默认为 5M<br>用来在mysql crash后的恢复.所以设置合理的大小对于mysql的性能非常重要<br>通过show engine innodb status;可以查看mysql checkpoint情况，可以算<br>出上次checkpoint和最后一次checkpoint的中间值，官方文档建议最好不要超过<br>innodb_log_files_in_group*innodb_log_file_size的0.75<br>由此可以推算出innodb_log_file_size比较合适的值。<br>在mysql 5.5和5.5以前innodb的logfile最大设置为4GB,在5.6以后的版本中logfile<br>最大的可以设为512GB<br>当mysql crash后，在重启之前需要将老的innodb logfile删除。</p><p><strong>innodb_log_buffer_size = 48M</strong><br>默认为8M<br>当事务提交时，保存脏数据到内存中，后续再刷新保存到磁盘<br>适当调整此参数大小，可以减少磁盘I/O</p><p><strong>innodb_flush_log_at_trx_commit=2</strong><br>默认为1<br>控制log buffer写入log file和控制flush操作<br>innodb_flush_log_at_trx_commit=0，log buffer将每秒一次地写入log file中，<br>并且log file的flush(刷到磁盘)操作同时进行.该模式下，在事务提交的时候，不<br>会主动触发写入磁盘的操作。<br>innodb_flush_log_at_trx_commit=1，每次事务提交时MySQL都会把log buffer的<br>数据写入log file，并且flush(刷到磁盘)中去.<br>innodb_flush_log_at_trx_commit=2，每次事务提交时MySQL都会把log buffer的<br>数据写入log file.但是flush(刷到磁盘)操作并不会同时进行。该模式下,MySQL会<br>每秒执行一次 flush(刷到磁盘)操作。<br>注意：<br>  由于进程调度策略问题,这个“每秒执行一次 flush(刷到磁盘)操作”并不是保证<br>  100%的“每秒”。</p><p><strong>sync_binlog = 15</strong><br>默认值为0<br>像操作系统刷其他文件的机制一样，MySQL不会同步到磁盘中去而是依赖操作系统<br>来刷新binary log。当sync_binlog =N (N&gt;0) ，MySQL 在每写 N次 二进制日志<br>binary log时，会使用fdatasync()函数将它的写二进制日志binary log同步<br>到磁盘中去。<br>注:<br>   如果启用了autocommit，那么每一个语句statement就会有一次写操作；否则<br>   每个事务对应一个写操作。<br>   一般与innodb_flush_log_at_trx_commit同时设置</p><p><strong>innodb_support_xa = 0</strong><br>0表示关闭<br>分布式事务中此参数确保事务日志写入bin-log 的顺序与是事务的time-line 是<br>一致的</p><p><strong>sql_mode = NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</strong><br>默认为空<br>此参数在mysql数据库版本升级时候用比较合适</p><p><strong>binlog_cache_size=2M</strong><br>默认为32K<br>一个事务，在没有提交（uncommitted）的时候，产生的日志，记录到Cache中；<br>等到事务提交（committed）需要提交的时候，则把日志持久化到磁盘<br>在事务中存储二进制日志sql语句的缓存大小</p><p><strong>tx_isolation = READ-COMMITTED</strong><br>默认为 REPEATABLE READ<br>关于MySQL的事务处理及隔离级别<br>READ-UNCOMMITTED, READ-COMMITTED, REPEATABLE-READ, SERIALIZABLE</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mysql在启动的时候，会加载my.ini（Linux系统下是my.cnf），即当mysql服务器启动时它会读取这&lt;br&gt;个文件，设置相关的运行环境参数。&lt;br&gt;查询当前全部参数设置sql语句为：show variables&lt;/p&gt;
&lt;p&gt;下面是一些常用的配置参数：&lt;br&gt;
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://ouzhrm.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://ouzhrm.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务的四种隔离级别</title>
    <link href="https://ouzhrm.github.io/2018/04/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>https://ouzhrm.github.io/2018/04/19/数据库事务的四种隔离级别/</id>
    <published>2018-04-19T02:24:31.000Z</published>
    <updated>2018-04-21T01:37:33.477Z</updated>
    
    <content type="html"><![CDATA[<p>1.读没提交<br>事务A没有提交，做了一些写入或者更新操作，事务B可以读，但如果事务B发生回滚，那么就会出现脏读现象。<br>脏读可以理解成还没提交你就开始读，真脏的意思。实际做生产的时候一般不会使用这种事务。<br>2.读提交<br>和读没提交恰好相反，只有事务A提交了，事务B才可以读，大部分数据库支持这一种事务。<br>3.重复读<br>事务B先读一遍数据，事务A写入id为3的数据，事务B再查一遍数据，发现没有发生变化，也就是说事务之间隔离了，<br>但事务B也想写入id为3的数据时，发现无法写入，并提醒id重复,也就是所谓的幻读，似乎发生幻觉了一样。这种<br>隔离级别是事务各干各的，但是又有点联系那种，很模糊。mysql就是默认这种隔离级别的。<br>4.串行化<br>事务A正在查询，事务B写入，会发现事务B无法写入，显示正在等待状态。这是事务隔离级别中最严格的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.读没提交&lt;br&gt;事务A没有提交，做了一些写入或者更新操作，事务B可以读，但如果事务B发生回滚，那么就会出现脏读现象。&lt;br&gt;脏读可以理解成还没提交你就开始读，真脏的意思。实际做生产的时候一般不会使用这种事务。&lt;br&gt;2.读提交&lt;br&gt;和读没提交恰好相反，只有事务A提交了
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://ouzhrm.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>《大型网站技术架构 核心原理与案例分析》读书总结</title>
    <link href="https://ouzhrm.github.io/2018/04/18/%E3%80%8A%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E3%80%8B%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"/>
    <id>https://ouzhrm.github.io/2018/04/18/《大型网站技术架构-核心原理与案例分析》读书总结/</id>
    <published>2018-04-18T02:21:51.000Z</published>
    <updated>2018-04-21T05:36:11.924Z</updated>
    
    <content type="html"><![CDATA[<h4 id="我为什么读这本书？"><a href="#我为什么读这本书？" class="headerlink" title="我为什么读这本书？"></a>我为什么读这本书？</h4><p>最近在研究分布式相关，在网上聊的热火朝天，都说这本书入门好。李智慧编写，电子工业出版社出版，<br>豆瓣读书评分是7.9,一共有1000多人参与评论。我大概花了一个多星期的零碎时间，通读了这本书，大<br>概读到后面的后辈对晚辈的悉心嘱咐的时候，我就在豆瓣读书奉献了这本书的书评，给了三星。并作了<br>一些评论。毫无疑问，这本书真的是很适合入门，网上的兄弟们没骗我，它会在大型网站架构上给你一<br>些很全面的认识以及自己的一些经验之谈。但咋们做技术的，往往注重实用性，关注点在能不能用，怎<br>么用，用的时候注意什么，用的好不好等问题，但在这本书并没有深入。而最后，我想总结的是，这本<br>书更像一本兵书，想发力却又用不上来的那种感觉，又像师父领进门，修行看个人的感觉。如果说非要<br>给这本书来个标签，那可能是，有点失灵，但方向还基本正确的指南针，因为里面多少掺杂一些水分，<br>无关紧要的，能一句话说完，它非要说上1000来字，带点装*，自嗨的那种感觉。    </p><h4 id="这本书带给我的收获"><a href="#这本书带给我的收获" class="headerlink" title="这本书带给我的收获"></a>这本书带给我的收获</h4><p>一般后台的分三层：应用层，服务层，数据层。应用层一般是页面及控制器。服务层是一些可调用的接<br>口，可以理解成service层，而数据库层，也就是操作数据库的，可以理解成dao层。但这仅仅指的是java<br>层面上的理解。</p><p>先说应用层，也就是页面相关的。<br>流量入口，我们一般用nginx进行反向代理，负载均衡。将请求按轮询的方式或者hash方式分发到具体的<br>服务器或者网关。一些热点的静态页面（比如说主页）可以放到nginx缓存或者CDN服务器。而CDN、反向<br>代理服务器的原理都是缓存。当然，如果集群中的某一台服务器宕机了，要实现失效转移，将请求转发<br>到其他正常运行的服务器中。<br>1、页面优化<br>为减少http请求，我们要实现一个静态资源，合并css,js,以及请求数据量大的图片。其次，要通过设置<br>请求头的方式实现浏览器缓存，304重定向，防止图片，js的文件的再次加载。其次可以启用压缩，服务<br>器将文件压缩，浏览器解压缩。减少传输的数据量。其次css放在上面，js放在下面。因为加载页面<br>是从上往下加载的。<br>2、负载均衡<br>有几种方式，反向代理负载均衡，IP负载均衡，数据链路层负载均衡等。这些之后可以去了解一下，这<br>几种都是不同的。这本书也描述的不是特别清楚。然后以及负载均衡的算法，现在业内大部分是通过<br>一致性hash算法来实现请求到底去选择哪一台服务器。</p><p>然后说说服务层<br>当服务层的关系很复杂的时候，我们要对其进行解耦，解耦的方式有以下那么几种：<br>分布式服务：也就是rpc,远程方法调用，国内的Dubbo或者FaceBook通过Thrift来自主研发的框架。<br>原理简单：网络通信+编解码+服务端+客户端。<br>消息队列：消息队列是类似于生产者-消费者模式的。一头生产消息，另一头消费消息，中间来个管理消<br>息与推送消息的。也常常叫做消息中间件，jms。如：activemq，kafka等。在高并发支付场景可以使用。<br>但注意幂等性，消息重发等问题。独立部署web应用：当某一个服务与其他服务关联不大的时候，可以采<br>用单独拿出来，独立部署。</p><p>最后是数据层<br>关系型数据库往往会设计成读写分离（master写，一个或多个slave读）的模式。如mysql本身有主从热备<br>的功能，也就是数据库之间数据同步。先说下概念，热备份是主从复制，而冷备份定期存档。其次还有垂直水<br>平分库分表的方式，按业务模块分，按列，按时间等分出多个数据库或表。性能上，人为能改变的有sql优化、<br>索引设置等。然后是nosql相关的，nosql种类很多，如key-value形式，可用于存session，保证session<br>一致性的redis,文档型非关系型数据库mongoDB,此外还有mamcached等。<br>然后介绍几个概念，<br>缓存预热：将数据提前存到非关系型数据库如redis中，防止项目重新部署之后，关系型数据库如mysql访问<br>量过大而宕机。<br>缓存穿透：是指大量并发访问redis中一个不存在的数据，导致请求都往mysql上串，最终mysql访问量过大<br>而宕机，解决的方式可以是设置将redis不存在的数据立即返回null。</p><h4 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h4><p>自动化是我们的理想形态，如：自动化发布、自动化代码管理、自动化测试（安全、性能、功能），自动化<br>监控和报警（心跳检测、通知），自动化失效转移，超时转移和失效恢复、自动化降级、自动化分配资源等。</p><h4 id="大型网站要实现以下几种性质"><a href="#大型网站要实现以下几种性质" class="headerlink" title="大型网站要实现以下几种性质"></a>大型网站要实现以下几种性质</h4><p>可用性：一年内99.99%的时间里，服务器都能正常的运行及可提供功能访问。<br>伸缩性：线上增减服务器数量时对其它服务器的影响。<br>扩展性：增减功能对其他功能的影响。<br>安全性：保证网站的安全。</p><h4 id="CAP原理"><a href="#CAP原理" class="headerlink" title="CAP原理"></a>CAP原理</h4><p>C：数据一致性，保证请求在某一具体功能点上都能访问到相同或者说正确的数据。<br>A：数据可用性：任何时候请求的数据都能进行读写访问。<br>P：系统跨网络线性伸缩。</p><h4 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h4><p>每天只发布部分服务器，分多天发布。</p><h4 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h4><p>集群服务器之后，请求过来后，访问那一台服务器是具有不确定性的。</p><h5 id="秒杀系统的架构和设计"><a href="#秒杀系统的架构和设计" class="headerlink" title="秒杀系统的架构和设计"></a>秒杀系统的架构和设计</h5><p>1、秒杀系统独立部署，与网站其他功能尽量没有关联，秒杀商品页面静态化，用户请求不需要经过应用服务<br>器进行跳转或者逻辑处理，秒杀页面租借秒杀活动网络带宽，将秒杀商品页面缓存到CDN中。<br>2、部署定时任务服务器，动态生成随机下单页面的URL，推送到javascript服务器中，到点后，静态页面刷<br>新，购买按钮点亮。<br>3、设置全局计数器服务器，每次下单前都要取缓存中的数字进行比对，如果大于缓存中的数字，则直接返<br>回活动结束页面，否则提交到订单处理子系统。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>服务器配置实时更新之后的分布式配置，如用zookeeper共享配置。<br>分布式环境下实现并发访问协同的分布式锁。<br>分布式批量操作等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;我为什么读这本书？&quot;&gt;&lt;a href=&quot;#我为什么读这本书？&quot; class=&quot;headerlink&quot; title=&quot;我为什么读这本书？&quot;&gt;&lt;/a&gt;我为什么读这本书？&lt;/h4&gt;&lt;p&gt;最近在研究分布式相关，在网上聊的热火朝天，都说这本书入门好。李智慧编写，电子工业出版
      
    
    </summary>
    
      <category term="读书" scheme="https://ouzhrm.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="分布式" scheme="https://ouzhrm.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="https://ouzhrm.github.io/2018/04/12/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>https://ouzhrm.github.io/2018/04/12/我的第一篇博客/</id>
    <published>2018-04-12T06:39:32.000Z</published>
    <updated>2018-04-18T01:53:02.750Z</updated>
    
    <content type="html"><![CDATA[<p>接触博客已经3、4年了，但是一直没有搭建过自己的一个独立的博客，曾经在github上，csdn上写过，<br>最高的那篇文章浏览量也已经过万，那是大二的时候了。今天浏览github的时候无意之中看见了搭建<br>博客的教程，心里突然想到的是，一味的索取他人的知识，没有奉献过自己的知识，顿时感觉到是不是<br>有点自私了？于是乎，经过三天的摸索，终于搭建了一个自己的小博客，写这篇博客的目的是，希望勉<br>励自己，不断前行，尽可能的为互联网事业奉献自己的一份微薄之力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;接触博客已经3、4年了，但是一直没有搭建过自己的一个独立的博客，曾经在github上，csdn上写过，&lt;br&gt;最高的那篇文章浏览量也已经过万，那是大二的时候了。今天浏览github的时候无意之中看见了搭建&lt;br&gt;博客的教程，心里突然想到的是，一味的索取他人的知识，没有奉献过
      
    
    </summary>
    
      <category term="随笔" scheme="https://ouzhrm.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://ouzhrm.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
