<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kevin Chow&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ouzhrm.github.io/"/>
  <updated>2021-04-11T13:30:06.801Z</updated>
  <id>https://ouzhrm.github.io/</id>
  
  <author>
    <name>Kevin Chow</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>系统性能优化</title>
    <link href="https://ouzhrm.github.io/2021/01/20/%E6%8E%A5%E5%8F%A3%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"/>
    <id>https://ouzhrm.github.io/2021/01/20/接口优化总结/</id>
    <published>2021-01-20T15:16:39.000Z</published>
    <updated>2021-04-11T13:30:06.801Z</updated>
    
    <content type="html"><![CDATA[<h4 id="经历"><a href="#经历" class="headerlink" title="经历"></a>经历</h4><p>从刚参加工作到现在满打满算，有快4年时间了，期间优化过大大小小的服务，<br>2C2B的都有，基本上2C会严格些，因为它是面向用户的，用户体验好不好也直接<br>影响到用户的流失以及购买意愿等问题，响应时间尽可能在毫秒级，最慢不要超过<br>2秒，特别是核心的服务。2B的话只要不是特别慢，3到5秒都是可以容忍的,前提是<br>公司内部用户,对性能要求不是很高的受众。<br><a id="more"></a><br>    下面直接说思路,我们知道外网的请求通过网络, 先是走DNS服务器将域名解析成IP,<br>然后请求连接,tcp三次握手,将数据分组发送到对应的服务器上,然后服务器对根据<br>数据包的序号重组成完整的数据,期间数据包经过交换机,多个路由器转发,链路成解<br>析成帧单位的数据物理层解析成bit单位的数据,再经过交换机,最后到达服务器端,<br>服务器端通过进程的调度,处理完逻辑后, 原路返回给用户端.所以如果某个请求响应<br>很慢,那么需要在这些环节上拆解问题, ping 域名返回的时间,能知道网络时间,基本上<br>都是100ms以内,普遍5到50ms不等. 我的经验上看基本上不是网络的问题, 当然如果内<br>网有墙的情况下.</p><h4 id="网络和机器层面"><a href="#网络和机器层面" class="headerlink" title="网络和机器层面"></a>网络和机器层面</h4><pre><code>其次外网进内网会经过咋们自己实现的服务网关, 服务网关主要是监控流量,黑白名单,</code></pre><p>熔断限流鉴权转发等, 内网会对网关会有一个专门的心跳监测, 定时请求从网关到各个服务<br>的请求监测,如果不通会自动邮件告警, 微信告警.还有对机器的监测告警,CPU,内存,网络,硬盘<br>等,超过一定阈值会自动水平扩容和告警.</p><h4 id="代码逻辑层面"><a href="#代码逻辑层面" class="headerlink" title="代码逻辑层面"></a>代码逻辑层面</h4><p>服务通过切面（动态代理）记录耗时日志，如果2C接口超过1s，会发日志告警邮件，接口性能优<br>化，可通过批量、多线程、异步策略来优化。<br>    1、批量，即批量请求数据库或者缓存，减少在网络上浪费的时间，经验上看，很多同学会在<br>for循环上单个请求数据库或者缓存，别小看for循环，尽管单个请求数据库或者缓存是50毫秒，<br>那么50个item，就是2.5s，还没算其他逻辑或者其他请求链路上的时间，如果批量获取数据，<br>然后再处理，时间是90ms,那么节省了将近2.5s, 性能提升很明显。这也是我优化过接口很常见<br>的场景。<br>    2、多线程，如果主线程处理时间确实很长，可以通过多线程的方式并发处理，注意，如果使<br>用多线程，则注意线程安全（适当使用原子类）和CPU核数适当给大一些。多线程可以用jdk1.8最<br>新的parallelStream流，代码数比ThreadExecutor远远要小，内部原理采用fork/join窃取算法。<br>    3、异步，如果只能用主线程，不可以用多线程这样的场景，逻辑特别复杂冗长，我们可以<br>拆分成多个接口或者采用异步的处理手段，异步是将不是特别紧要的功能通过本地队列或者第<br>三方队列的形式实现解耦，实现快速响应返回。比如落库，订阅通知等等，如紧要的功能是访<br>问缓存获得，所以只需更新缓存，然后发消息去更新数据库和订阅通知。少了更新数据库和订<br>阅通知逻辑处理，大大提高了接口的吞吐量。<br>    4、此外，还有很多策略，用的比较少的，包括减少for循环，减少条件判断，运维层面的<br>sql调优，慢查询explain,比较复杂的垂直水平分库分表（涉及到数据迁移等操作，比较繁琐而<br>且风险比较大），读写分离，连接池数调优，加缓存（本地缓存、nosql，效果明显）,JVM调优<br>（这个我接触的少，主要是处理果full gc一些故障，可以用jmap命令和MAT插件定位对象）等等，<br>关键是找到瓶颈，定位到问题，对症下药，犹如木桶短板理论，木桶能装多少水，取决于最短的<br>那块木板。<br>    5、备选短期方案，弹性容器自动扩容。但长期成本过高。</p><h4 id="优化流程"><a href="#优化流程" class="headerlink" title="优化流程"></a>优化流程</h4><p>1、先让测试人员对接口进行压测，得到旧接口的压测报告和返回数据。<br>2、开发人员优化接口，让测试人员对优化后的新接口重新压测和比较新旧数据的准确性，回归<br>原有自动化测试用例，集成测试、功能测试。<br>3、部署方案，如果出现问题，紧急回滚到上一版。如果出问题需要最快止损，可以通过配置中心<br>配置对新旧代码实现快速切换。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;经历&quot;&gt;&lt;a href=&quot;#经历&quot; class=&quot;headerlink&quot; title=&quot;经历&quot;&gt;&lt;/a&gt;经历&lt;/h4&gt;&lt;p&gt;从刚参加工作到现在满打满算，有快4年时间了，期间优化过大大小小的服务，&lt;br&gt;2C2B的都有，基本上2C会严格些，因为它是面向用户的，用户体验好不好也直接&lt;br&gt;影响到用户的流失以及购买意愿等问题，响应时间尽可能在毫秒级，最慢不要超过&lt;br&gt;2秒，特别是核心的服务。2B的话只要不是特别慢，3到5秒都是可以容忍的,前提是&lt;br&gt;公司内部用户,对性能要求不是很高的受众。&lt;br&gt;
    
    </summary>
    
      <category term="系统性能" scheme="https://ouzhrm.github.io/categories/%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD/"/>
    
    
      <category term="优化" scheme="https://ouzhrm.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>基础架构部门elasticsearch使用经验研究</title>
    <link href="https://ouzhrm.github.io/2020/12/25/%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E9%83%A8%E9%97%A8elasticsearch%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C%E7%A0%94%E7%A9%B6/"/>
    <id>https://ouzhrm.github.io/2020/12/25/基础架构部门elasticsearch使用经验研究/</id>
    <published>2020-12-25T11:45:55.000Z</published>
    <updated>2021-04-11T08:43:49.957Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>对elasticsearch封装成一个服务opensearch平台，实现其他部门搜索功能的快速接入能力。<br><a id="more"></a></p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>站内搜索（订单、帖子、门店、产品、物流）、日志、系统调用链</p><h4 id="配置、生产数据"><a href="#配置、生产数据" class="headerlink" title="配置、生产数据"></a>配置、生产数据</h4><p>订单优惠券（16C 、32G 、3Node 、500G+数据、 1w+QPS、 RT &lt; 100ms，写入查询要求高<br>商品论坛（8C、16G、3Node、20G+数据、8k+QPS、RT &lt; 30ms）, 查询要求高<br>日志（16C 、32G 、32Node、日均60TB数据，RT秒级）、写入要求高 </p><h4 id="已有功能"><a href="#已有功能" class="headerlink" title="已有功能"></a>已有功能</h4><p>admin后台（分类管理、过滤标签管理、索引管理、定时mysql同步、词典&amp;同义<br>词管理、黑白名单）、下拉推荐词、异地容灾、系统监控</p><h4 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h4><p>双写+快照，双写保证实时性，快照保证最终一致性。</p><h4 id="优化案例"><a href="#优化案例" class="headerlink" title="优化案例"></a>优化案例</h4><p>深度分页、cpu内存增高、用scroll解决 、_id以分类作前辍容易造成hash冲突<br>导致分片不均，解决方式为_id随机生成，更新删除由业务Id作条件删除。</p><h4 id="电商搜索领域重点关注"><a href="#电商搜索领域重点关注" class="headerlink" title="电商搜索领域重点关注"></a>电商搜索领域重点关注</h4><p>不能丢品，性能高，召回、准确率高</p><h4 id="目前功能"><a href="#目前功能" class="headerlink" title="目前功能"></a>目前功能</h4><p>仅实现布尔模型、空间向量模型，成本收益考虑，不实现NLP等高级功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;对elasticsearch封装成一个服务opensearch平台，实现其他部门搜索功能的快速接入能力。&lt;br&gt;
    
    </summary>
    
      <category term="搜索" scheme="https://ouzhrm.github.io/categories/%E6%90%9C%E7%B4%A2/"/>
    
    
      <category term="elasticsearch" scheme="https://ouzhrm.github.io/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>业界使用elasticsearch经验研究</title>
    <link href="https://ouzhrm.github.io/2020/12/12/elasticsearch%E4%B8%9A%E7%95%8C%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C%E7%A0%94%E7%A9%B6/"/>
    <id>https://ouzhrm.github.io/2020/12/12/elasticsearch业界使用经验研究/</id>
    <published>2020-12-12T15:12:45.000Z</published>
    <updated>2021-04-11T08:44:06.604Z</updated>
    
    <content type="html"><![CDATA[<h4 id="去哪儿"><a href="#去哪儿" class="headerlink" title="去哪儿"></a>去哪儿</h4><p>docker+k8s部署elasticsearch, 设定慢日志记录，<br>节点划分（data, master, hot, warm这些），分片数副本数<br>设定， opensearch系统的自助配置，监控和报警，监控数据汇总<br>审计日志，错误日志，访问日志。<br>PB级数据量写入和查询<br>使用场景：附近的人（GPS）, 报表，监控统计，物/车联网传感器数据，<br>日志实时分析，站内搜索（订单，产品，文档），<br>定期force merge (segment 是jvm消耗的主要者)<br><a id="more"></a></p><h4 id="腾讯云"><a href="#腾讯云" class="headerlink" title="腾讯云"></a>腾讯云</h4><p>考虑问题：成本，可用性，性能。<br>可用性挑战：大查询，瞬间性的压力过载，数据损坏，master堵塞<br>成本挑战：定时关闭历史索引，磁盘利用率低<br>性能挑战：<br>写入： bulk ,  多线程， 自带主键（_id）性能衰退1倍<br>查询：毛刺,<br>查询时间要求敏感，需要深度调优，数值体现<br>限流、熔断（timeout请求）、备份、跨区多机房容灾, 权限(opengateway)，<br>冷数据落盘（生命周期管理，日期滑动窗口），降低GC，优化merge策略，查询剪枝</p><h4 id="跨越速运"><a href="#跨越速运" class="headerlink" title="跨越速运"></a>跨越速运</h4><p>多重聚合性能问题（快递行业按月度建索引和查询聚合）<br>指标: QPS, 平均响应时间<br>bucket原理： 先分组后查询，节省内存空间<br>mysql: 先查询后分组<br>elasticsearch聚合能力边界：深度二次聚合，去重后聚合</p><h4 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h4><p>自动化运维（基于经验。类似watch监控）：自动诊断系统（正则删除禁用、别<br>名使用，dynamic禁用，GC日志、slow log日志，type合理性）</p><h4 id="个推"><a href="#个推" class="headerlink" title="个推"></a>个推</h4><p>elasticsearch0.9到1.5版本的升级，升级前比较多问题，节点脱离集群，jvm的<br>堆内存过高（fresh原因）</p><h4 id="滴滴"><a href="#滴滴" class="headerlink" title="滴滴"></a>滴滴</h4><p>应用场景：redis从库、 日志搜索、安全场景分析、应用核心搜索<br>3500+节点、1000+应用， 8PB+数据量，月存储成本350w+, 5w+QPS<br>数据同步（redis2es, hive2es, log2es）、数据清理（ingest节点）、<br>多版本兼容、版本升级、容量规划、DSL审核、<br>权限审计、多租户隔离（opensearch）、跨集群访问、indexTemplate 管理、租户管理、<br>DSL模板管理、用户自助接入、系统集成、学习使用成本低，自助式运维（监控体系化）<br>稳定性建设：事前（资源隔离、查询审核），事中（限流，查询熔断），事后（快速修复、止损）<br>95%命中三天的数据（优化：冷热数据），25%的字段数据从未被查询过（优化：索引重建）</p><h4 id="斗鱼（es版本1-x）"><a href="#斗鱼（es版本1-x）" class="headerlink" title="斗鱼（es版本1.x）"></a>斗鱼（es版本1.x）</h4><p>mapping创建留备用字段，防止reindex索引<br>避免wildcard查询<br>网关：权限、查询超时熔断、限流，流量监控</p><h4 id="百度-es版本2-x-优化改进"><a href="#百度-es版本2-x-优化改进" class="headerlink" title="百度(es版本2.x 优化改进)"></a>百度(es版本2.x 优化改进)</h4><p>(在线动态增加字段,修改分词器)，加版本号，后台job自动reindex<br>DistributedLog: 强一致读写，高性能、高可用、可扩展</p><h4 id="360"><a href="#360" class="headerlink" title="360"></a>360</h4><p>elasticsearch加速spacksql查询，把mysql数据弄到es上</p><h4 id="LinkedIn-做日志搜索和分析"><a href="#LinkedIn-做日志搜索和分析" class="headerlink" title="LinkedIn :做日志搜索和分析"></a>LinkedIn :做日志搜索和分析</h4><p>能用SSD就不用SATA<br>JVM heap设置不要超过32GB，shard不要超过50GB</p><h4 id="知乎"><a href="#知乎" class="headerlink" title="知乎"></a>知乎</h4><p>现状：3500+节点、3000+索引、50000+shard、5PB数据存储和搜索、峰值2000w/s写入</p><p>应用场景： 日志搜索、 站内/app核心搜索（订单、附近的车辆）、 安全监控日志搜索和聚合分析</p><p>架构： 多集群、写入加一层sink服务 &amp; kafka 做流量削峰、查询加一层gateway做限流熔断、安全<br>审计、流量监控等， 跨集群加一层低版本叫tribeNode、高版本叫跨集群（流量代理）来实现跨集群<br>搜索， admin服务提供对索引的生命周期管理、容量自动规划、索引和集群健康监控等功能。kafka<br>可以回溯数据做故障恢复，分发消息到多个集群中。</p><p>优点：支撑业务线可快速接入、统一管理与运维、可靠性高、对业务线隐藏es技术细节，做到对业务<br>无感知，可快速扩缩容、自动化部署、水平扩展快。</p><p>缺点：复杂性、风险性增加，如下瓶颈和挑战。<br>瓶颈和挑战：<br>1）稳定性挑战:<br>tribeNode会merge每个集群的ClusterState对象，对外看起来就是一个包含所有索引的节点，<br>ClusterState包含索引、分片和节点数据分布表等数据，如果在变更或者查询这些数据时，<br>tribeNode会转发这些数据到各个集群的shard中，异步等待各个shard执行成功汇总返回。<br>如果某个节点假死，如JVM堆内存飙升，则等待响应时间长，如果这样的请求很多，<br>netty的worker线程用完，则进入队列等待，阻塞影响到后面的请求操作。<br>2）统一性/规范性挑战:<br>每个集群都有自己的_cluster setting，indexTemplate . 这导致在跨集群搜索的时候难<br>以进行。解决方式是内部实现统一的lucene、es版本。<br>3）容量规划挑战:<br>在创建索引前先对容量进行规划，容量满了则需要对索引转移，后期应实现自动化容量转移和规划。</p><h4 id="阿里云elasticsearch"><a href="#阿里云elasticsearch" class="headerlink" title="阿里云elasticsearch"></a>阿里云elasticsearch</h4><p>1、支持sql查询，提高易用性、降低学习成本。<br>2、Faster bulk插件写入吞吐提升20%。<br>3、一键索引迁移。<br>4、支持异步写入。<br>5、支持高版本如7.7。<br>6、自动告警。<br>7、节点数弹性扩缩容，存储自动升降配。<br>8、支持冷热数据，冷数据走SATA盘，降低成本。<br>9、支持brotli和zstd压缩算法，具有更高的索引压缩比，大幅降低索引存储成本，写入性能下降10%，<br>压缩率提升45%。<br>11、支持限流降级插件。<br>12、支持场景化模板，帮助用户进行配置，使集群和索引配置达到最优。场景分为：持通用场景、数<br>据分析场景、数据库加速场景和搜索场景；日志增强版支持日志场景。支持在控制台上根据业务情<br>况修改所选场景，并查看、修改、应用相应的配置，从而优化集群的参数和索引情况，减少由于使<br>用错误导致的集群异常和性能问题。<br>13、在控制台日志模块查询ES访问日志，包含请求时间、客户端来源、请求内容等，可用于问题排<br>查和请求分析。<br>14、智能运维诊断结果推送，通过邮件方式，为用户推送相关实例的健康诊断报告，集群变更与数<br>据备份功能。支持每半小时的自动数据备份时间间隔，以及自定义备份周期。<br>15、Beats数据采集中心上线，提供多beats标准化接入方案。<br>16、支持用户上传自定义同义词文件，并通过分词器设置自定义分词策略。<br>17、提供Error Log、Slow Log、GC Log日志的查看及搜索功能，并且提供时间的filter能力。方<br>便用户查看了解集群的状况。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;去哪儿&quot;&gt;&lt;a href=&quot;#去哪儿&quot; class=&quot;headerlink&quot; title=&quot;去哪儿&quot;&gt;&lt;/a&gt;去哪儿&lt;/h4&gt;&lt;p&gt;docker+k8s部署elasticsearch, 设定慢日志记录，&lt;br&gt;节点划分（data, master, hot, warm这些），分片数副本数&lt;br&gt;设定， opensearch系统的自助配置，监控和报警，监控数据汇总&lt;br&gt;审计日志，错误日志，访问日志。&lt;br&gt;PB级数据量写入和查询&lt;br&gt;使用场景：附近的人（GPS）, 报表，监控统计，物/车联网传感器数据，&lt;br&gt;日志实时分析，站内搜索（订单，产品，文档），&lt;br&gt;定期force merge (segment 是jvm消耗的主要者)&lt;br&gt;
    
    </summary>
    
      <category term="搜索" scheme="https://ouzhrm.github.io/categories/%E6%90%9C%E7%B4%A2/"/>
    
    
      <category term="elasticsearch" scheme="https://ouzhrm.github.io/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>评审思考</title>
    <link href="https://ouzhrm.github.io/2020/05/05/%E8%AF%84%E5%AE%A1%E6%80%9D%E8%80%83/"/>
    <id>https://ouzhrm.github.io/2020/05/05/评审思考/</id>
    <published>2020-05-05T14:19:58.000Z</published>
    <updated>2021-04-11T03:53:47.850Z</updated>
    
    <content type="html"><![CDATA[<h4 id="会议过程"><a href="#会议过程" class="headerlink" title="会议过程"></a>会议过程</h4><p>会前预审<br>会中记录<br>会后跟踪</p><a id="more"></a><p>评审：集中所有人的智慧更好的解决问题，最好每个人都要发言。</p><p>根据一般软件的开发过程。大体可分为：方案评审、设计评审、代码评审</p><h4 id="方案评审考虑的要素-5w1h"><a href="#方案评审考虑的要素-5w1h" class="headerlink" title="方案评审考虑的要素(5w1h)"></a>方案评审考虑的要素(5w1h)</h4><p>目的和背景（是什么，为什么，投入和产出比考虑）<br>资源协调（组和人，谁做）<br>划分边界（在哪块做比较合适）<br>优先级（里程碑，什么时候做）<br>风险（怎么做，落地问题，技术难点，业务如政策、数据脱敏等难点，风控安全）</p><h4 id="设计评审考虑的要素"><a href="#设计评审考虑的要素" class="headerlink" title="设计评审考虑的要素"></a>设计评审考虑的要素</h4><p>系统稳定性（技术选型，引入新组件，如有）<br>性能<br>影响（对原有系统服务逻辑、数据的影响）<br>可维护性（降低系统的复杂性，易于重构）<br>可扩展性（满足2到3年的业务发展）<br>复杂模块设计图（清晰易懂）<br>遵循已有规范和架构<br>风险折衷</p><h4 id="代码评审考虑的要素"><a href="#代码评审考虑的要素" class="headerlink" title="代码评审考虑的要素"></a>代码评审考虑的要素</h4><p>code review</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;会议过程&quot;&gt;&lt;a href=&quot;#会议过程&quot; class=&quot;headerlink&quot; title=&quot;会议过程&quot;&gt;&lt;/a&gt;会议过程&lt;/h4&gt;&lt;p&gt;会前预审&lt;br&gt;会中记录&lt;br&gt;会后跟踪&lt;/p&gt;
    
    </summary>
    
      <category term="开会和评审" scheme="https://ouzhrm.github.io/categories/%E5%BC%80%E4%BC%9A%E5%92%8C%E8%AF%84%E5%AE%A1/"/>
    
    
      <category term="评审思考" scheme="https://ouzhrm.github.io/tags/%E8%AF%84%E5%AE%A1%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>需求讨论什么内容？</title>
    <link href="https://ouzhrm.github.io/2020/05/03/%E9%9C%80%E6%B1%82%E8%AE%A8%E8%AE%BA-%E5%8F%82%E4%B8%8E%E4%BA%BA%E8%A7%92%E5%BA%A6/"/>
    <id>https://ouzhrm.github.io/2020/05/03/需求讨论-参与人角度/</id>
    <published>2020-05-03T13:12:48.000Z</published>
    <updated>2021-04-11T03:50:08.097Z</updated>
    
    <content type="html"><![CDATA[<h4 id="需求评审的目的是为了搞清楚："><a href="#需求评审的目的是为了搞清楚：" class="headerlink" title="需求评审的目的是为了搞清楚："></a>需求评审的目的是为了搞清楚：</h4><p>1、需求是什么，从哪里来，对业务的影响是什么，价值在哪里，<br>对开发的要求是什么。<br>2、需求是一次性的，还是需要分期实现的，是解决一个问题，还<br>是解决多个问题，扩展性如何，通用性如何。<br>3、需求如何实现，边界划分，业务方面有无配合的部分，开发方<br>面哪里有风险，哪里是难点，哪里是重点，有没有可以复用的部分，<br>周期如何，优先级怎样。<br>4、需求实现之后，可以达到的效果，对业务的帮助，等等<br><a id="more"></a></p><h4 id="所以一般需求评审前，要做几件事："><a href="#所以一般需求评审前，要做几件事：" class="headerlink" title="所以一般需求评审前，要做几件事："></a>所以一般需求评审前，要做几件事：</h4><p>1、和相关人员沟通，确保这个需求是具有可行性的，对现有业务有帮助的。<br>2、明确会议的重点，是沟通好目标还是确认细节实现的过程，准备好相关的<br>文档、模型、低保真的演示demo，和开发人员沟通需求实现的复杂度，需要<br>召集哪些人员，架构要不要参与、测试可能要几个人力、风控是否要介入，<br>在会议中承担的角色和职责分别为何。<br>3、准备好需求检查单需求评审中，要增加交流，阐述明确，让参与评审的人。<br>员尽可能的明确的多次提问，把需求讨论清楚，并在会议中达成共识，形成<br>决议，通过需求检查去确认遗漏。最后就是实施。</p><h4 id="总结：5w1h"><a href="#总结：5w1h" class="headerlink" title="总结：5w1h"></a>总结：5w1h</h4><p>what  why who where when how<br>需求是什么？为什么？细节和特殊情况是否全面。<br>什么时候做？即优先级，是否分期实现。<br>放到那个组、那个模块做合适，由谁做？划分边界<br>最后，才是怎么做？<br>how，重点考虑下面两个问题<br>针对用户量的增长<br>针对数据量的增长</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;需求评审的目的是为了搞清楚：&quot;&gt;&lt;a href=&quot;#需求评审的目的是为了搞清楚：&quot; class=&quot;headerlink&quot; title=&quot;需求评审的目的是为了搞清楚：&quot;&gt;&lt;/a&gt;需求评审的目的是为了搞清楚：&lt;/h4&gt;&lt;p&gt;1、需求是什么，从哪里来，对业务的影响是什么，价值在哪里，&lt;br&gt;对开发的要求是什么。&lt;br&gt;2、需求是一次性的，还是需要分期实现的，是解决一个问题，还&lt;br&gt;是解决多个问题，扩展性如何，通用性如何。&lt;br&gt;3、需求如何实现，边界划分，业务方面有无配合的部分，开发方&lt;br&gt;面哪里有风险，哪里是难点，哪里是重点，有没有可以复用的部分，&lt;br&gt;周期如何，优先级怎样。&lt;br&gt;4、需求实现之后，可以达到的效果，对业务的帮助，等等&lt;br&gt;
    
    </summary>
    
      <category term="code review" scheme="https://ouzhrm.github.io/categories/code-review/"/>
    
    
      <category term="需求分析" scheme="https://ouzhrm.github.io/tags/%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>code review分享</title>
    <link href="https://ouzhrm.github.io/2020/05/02/code%20review%E5%88%86%E4%BA%AB/"/>
    <id>https://ouzhrm.github.io/2020/05/02/code review分享/</id>
    <published>2020-05-02T11:59:06.000Z</published>
    <updated>2021-04-11T03:37:07.139Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h4><p>code review本质是鼓励开发者间更多的沟通，互相学习，营造技术文化氛围。<br>code review按照后面咋们讨论的check清单一项一项的检查, 以此来降低项目<br>出现的一些低级别的错误和没cover 到场景等错误. 定期总结和优化check 清<br>单,  熟悉模块之间的依赖, 后期逐步提高开发效率,  丰富全局考虑问题的思<br>维, 有利于开发之间学习和成长。code review 比较符合从有到优的发展阶段。<br>code review 的目标长期来看，收益是提升团队的项目质量，减少团队陷入反<br>复修复 bug 的困境中，让团队有机会去面对更多的挑战。<br>code review 对个人和团队而言都是成长的机会，要用开放的包容的心态去接<br>受不同的意见，取其精华。<br><a id="more"></a></p><h4 id="二、目标"><a href="#二、目标" class="headerlink" title="二、目标"></a>二、目标</h4><p>1、每月选一人分享一次，内容包括：过去一个月code review心得与经验总结，<br>新增并列举些review项，耗时不超过半个小时。<br>2、Code Review 要计入开发的工作量，建议最好2小时以内，不超过4个小时<br>3、在提交测试之前做code review<br>4、一次提交代码行数不宜多，功能完整。<br>5、大功能代码review需要当面沟通，提高效率<br>6、每次review完至少做一次赞赏，本身review是离开舒适区的表现。code review<br> 并不只是为了找错，看到好的代码，不要吝啬你的赞美.<br>7、优先级问题，先专注自己的工作，后code review, 应当在一个工作日之内回应<br>Code Review请求，Code Review应该越快越好. 务必趁热打铁，因为一个星期后可<br>能自己写的代码都不认识。</p><h4 id="三、check-list"><a href="#三、check-list" class="headerlink" title="三、check list"></a>三、check list</h4><p>0、线程安全问题：使用多线程注意存取值问题。<br>1、事务：事务操作过程中出错是否能回滚？如果无法实现事务，是否需要做job补偿？<br>(如：事务没更新完数据库，就异步获取数据库的数据，结果获取的还是旧的数据)。<br>2、兼容，旧代码变更，是否影响到老接口的逻辑，是否应该做兼容。<br>3、单元测试，最好能覆盖每个条件流转，方法封装是否合理, 可读性强（如时间格式<br>转换，组装请求数据等）除非是P1,P2 hotfix上线，一般情况下，都要求提交的代码<br>有单元测试。<br>4、注释；复杂难以让人理解的方法要写注释，内容包括业务背景，目的，参数的含义<br>5、信息同步，排查很多问题不是bug, 而是业务或者测试没有信息同步。写完代码最<br>好针对单元测试每种情况跟测试、PO沟通一下。如：出现某种异常是否影响到下游继<br>续执行。个人方法：我理解的讲一遍给对方听，然后让对方复述，然后根据复述提出<br>一些问题，确保思路保持一致。<br>6、时区问题，多机房部署可能有时区问题。<br>7、切分支问题，测试测一半了发现分支没切，耗测试时间，切分支之前在群里喊一声。<br>8、是否考虑性能，如：for循环调接口，建议改成批量调。需要高性能的接口要打上请<br>求耗时时间。<br>9、纯技术：mysql死锁异常，两个事务互相要锁；kafka消费线程挂起，kafka消息堆积；<br>发消息是否有确认回执；sql注入，mybatis 的$慎用，建议用#。<br>10、异常处理，特别注意是否可能出现空指针，如果有则需要及时判空。<br>11、粗心、低级别错误。比如设值问题：在写代码的时候，写的很快，或者有点犯困，<br>ide工具有自动补全功能，一不小心把setAAB写成setAAA了，导致一些值设置错误。<br>12、catch块，调第三方或者可能出异常的地方（黑盒）没加catch块，调不通或者向<br>上抛异常影响代码继续向下执行。<br>13、添加关键日志，排查问题找不到日志，排查困难。<br>14、条件覆盖；写代码时一些条件流转的细节场景没有沟通到位，直接忽略导致因为<br>忽略出现了问题，需考虑到每种else的场景。<br>15、业务功能细节；需求了解，开发务必读通需求文档，分析到影响的每个地方，<br>对于复杂流程最好能加以详细文档梳理。<br>16、魔法值太多，难以调整，静态变量要大写，统一存放.可能多次出现的常量值统<br>一用ENUM表示。后期如果有需求调整常量值，而这个常量值多个地方出现。调整代码<br>范围大，对后面维护人员不友好。<br>17，如果是复杂功能开发，则需补充详细设计文档负责的模块、以及考虑代码执行顺序。<br>18，预估频繁修改的配置，比如job的执行时间，放到leconf配置中心里。<br>19、返回值一定要定错误码和错误信息，并同步到上游，提高后期排查问题的效率。<br>20，对于管理系统，字段是必填项还是可选项。</p><h4 id="四、解决方案分析"><a href="#四、解决方案分析" class="headerlink" title="四、解决方案分析"></a>四、解决方案分析</h4><p>1、</p><h4 id="五、指标评估"><a href="#五、指标评估" class="headerlink" title="五、指标评估"></a>五、指标评估</h4><p>1、</p><h4 id="六、问题障碍与资源"><a href="#六、问题障碍与资源" class="headerlink" title="六、问题障碍与资源"></a>六、问题障碍与资源</h4><p>1、 后期需要公司XX部门的配合，让工具来辅助code review，将需求提给XX<br>2、具体code review落地执行困难重重，目前没有比较好的指标去评估，全靠自觉。</p><h4 id="七、后期改进"><a href="#七、后期改进" class="headerlink" title="七、后期改进"></a>七、后期改进</h4><p>1、引入工具来做第一步静态代码自动化扫描<br>2、不断完善check list</p><h4 id="八、Q-amp-A"><a href="#八、Q-amp-A" class="headerlink" title="八、Q &amp; A"></a>八、Q &amp; A</h4><p>1）有人认为 Code Review 流程太长，太浪费时间，特别是业务逼，工期紧的时候，今天<br>改的代码，明天就要上，如果等同事 Review，同事还有可能没时间。<br>目前阶段不应该认为，因为工期紧导致没有时间 Code Review 的。而且 Code Review 熟<br>练之后，并不需要花费太长的时间。尽管开始做 Code Review 的时候，你可能因为不熟练，<br>需要有一个 check list 对照着来 Review，比较耗时，但当你熟练之后，Code Review 就像<br>键盘盲打一样，你已经忘记了哪个手指按的是哪个键了，扫一遍代码就能揪出绝大部分问题。<br>2）ROI（投入产出比）不高。<br>对于很多非功能性的，比如代码的可读性，扩展性，后期维护性，组织结构是否合理，性能问<br>题等都是无法考察的。比如，代码复杂混乱，可读性查，代码组织结构难以支撑业务扩展，后<br>期新功能开发还是要补上这些旧债，如梳理，调整结构等等。</p><h4 id="九、参考附录"><a href="#九、参考附录" class="headerlink" title="九、参考附录"></a>九、参考附录</h4><p>google文档：<br><a href="https://google.github.io/eng-practices/review/reviewer/standard.html" target="_blank" rel="noopener">https://google.github.io/eng-practices/review/reviewer/standard.html</a><br>前人经验: <a href="https://tangguangyao.github.io/2015/11/08/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9D%9A%E6%8C%81code%20review/" target="_blank" rel="noopener">https://tangguangyao.github.io/2015/11/08/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9D%9A%E6%8C%81code%20review/</a><br><a href="https://blog.csdn.net/shgh_2004/article/details/78559762" target="_blank" rel="noopener">https://blog.csdn.net/shgh_2004/article/details/78559762</a><br><a href="https://blog.fundebug.com/2019/03/28/is-code-review-necessary/" target="_blank" rel="noopener">https://blog.fundebug.com/2019/03/28/is-code-review-necessary/</a><br><a href="https://www.cnblogs.com/xiao2shiqi/p/13490011.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiao2shiqi/p/13490011.html</a><br>维百：<a href="https://en.wikipedia.org/wiki/Code_review" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Code_review</a><br>StackOverflow：<a href="https://stackoverflow.blog/2019/09/30/how-to-make-good-code-reviews-better/" target="_blank" rel="noopener">https://stackoverflow.blog/2019/09/30/how-to-make-good-code-reviews-better/</a><br>开源贡献的code review：<a href="https://github.com/elastic/elasticsearch/blob/master/CONTRIBUTING.md" target="_blank" rel="noopener">https://github.com/elastic/elasticsearch/blob/master/CONTRIBUTING.md</a></p><h4 id="十、分享人记录"><a href="#十、分享人记录" class="headerlink" title="十、分享人记录"></a>十、分享人记录</h4><p>日期     分享人      分享纪要（url）</p><h4 id="额外"><a href="#额外" class="headerlink" title="额外"></a>额外</h4><p>思考感悟：思考、总结、抽象、实践、思考<br>项目感悟：文档化、工具化</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h4&gt;&lt;p&gt;code review本质是鼓励开发者间更多的沟通，互相学习，营造技术文化氛围。&lt;br&gt;code review按照后面咋们讨论的check清单一项一项的检查, 以此来降低项目&lt;br&gt;出现的一些低级别的错误和没cover 到场景等错误. 定期总结和优化check 清&lt;br&gt;单,  熟悉模块之间的依赖, 后期逐步提高开发效率,  丰富全局考虑问题的思&lt;br&gt;维, 有利于开发之间学习和成长。code review 比较符合从有到优的发展阶段。&lt;br&gt;code review 的目标长期来看，收益是提升团队的项目质量，减少团队陷入反&lt;br&gt;复修复 bug 的困境中，让团队有机会去面对更多的挑战。&lt;br&gt;code review 对个人和团队而言都是成长的机会，要用开放的包容的心态去接&lt;br&gt;受不同的意见，取其精华。&lt;br&gt;
    
    </summary>
    
      <category term="code review" scheme="https://ouzhrm.github.io/categories/code-review/"/>
    
    
      <category term="稳定性" scheme="https://ouzhrm.github.io/tags/%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>系统稳定性建设初探</title>
    <link href="https://ouzhrm.github.io/2020/04/21/%E7%B3%BB%E7%BB%9F%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%BB%BA%E8%AE%BE%E5%88%9D%E6%8E%A2/"/>
    <id>https://ouzhrm.github.io/2020/04/21/系统稳定性建设初探/</id>
    <published>2020-04-21T05:00:58.000Z</published>
    <updated>2021-04-11T03:20:47.844Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是系统稳定性建设？"><a href="#什么是系统稳定性建设？" class="headerlink" title="什么是系统稳定性建设？"></a>什么是系统稳定性建设？</h4><p>系统稳定性建设是对系统进行评估考量、不断优化预防的一个过程。<br>目的是实现系统按照人为的意念及需求，稳定地对外提供服务。<br><a id="more"></a></p><h4 id="为什么要做系统稳定性建设？"><a href="#为什么要做系统稳定性建设？" class="headerlink" title="为什么要做系统稳定性建设？"></a>为什么要做系统稳定性建设？</h4><p>因为对需求分析编码测试到上线，服务百分百能按照人的意念及需求稳定运行是不可能的。<br>它有可能会因内外界因素如预案调研不充分、代码逻辑出错、机器问题cpu过载、内存溢出、<br>磁盘存储超过最大容量、网络带宽阻塞等等因素而发生无法对外提供服务。<br>案例如：<br>20年，中秋十一前一天下午，用户流量冲击和交通阻塞等因素，导致滴滴和嘀嗒服务故障。<br>18年亚马逊会员日用户无法加入购物车，后续统计当天损失达9900万美金<br>15年某天下午支付宝部分地区用户无法支付，原因是被施工队挖断电缆。<br>12年某天12306机房空调系统故障导致无法提供票务售退改签服务。</p><h4 id="谁负责去做系统稳定性建设"><a href="#谁负责去做系统稳定性建设" class="headerlink" title="谁负责去做系统稳定性建设?"></a>谁负责去做系统稳定性建设?</h4><p>需要PO、开发、运维、测试等一起来做系统稳定性建设。因为PO对用户需求理解程度相对而<br>言更了解、开发对代码技术细节相较而言更理解、运维对线上情况如各个时间段服务运行状<br>况及机器cpu、内存等硬件设施的监控更了解、测试对系统的操作流程比其他人更了解。</p><h4 id="什么时候适合做系统稳定性建设-在那块需要做系统稳定性建设？针对整个项目管理流程每个环节分析"><a href="#什么时候适合做系统稳定性建设-在那块需要做系统稳定性建设？针对整个项目管理流程每个环节分析" class="headerlink" title="什么时候适合做系统稳定性建设? 在那块需要做系统稳定性建设？针对整个项目管理流程每个环节分析"></a>什么时候适合做系统稳定性建设? 在那块需要做系统稳定性建设？针对整个项目管理流程每个环节分析</h4><p>从需求的分析，到项目上线后的维护，每一环节每一时刻都应考虑系统的稳定性。</p><h3 id="系统稳定性建设需要怎么做？考虑什么问题？针对大型互联网项目"><a href="#系统稳定性建设需要怎么做？考虑什么问题？针对大型互联网项目" class="headerlink" title="系统稳定性建设需要怎么做？考虑什么问题？针对大型互联网项目"></a>系统稳定性建设需要怎么做？考虑什么问题？针对大型互联网项目</h3><h4 id="1-针对故障事前、事中、事后时候展开"><a href="#1-针对故障事前、事中、事后时候展开" class="headerlink" title="1, 针对故障事前、事中、事后时候展开"></a>1, 针对故障事前、事中、事后时候展开</h4><p>尽管咋们设计的系统在线上运行如果是比较优秀的, 保证一年5个9的时间稳定运行,<br>它还是有5分多钟的时间是故障, 服务是不可用的. 所以在针对发生故障时, 要有一<br>系列的准备和措施, 特别是互联网to C项目, 项目不稳定损失的不是一丁半点, 如亚<br>马逊的购物车无法提供服务一个下午, 事后统计就损失9000多万美金.咋们分故障发<br>生前做好场景方案设计与预案, 事中故障处理流程, 事后及时复盘和总结优化展开.<br>    故障前, 咋们针对不同的场景, 结合业务需求, 去做系统设计和预案. 举例:<br>就好像产品相对下游, 流量大,上架的产品相关数据放到缓存中, 价格数据敏感, 需<br>要有审核记录, 每一次变更价格都要记录变更人, 营销策略原因导致价格需频繁变更,<br>就好像上午的价格可能跟下午的价格不一样,  需要设计地板价, 保证无论如何改价<br>都合理范围. 下单时,库存可能同时操作多个产品的库存, 为了保证redis事务一致性,<br>用到lua脚本来保证要成功全部成功, 要失败全部失败.  此外, 还需开发流程规范,<br>包括需求评审, 技术评审, 代码版本管理, 代码review.人事方面建立救火群，紧急联<br>系方式，确定相关模块的负责人，总协调人，指挥人。还需要做好对抗演练，恶意攻<br>击演习等等。每一次MTP上线都做好部署方案，设计好折衷方案，确保出现问题能及<br>时从容应对。一般部署后的半个小时内，应留意一段时间生产日志告警，系统监控、<br>服务监控。<br>    故障中，按经验一般部署后的半个小时，大功能在部署后的24小时内，流量突增时，<br>可能会出现故障，此时应通知相关人，然后梳理影响范围，及时告知排查进度，按协调<br>人和负责人的指挥有序进行，尽快止损恢复正常，找到RC。<br>    故障后，梳理故障排查时间轴，向上邮件汇报，向下每隔一段时间开会复盘和分享，<br>必要需要落地一些改进措施。</p><h4 id="2-针对电商场景展开"><a href="#2-针对电商场景展开" class="headerlink" title="2, 针对电商场景展开"></a>2, 针对电商场景展开</h4><p>ERP、产品（价格、库存、搜索、营销）、CMS（页面静态化、组件化、缓存化）、<br>账号、购物车、订单、支付、报表、邮件、MIS</p><h4 id="3-从迭代流程，针对需求分析到上线运维每一个环节展开"><a href="#3-从迭代流程，针对需求分析到上线运维每一个环节展开" class="headerlink" title="3, 从迭代流程，针对需求分析到上线运维每一个环节展开"></a>3, 从迭代流程，针对需求分析到上线运维每一个环节展开</h4><p>TODO（需求分析，需求方案评审、技术方案评审、代码开发、code review、部署方案）</p><h4 id="4-从测试流程展开"><a href="#4-从测试流程展开" class="headerlink" title="4, 从测试流程展开"></a>4, 从测试流程展开</h4><p>TODO（功能测试、集成测试、自动化测试等）</p><p>稳定性技术策略包含：设计层面（TODO），测试层面、运维层面（监控，回滚，重试）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是系统稳定性建设？&quot;&gt;&lt;a href=&quot;#什么是系统稳定性建设？&quot; class=&quot;headerlink&quot; title=&quot;什么是系统稳定性建设？&quot;&gt;&lt;/a&gt;什么是系统稳定性建设？&lt;/h4&gt;&lt;p&gt;系统稳定性建设是对系统进行评估考量、不断优化预防的一个过程。&lt;br&gt;目的是实现系统按照人为的意念及需求，稳定地对外提供服务。&lt;br&gt;
    
    </summary>
    
      <category term="系统设计" scheme="https://ouzhrm.github.io/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="稳定性" scheme="https://ouzhrm.github.io/tags/%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>行业研究结构化思维</title>
    <link href="https://ouzhrm.github.io/2020/04/01/%E8%A1%8C%E4%B8%9A%E7%A0%94%E7%A9%B6%E7%BB%93%E6%9E%84%E5%8C%96%E6%80%9D%E7%BB%B4/"/>
    <id>https://ouzhrm.github.io/2020/04/01/行业研究结构化思维/</id>
    <published>2020-03-31T23:10:26.000Z</published>
    <updated>2021-04-11T03:15:15.983Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本的研究框架"><a href="#基本的研究框架" class="headerlink" title="基本的研究框架"></a>基本的研究框架</h4><p>一般常见的研究框架包括以下这些：</p><h4 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h4><p>这个行业的主要产品是什么？<br>产品的主要形态是什么？<br><a id="more"></a><br>满足了用户哪一方面的需求？<br>产品的替代品包括什么？<br>产品的关键技术是哪一项？<br>产品的成本结构如何？</p><h4 id="市场"><a href="#市场" class="headerlink" title="市场"></a>市场</h4><p>公司的市场定位？<br>公司的主要用户？<br>市场空间有多大？<br>近几年的市场增长率有多高？<br>预计未来几年的市场增速如何？<br>市场的主要玩家是谁？</p><h4 id="行业概括"><a href="#行业概括" class="headerlink" title="行业概括"></a>行业概括</h4><h4 id="基本的行业术语"><a href="#基本的行业术语" class="headerlink" title="基本的行业术语"></a>基本的行业术语</h4><p>行业的发展历程和变迁<br>行业的监管情况和主要政策是什么？<br>行业发展的有利因素和不利因素<br>行业发展的瓶颈<br>行业目前所处的周期<br>行业的供应链情况，关键的环节是哪一个？</p><h4 id="用PESTEL模型分析，这个行业如何？（PESTEL模型如下）"><a href="#用PESTEL模型分析，这个行业如何？（PESTEL模型如下）" class="headerlink" title="用PESTEL模型分析，这个行业如何？（PESTEL模型如下）"></a>用PESTEL模型分析，这个行业如何？（PESTEL模型如下）</h4><p>P：政治因素，是否是公有设施行业？是否受到政策和监控的严控？如房地产<br>E：经济因素，哪些经济因素影响了这个行业的发展？如奢侈品<br>S：社会因素，社会风俗和思想开放程度对这个行业有多大的影响？如医美<br>T：技术因素，技术是如何影响这个行业的？如手机<br>E：环境因素，环保政策和环保理念如何影响行业发展？如新能源汽车<br>L：法律因素，某些法律法规的出台对行业的影响，如广告法影响自媒体等。</p><h4 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h4><p>行业的竞争情况如何，是完全竞争？寡头垄断？还是寡头竞争？该行业是否受到反垄断的监控？<br>业内几个主要玩家的盈利模式分别是怎样的？<br>在竞争胜出的关键行业因素是什么？<br>该行业是否受到海外竞争的压力？</p><p>除了收集上面的信息，还可以关注一下近期的特殊事件，特别是政策动向、国运、资本投资趋向。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本的研究框架&quot;&gt;&lt;a href=&quot;#基本的研究框架&quot; class=&quot;headerlink&quot; title=&quot;基本的研究框架&quot;&gt;&lt;/a&gt;基本的研究框架&lt;/h4&gt;&lt;p&gt;一般常见的研究框架包括以下这些：&lt;/p&gt;
&lt;h4 id=&quot;产品&quot;&gt;&lt;a href=&quot;#产品&quot; class=&quot;headerlink&quot; title=&quot;产品&quot;&gt;&lt;/a&gt;产品&lt;/h4&gt;&lt;p&gt;这个行业的主要产品是什么？&lt;br&gt;产品的主要形态是什么？&lt;br&gt;
    
    </summary>
    
      <category term="思维" scheme="https://ouzhrm.github.io/categories/%E6%80%9D%E7%BB%B4/"/>
    
    
      <category term="思考" scheme="https://ouzhrm.github.io/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>java锁相关研究</title>
    <link href="https://ouzhrm.github.io/2020/03/22/java%E9%94%81%E7%9B%B8%E5%85%B3%E7%A0%94%E7%A9%B6/"/>
    <id>https://ouzhrm.github.io/2020/03/22/java锁相关研究/</id>
    <published>2020-03-22T13:45:19.000Z</published>
    <updated>2021-04-11T02:49:37.190Z</updated>
    
    <content type="html"><![CDATA[<h4 id="轻量级锁和重量级锁"><a href="#轻量级锁和重量级锁" class="headerlink" title="轻量级锁和重量级锁"></a>轻量级锁和重量级锁</h4><p>读多写少 =&gt; 用轻量级锁Reentranlock，原子类。其原理是CAS比较并交换<br>自旋递增(unsafe类do while)逻辑。<br>写多读少 =&gt; 用重量级锁synchronized，Lock。而synchronized的实现原<br>理是依赖操作系统的互斥锁实现线程的同步。<br><a id="more"></a></p><h4 id="CAS比较并交换算法的弊端"><a href="#CAS比较并交换算法的弊端" class="headerlink" title="CAS比较并交换算法的弊端"></a>CAS比较并交换算法的弊端</h4><p>1、aba问题用版本号递增解决<br>2、自旋等待耗cpu资源，自旋时间超过cpu状态切换时间不建议用轻量级锁。<br>3、多个共享变量操作用AtomicReference类。</p><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>原子类也是自旋锁，应用场景是自旋时间小于cpu状态切换的时间。</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>同步代码块只有一个线程访问，则不会有加锁解锁操作，原理是Mark Word<br>会记录线程id。如果有其他线程访问，会升级成轻量级锁，如果自旋超过<br>一定次数，并且有第三个线程访问，会升级为重量级锁。锁降级是指当前<br>把持住写锁，再获取到读锁，随后释放(先前拥有的)写锁的过程。</p><h4 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h4><p>公平锁是线程访问同步代码块时按顺序排队获取锁，优点是队列中的线程<br>不会饿死，缺点性能比非公平锁低，因为需要按顺序唤醒阻塞线程，cpu状<br>态需要切换。<br>非公平锁是可能后申请获取锁的线程先获得锁，即在锁刚好可用的时候。<br>优点减少cpu状态切换，提高性能，缺点是队列中的线程可能会饿死。<br>ReentranLock可实现公平锁和非公平锁。<br>公平锁和非公平锁原理是分别是增加队列和判断status是否为0</p><h4 id="可重入锁和非可重入锁"><a href="#可重入锁和非可重入锁" class="headerlink" title="可重入锁和非可重入锁"></a>可重入锁和非可重入锁</h4><p>可重入锁是线程进入两个方法同步代码块里的锁如果是同一个则都能<br>获得锁，ReentrantLock和synchronized都是可重入锁，可重入锁优点<br>是可一定程度避免死锁。非可重入锁和可重入锁相反。<br>实现方式：可重入锁会判断下当前线程是否是获取过锁的线程，然后<br>status加一；释放则减一，如果状态为0则表示释放了锁。非可重入<br>锁判断status的状态（compareAndSwapStatus）来是否可以获得锁，<br>如果可以则status加一。</p><h4 id="独享锁（排它锁）和共享锁"><a href="#独享锁（排它锁）和共享锁" class="headerlink" title="独享锁（排它锁）和共享锁"></a>独享锁（排它锁）和共享锁</h4><p>ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，读锁是<br>共享锁，写锁是独享锁。写写、写读互斥。公平锁和非公平锁都是<br>获取的互斥锁（ReentranLock），所以是独享锁。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>读多写少 =&gt; 用轻量级锁Reentranlock，原子类<br>读少写多 =&gt; 用重量级锁synchronized，Lock<br>自旋时间小于cpu状态切换的时间用自旋锁（CAS即比较并交换算法）<br>按先后顺序获取锁防止先到线程饿死忽略性能用公平锁。谁抢到就是谁的，<br>为了提高性能，忽略线程饿死则用非公平锁。公平锁和非公平锁都可用<br>ReentranLock实现。ReentrantLock和synchronized都是可重入锁。<br>ReadLock和WriteLock，读锁是共享锁，写锁是独享锁。ReentranLock是独享锁。</p><p>Reentranlock、原子类可以是轻量级锁、可重入锁、公平锁或非公平锁、自旋锁、独享锁<br>synchronized、Lock是重量级锁、可重入锁<br>ReadLock是共享锁，WriteLock是独享锁</p><p>强烈推荐在多线程应用程序中使用synchronized，因为实现方便，后续工作由JVM来完成，<br>可靠性高。只有在确定锁机制是当前多线程程序的性能瓶颈时，才考虑使用其他机制，如ReentrantLock等。<br>在高并发量的条件下，synchronized性能会迅速下降几十倍，而ReentrantLock的性能却能依然维持一个水准。<br>ReentrantLock默认为非公平锁。这是因为，非公平锁实际执行的效率要远远超出公平锁。<br>使用ReentrantLock必须在finally控制块中进行解锁操作。<br>读写锁比较适用于读多写少的应用场景</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;轻量级锁和重量级锁&quot;&gt;&lt;a href=&quot;#轻量级锁和重量级锁&quot; class=&quot;headerlink&quot; title=&quot;轻量级锁和重量级锁&quot;&gt;&lt;/a&gt;轻量级锁和重量级锁&lt;/h4&gt;&lt;p&gt;读多写少 =&amp;gt; 用轻量级锁Reentranlock，原子类。其原理是CAS比较并交换&lt;br&gt;自旋递增(unsafe类do while)逻辑。&lt;br&gt;写多读少 =&amp;gt; 用重量级锁synchronized，Lock。而synchronized的实现原&lt;br&gt;理是依赖操作系统的互斥锁实现线程的同步。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://ouzhrm.github.io/categories/java/"/>
    
    
      <category term="锁" scheme="https://ouzhrm.github.io/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>DDD思想认知与实践</title>
    <link href="https://ouzhrm.github.io/2020/03/17/DDD%E6%80%9D%E6%83%B3%E8%AE%A4%E7%9F%A5%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <id>https://ouzhrm.github.io/2020/03/17/DDD思想认知与实践/</id>
    <published>2020-03-17T01:27:41.000Z</published>
    <updated>2020-03-17T01:53:38.778Z</updated>
    
    <content type="html"><![CDATA[<p>本文以问题为导向，以某一个业务甚至多个业务为例，一步步解析DDD<br>（即领域驱动设计，后文均简写成DDD）。业界有句话说，架构脱离业<br>务就是耍流氓，同样，思想如果脱离实践，只谈理论，就是空谈。<br><a id="more"></a></p><h4 id="我最近为什么要研究DDD？"><a href="#我最近为什么要研究DDD？" class="headerlink" title="我最近为什么要研究DDD？"></a>我最近为什么要研究DDD？</h4><p>最近公司要将一个项目重构，这个项目经过很多人的手，代码接近800M，<br>这个项目在全球有多个站点，这给我们带来了不少的困难，首先，相关<br>文档如数据库关系文档、概要和详细设计等文档缺失，其次，业务梳理<br>困难，可能一些细节会忽视，再框架层面是用SAP比较笨重的hybris框架，<br>怎么扩展，以及很好的使用这个框架，对应的文档也很少，这给我们开发<br>人员在快速响应需求，项目出现紧急bug上，在扩展和维护上带来很大的<br>挑战，以及遇到一些源码级别的坑会很影响效率，要找维护这个框架的公<br>司的人来解决，在当今，拥抱开源是趋势，最重要的是时间成本上，这个<br>项目的代码比较多，项目启动比较费时，重启的时间往往比更改很小的内<br>容所耗的时间要长的多得多，从而导致增加人手来维护这个平台，进而人<br>力成本上升。<br>对此，我们曾经提出以下几种解决策略：<br>1、尽可能的停止在就平台上面继续开发新需求，能迁移的就单独迁移出来<br>形成一个新的服务。<br>2、如果不能迁移出来，迁移困难，则将其封装成一个接口，形成所谓的胶水<br>代码，供新旧服务使用。<br>3、先迁移简单的，以及先迁移更有价值的，或者频繁维护的。<br>4、在准备迁移之前，先前后端分离。以及建立api网关及DNS。<br>5、采取灰度发布二八形式，20%的流量打到新服务，80%的流量打到旧服务，<br>如果新服务出现问题，及时回滚或者指向回旧服务。<br>6、数据迁移方面，分静态迁移和动态迁移，静态迁移就是直接导入导出的形<br>式。而动态迁移就是服务不停机，<br>关系型数据库直接通过搭建主备数据库双写的形式，缓存必要时可以丢失，<br>文件服务器直接共用。一般是在用户少使用的时候进行。<br>最后，在权衡用户，开发，测试，运营等成本得失后，如果重写的成本相对低，<br>就立马行动！如果我们没法控制住它，不如试法去打破它。重新根据旧项目<br>的功能去梳理，构建一个新的平台。业务复杂，功能未来多变，要求快速迭代，<br>并带有不确定性需求的大型项目这么一个场景，是比较适合用DDD去设计的。<br>这也是我研究DDD的原因的之一。</p><h4 id="提出DDD是在什么背景下？"><a href="#提出DDD是在什么背景下？" class="headerlink" title="提出DDD是在什么背景下？"></a>提出DDD是在什么背景下？</h4><p>是一个老外，具体什么名字咋们不讲究，说他们从一个小的创业公司逐渐发展<br>壮大，结果技术无法跟上业务的脚步，代码结构混乱冗杂并且庞大，业务复杂，<br>严重影响开发维护效率，一来怕担心影响到用户的体验，二是公司人力少，不<br>敢多招人，目前人均工作量饱和，业务需求和维护量也多，只关注业务的发展，<br>对没有产生效益的工作不是特别在乎，所以这给重构的推动带来重重困难。</p><h4 id="什么是DDD？"><a href="#什么是DDD？" class="headerlink" title="什么是DDD？"></a>什么是DDD？</h4><p>domain driver design , 简称DDD, 翻译过来叫领域驱动设计，也就是业务专家<br>跟程序员打交道时，以领域为界建模的方式，降低沟通成本，达到业务即设计，<br>设计即代码，代码即文档的一种暂且的相对来说的理想境界。</p><p>领域：即业务是属于哪块，电商领域，保险领域，零售领域，又可细化分为子领<br>域。如电商下（订单交易领域、库存领域、会员领域、物流领域….）<br>领域专家：一般指熟悉对应领域的产品经理项目经理</p><h4 id="有必要一定要推行DDD这种开发方式吗？为什么推荐发展快速且业务复杂的互联网企业要用DDD作为主导设计？使用DDD有什么好处与坏处？"><a href="#有必要一定要推行DDD这种开发方式吗？为什么推荐发展快速且业务复杂的互联网企业要用DDD作为主导设计？使用DDD有什么好处与坏处？" class="headerlink" title="有必要一定要推行DDD这种开发方式吗？为什么推荐发展快速且业务复杂的互联网企业要用DDD作为主导设计？使用DDD有什么好处与坏处？"></a>有必要一定要推行DDD这种开发方式吗？为什么推荐发展快速且业务复杂的互联网企业要用DDD作为主导设计？使用DDD有什么好处与坏处？</h4><p>不一定，如果你的项目未来业务不是特别复杂，相对于传统甚至走瀑布流的开发<br>管理方式，变更需求不强烈，不要求快速迭代，用户增长不高相对稳定的情况下，<br>不建议采用DDD这种建模方式或者说设计思想。如果是一家初创企业，未来用户会<br>快速增长，业务会越来越复杂，未来希望能降低重构所耗的时间成本及人力成本，<br>未来需求不确定，变更频繁，不知道未来是否会演变成微服务，如果会演变，微服<br>务拆多细，怎么拆的问题，我建议推行DDD这种开发方式，当然，还有我开头所说的，<br>业务复杂，功能点多且细，无法跟上开发文档的修改速度时，或者项目比较重或者比<br>较臃肿时，我建议重构后推行DDD这种开发方式。</p><p>领域驱动设计主要优势：<br>1、业务导向。<br>2、业务逻辑内聚，应用边界清晰。<br>3、建立领域模型优先。<br>4、分析、设计、代码和数据有机结合。<br>5、代码即设计。<br>6、扩展性好。<br>数据驱动设计主要特点：<br>1、技术导向。<br>2、数据库优先。<br>3、代码不能反映业务和设计。<br>4、业务逻辑分散。<br>5、扩展性不好。</p><p>领域驱动设计目的是让业务架构和系统架构形成绑定关系，当我们去响应业务变化调<br>整业务架构时，系统架构的改变也会随之发生。在领域驱动设计中业务架构的梳理和<br>系统架构的梳理是同步进行的，其结果是设计出的业务上下文和系统模块结构是绑定的。</p><h4 id="什么时候要重构？"><a href="#什么时候要重构？" class="headerlink" title="什么时候要重构？"></a>什么时候要重构？</h4><p>什么时候都适合重构，哪怕一个小小的重构，但现实中，往往是难以维护甚至无法维护<br>时才去重构，或者是影响开发效率，扩展功能耗时太长其原因代码太笨重太复杂影响，<br>开发效率严重影响业务需求时，即时间成本太高时才去重构。</p><h4 id="怎么运用领域驱动设计思想去做业务设计和开发？举例说明"><a href="#怎么运用领域驱动设计思想去做业务设计和开发？举例说明" class="headerlink" title="怎么运用领域驱动设计思想去做业务设计和开发？举例说明"></a>怎么运用领域驱动设计思想去做业务设计和开发？举例说明</h4><p>DDD 分层架构包括：展现层、应用层、领域层和基础层。</p><p>展现层：可以理解成前端。</p><p>应用层：可以理解成传统三层架构中的控制层，应用层还可进行安全认证、权限校<br>验、分布式和持久化事务控制等。</p><p>领域层：它实现了全部业务逻辑并且通过各种校验手段保证业务正确性,通俗的说<br>就是按业务建模，校验函数也写在这一层。它包含业务所涉及的领域对象（实体、<br>值对象）、领域对象之间的关系。它负责表达业务概念、业务状态以及业务规则。</p><p>基础设施层（infrastructure）：封装基础资源服务，为应用层和领域层提供基础<br>资源服务（如数据库、缓存、api网关等基础资源）</p><p>接口返回值在Adapter层集合，类命名以Adapter结尾, 如CargoTrackingViewAdapter。<br>命令如更新，删除接口，入参写在web层，类命名以Command结尾，如UpdateXxxCommand。<br>interfaces层下有多个命名的业务动作，如取快递，送快递等，还有dto层（DTO相关类）、<br>assembler层（DTO 与领域对象domain之间的相互转换）。这些动作层下面有分逻辑处理<br>facade层和web层，web层下面有XxxController,XxxCommand, XxxAdapter，<br>此外还有工具层utils, 比如时间格式校验，时间转换等工具类。<br>还有配置层Config， 放相关的配置信息。</p><p>业务开展步骤：<br>1、场景分析<br>场景分析是一个发散的过程。根据不同角色的可能经历的场景分析，<br>尽可能全面的梳理从前端操作到后端业务逻辑发生的所有操作、命令、领域事件以及外<br>部依赖关系等信息。<br>2、领域建模<br>领域建模是一个收敛的过程。这个收敛过程分三步：<br>第一步根据场景分析中的操作集合定义领域实体；<br>第二步根据领域实体业务关联性，定义聚合；<br>第三步根据业务及边界等因素，定义限界上下文。<br>3、微服务设计和拆分<br>理论上一个限界上下文可以设计为一个微服务，但还需要综合考虑多种外部因素，<br>如：领域单一性、性能差异、版本发布频率、团队沟通效率和技术异构等要素。<br>4、代码结构模型设计<br>即设计类及分层结构，并写上一部分代码如领域实体，领域之间的关系，接口名称及出入参等。<br>5、详细设计<br>详细设计主要结合具体的业务功能来开展，主要工作包括：系统界面、数据库表以及字<br>段、服务参数规约及功能等。<br>6、代码开发；软件开发人员只需要按照设计文档和功能要求，找到业务功能对应的代<br>码位置，完成代码开发和服务编排即可。<br>7、测试和发布<br>完成代码开发后，由开发人员编写单元测试用例，基于挡板模拟依赖对象完成跨服务的测试，<br>测试人员编写测试用例，运维人员编写自动化测试脚本。</p><p>具体代码和详情介绍请看下面，这是我看到相对比较好的文章。<br>理论篇：<a href="https://www.infoq.cn/article/7QgXyp4Jh3-5Pk6LydWw" target="_blank" rel="noopener">https://www.infoq.cn/article/7QgXyp4Jh3-5Pk6LydWw</a><br>操作步骤篇：<a href="https://www.infoq.cn/article/s_LFUlU6ZQODd030RbH9" target="_blank" rel="noopener">https://www.infoq.cn/article/s_LFUlU6ZQODd030RbH9</a><br>代码篇：<a href="https://github.com/citerus/dddsample-core" target="_blank" rel="noopener">https://github.com/citerus/dddsample-core</a></p><h4 id="转DDD需要多大的成本及资源投入？效率怎么样？有那些指标体现？有没有备选方案或折衷？"><a href="#转DDD需要多大的成本及资源投入？效率怎么样？有那些指标体现？有没有备选方案或折衷？" class="headerlink" title="转DDD需要多大的成本及资源投入？效率怎么样？有那些指标体现？有没有备选方案或折衷？"></a>转DDD需要多大的成本及资源投入？效率怎么样？有那些指标体现？有没有备选方案或折衷？</h4><p>人力成本：开发、测试、运营、运维等。</p><p>时间成本：如果未来能节省时间成本，提高开发与维护效率，重构是不错的方案。</p><p>重构前需提前和业务沟通！</p><p>技术选型最好要成熟，一定要经历过生产级别验证过的。能用公司的基础服务就用基<br>础服务，能借鉴别的团队就借鉴别的团队！</p><p>重构量化指标比如用户操作的响应时间缩短到 100 毫秒、单元测试的覆盖率达到 80%、<br>发现问题时长降低到 30 分钟以内等等，能让系统更加完善的都可以提出明确指标。</p><p>性能指标：响应时间、超时率、错误率、资源占用率、运行周期、支持最大并发数。</p><p>资源使用率：CPU占用率、内存使用率、磁盘I/O、网络I/O。</p><p>错误率：返回的状态码如404，500等所占请求总数的比率。</p><p>衡量架构复杂度的几个指标：<br>depth（深度，从 nginx 开始到最深路径上的微服务个数），<br>fan-in（入度，一个服务被几个服务调用），<br>fan-out（出度，一个微服务调用了几个微服务）。<br>你应该尽力降低架构深度和出度，提升服务的入度。</p><p>良好的单元测试不但是重构的先决条件和好帮手，而且能帮我们整理设计的思路，从而<br>更好的写出优秀的代码。因为在写单元测试的时候，我们会假设自己是一个“代码破坏<br>者”，思考如何破坏代码的运行、寻找那些可能出错的边界条件。单元测试的编写和运<br>行可以在写完代码后进行，也可以在写代码之前动手。先写单元测试再写代码的技巧<br>叫作测试驱动开发（TDD），也是敏捷开发的基石之一。</p><h4 id="数据平滑迁移方案"><a href="#数据平滑迁移方案" class="headerlink" title="数据平滑迁移方案"></a>数据平滑迁移方案</h4><p>1、分可停机和不可停机，可停机直接导入导出，静态迁移，不可停机找用户少使用<br>时，数据库双写、定时任务load相对不太实时的数据、读取操作数据库日志变更的形式。<br>2、分数据类型，关系型数据库直接导入导出，或者双写的形式。缓存数据大部分是<br>经常访问或者处理过的数据，必要时可丢失。文件数据则共用的形式。<br>3、分业务需求，变更表结构，如拆表；变更存储介质，如mysql的数据迁移到mongodb<br>中；两者都可以开发个小工具处理。而分库个数追加，则只需更改库路由配置。<br>4、迁移完后还需进行缓存预热或者开发一个小工具进行新旧数据比对，保证数据一致。</p><h4 id="服务迁移方案"><a href="#服务迁移方案" class="headerlink" title="服务迁移方案"></a>服务迁移方案</h4><p>1、灰度发布，二八流量原则，20%的流量打到新服务，80%的流量打到新服务，如果出<br>现问题，及时切回旧服务。<br>2、全量发布，在不影响旧业务的情况下，如抽取封装成一个子服务，测试在预发布环<br>境也没问题，可全量发布，这种情况较少。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文以问题为导向，以某一个业务甚至多个业务为例，一步步解析DDD&lt;br&gt;（即领域驱动设计，后文均简写成DDD）。业界有句话说，架构脱离业&lt;br&gt;务就是耍流氓，同样，思想如果脱离实践，只谈理论，就是空谈。&lt;br&gt;
    
    </summary>
    
      <category term="重构" scheme="https://ouzhrm.github.io/categories/%E9%87%8D%E6%9E%84/"/>
    
    
      <category term="DDD" scheme="https://ouzhrm.github.io/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>经验之谈-某个使用spring规范</title>
    <link href="https://ouzhrm.github.io/2019/11/24/%E7%BB%8F%E9%AA%8C%E4%B9%8B%E8%B0%88-%E6%9F%90%E4%B8%AA%E4%BD%BF%E7%94%A8spring%E8%A7%84%E8%8C%83/"/>
    <id>https://ouzhrm.github.io/2019/11/24/经验之谈-某个使用spring规范/</id>
    <published>2019-11-24T05:27:41.000Z</published>
    <updated>2019-11-14T05:44:57.454Z</updated>
    
    <content type="html"><![CDATA[<p>今天看下别的模块，虽然不是我写的代码，但是我还是看一下，以便全面了解。<br>如果认为写的不对的地方，我会根据git的提交记录找到对应的人提出自己的<br>建议。今天，我就看到一个spring关于共享变量的问题。在我们组<br>中，有个人特别喜欢用共享变量，其实这种用法是不对的。我们知道，spring管理<br>bean的方式是单例的,对象是存在堆内存中的。废话不多说，直接上代码！<br><a id="more"></a><br>比如说，service层某个实现类有个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">boolean fullLoad = true;</span><br><span class="line">public void testFullload() throws InterruptedException &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+&quot;: change=&quot;+fullLoad);</span><br><span class="line">    fullLoad = !fullLoad;</span><br><span class="line">    if(fullLoad)&#123;</span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        Thread.sleep(5000);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+&quot;: get=&quot;+fullLoad);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后在controller层中调这个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value = &#123; &quot;/ping&quot; &#125;, method = RequestMethod.GET)</span><br><span class="line">public ResponseEntity&lt;String&gt; ping() throws InterruptedException &#123;</span><br><span class="line">   xxxService.testFullload();</span><br><span class="line">   return new ResponseEntity&lt;&gt;(&quot;Success&quot;, HttpStatus.OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>请求几次后得到的结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http-nio-9103-exec-8: change=true</span><br><span class="line">http-nio-9103-exec-8: get=false</span><br><span class="line">http-nio-9103-exec-1: change=false</span><br><span class="line">http-nio-9103-exec-1: get=true</span><br><span class="line">http-nio-9103-exec-5: change=true</span><br><span class="line">http-nio-9103-exec-5: get=false</span><br><span class="line">http-nio-9103-exec-2: change=false</span><br><span class="line">http-nio-9103-exec-2: get=true</span><br></pre></td></tr></table></figure></p><p>总结：这说明一个多线程的问题，spring 管理bean的方式<br>是单例的，对象不是放在线程内部独立的内存中的，而是<br>堆中共享的。使用共享变量特别需要注意，建议作为内部变量<br>放在方法中传递，而不是作为共享变量的形式传递，因为共享<br>变量在spring中会把值存储在堆内存中。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天看下别的模块，虽然不是我写的代码，但是我还是看一下，以便全面了解。&lt;br&gt;如果认为写的不对的地方，我会根据git的提交记录找到对应的人提出自己的&lt;br&gt;建议。今天，我就看到一个spring关于共享变量的问题。在我们组&lt;br&gt;中，有个人特别喜欢用共享变量，其实这种用法是不对的。我们知道，spring管理&lt;br&gt;bean的方式是单例的,对象是存在堆内存中的。废话不多说，直接上代码！&lt;br&gt;
    
    </summary>
    
      <category term="经验之谈" scheme="https://ouzhrm.github.io/categories/%E7%BB%8F%E9%AA%8C%E4%B9%8B%E8%B0%88/"/>
    
    
      <category term="spring" scheme="https://ouzhrm.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>学习redis，读这一篇就够了？</title>
    <link href="https://ouzhrm.github.io/2019/09/23/%E5%AD%A6%E4%B9%A0redis%EF%BC%8C%E8%AF%BB%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%9F/"/>
    <id>https://ouzhrm.github.io/2019/09/23/学习redis，读这一篇就够了？/</id>
    <published>2019-09-23T10:03:41.000Z</published>
    <updated>2019-09-23T10:38:18.514Z</updated>
    
    <content type="html"><![CDATA[<p>耗时1个多月空闲出来的时间学习整理的redis相关知识。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br></pre></td><td class="code"><pre><span class="line">1、什么时候会用到缓存？为什么要用这门技术？</span><br><span class="line"></span><br><span class="line">单机mysql数据库在TPS超过1500的时候可能会宕机或者说无法提供服务，</span><br><span class="line">redis缓存查询TPS在7到10w之间，所以要用redis缓存来保护&quot;脆弱&quot;的mysql单机数据库.</span><br><span class="line"></span><br><span class="line">维护性</span><br><span class="line">     开源，核心代码大概32000多行，社区活跃，后续可维护性较好</span><br><span class="line">扩展性</span><br><span class="line">     客户端支持多语言，比如：php、java、golang</span><br><span class="line">     可以搭集群（哨兵，分片），实现高可用</span><br><span class="line">稳定性、成熟性</span><br><span class="line">     支持持久化（RDB / AOF）</span><br><span class="line">    大多公司在用（阿里巴巴，微博，腾讯等）</span><br><span class="line">性能</span><br><span class="line">    每秒并发量能支持高达10万，速度快，用C语言实现，单线程模型避免上下文</span><br><span class="line">    资源切换及内部竞争条件（持久化会重新开条线程去处理）</span><br><span class="line">    支持协议格式执行命令，支持pipeline(管道)，提高执行效率</span><br><span class="line">丰富性</span><br><span class="line">    支持五种数据类型（string、list、set、zset、hash），而外还有bitmaps、</span><br><span class="line">hyperLogLog、GEO。</span><br><span class="line"></span><br><span class="line">注意：但数据量大访问频率低、联表多、要求有事务属性，不适合用redis。</span><br><span class="line"></span><br><span class="line">2、这门技术相对于其他的同类技术，为什么选用这门技术？两者或者多者的比较？有哪些优缺点？</span><br><span class="line">    举例：</span><br><span class="line">如自身的相关数值：数据量、TPS、响应时间。</span><br><span class="line">缓存相关的有：本地缓存、分布式缓存（redis、mamcached）、客户端缓存、</span><br><span class="line">数据库缓存、CDN缓存。</span><br><span class="line">选型指标：容量、并发量、响应时间、使用成本、扩展性、容灾。</span><br><span class="line"></span><br><span class="line">本地缓存不建议用在分布式服务中，一来是占其他服务内存，也带有不可控性，</span><br><span class="line">二是导致资源浪费。（相同资源备份在多个服务中）。</span><br><span class="line"></span><br><span class="line">客户端缓存可能会给用户带来不好的体验。</span><br><span class="line"></span><br><span class="line">数据库缓存带不可操作性（一些计算的结果，或者是频繁访问的数据）。</span><br><span class="line"></span><br><span class="line">CDN缓存。</span><br><span class="line"></span><br><span class="line">Redis之与Memcached的比较</span><br><span class="line">一、性能</span><br><span class="line">  由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储</span><br><span class="line">  小数据时比Memcached性能更高。而在100k以上的数据时，Memcached性能要高于Redis，</span><br><span class="line">  虽然Redis最近也在存储大数据的性能上进行优化，但是比起Memcached，还是稍有逊色。</span><br><span class="line">二、内存使用效率</span><br><span class="line">  使用简单的key-value存储的话，Memcached的内存利用率更高，而如果Redis采用hash结</span><br><span class="line">  构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcached。</span><br><span class="line">三、数据备份恢复</span><br><span class="line">  memcached挂掉后，数据不可恢复；redis数据丢失后可以通过aof恢复，Redis支持数据</span><br><span class="line">的备份，即master-slave主从模式的数据备份。redis支持持久化。</span><br><span class="line">四、内存管理机制</span><br><span class="line">对于像Redis和Memcached这种基于内存的数据库系统来说，内存管理的效率高低是影</span><br><span class="line">响系统性能的关键因素。Memcached的内存管理制效率高，而且不会造成内存碎片，但</span><br><span class="line">是它最大的缺点就是会导致空间浪费。因为每个Chunk都分配了特定长度的内存空间，</span><br><span class="line">所以变长数据无法充分利用这些空间。比如将100个字节的数据缓存到128个字节的Chunk</span><br><span class="line">中，剩余的28个字节就浪费掉了</span><br><span class="line">Redis采用的是包装的malloc/free,会造成内存碎片。</span><br><span class="line">五、集群、分布式存储</span><br><span class="line">Memcached不支持分布式，只能在客户端通过像一致性哈希(内置)这样的分布式算法来</span><br><span class="line">实现Memcached的分布式存储。Redis Cluster是一个实现了分布式且允许单点故障的</span><br><span class="line">Redis高级版本，它没有中心节点，具有线性可伸缩的功能。</span><br><span class="line">   （优秀博客：https://mp.weixin.qq.com/s/4J3oM1j5hcLq4w4TdSEMPg）</span><br><span class="line"></span><br><span class="line">使用场景上比较</span><br><span class="line">mamcached多核，qps能上到几十万级别，但数据结构单一，仅仅支持key/value简单</span><br><span class="line">的数据类型，无法持久化，水平扩展需要编写分布策略，无法进行数据水平复制。</span><br><span class="line">redis单核，qps能上十万，数据结构丰富，支持持久化（aof文件），支持集群和哨</span><br><span class="line">兵机制（master/slave），支持水平数据复制。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3、这门技术可以运用在什么场景上？</span><br><span class="line"></span><br><span class="line">放热数据，提高查询效率</span><br><span class="line">分布式锁</span><br><span class="line">统计（如2亿用户，统计某个用户是否为活跃用户,用到bitmaps）、排行榜(zset)</span><br><span class="line">分布式限流（根据ip地址）</span><br><span class="line">推荐（共同好友或歌曲推荐求交集，此外，还有差集和并集）、点赞、收藏数（set命令）</span><br><span class="line">消息队列（一般不会用）</span><br><span class="line">session统一处理</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4、如何运用这门技术？（常用命令、集群、分片、哨兵），怎么去优化？？这门技术是怎么实现的？</span><br><span class="line">redis用法及介绍：https://juejin.im/post/5a912b3f5188257a5c608729</span><br><span class="line">redis集群哨兵搭建（亲自搭建过，过程会有些bug ,自行谷歌修复）：</span><br><span class="line">https://blog.csdn.net/shouhuzhezhishen/article/details/69221517</span><br><span class="line"></span><br><span class="line">redis分片（将数据拆分几部分，按照一定的路由规则存到对应的redis节点中）</span><br><span class="line">客户端分片：在客户端进行一致性哈希，选择路由到那一台redis机器上访问。</span><br><span class="line">代理服务器分片：Twemproxy 是 Twitter 开发的代理服务器。</span><br><span class="line">服务端分片：将所有的存储空间分成16384个slot,数据按照一定的路由规则存到这些</span><br><span class="line">对应的slot中，可以理解成在master-slave上加一层，如果动态扩缩容，可以采</span><br><span class="line">用预分片（32/64个节点，不用的节点没数据占内存空间1M左右）。客户端在查找</span><br><span class="line">key的所在节点时也是通过CRC16校验后对16384取模。</span><br><span class="line"></span><br><span class="line">redis优化：</span><br><span class="line">一、尽量别用持久化（TODO：集群需要开启持久化，就是那三个save配置）。</span><br><span class="line">二、不要设置过期时间，耗cpu和内存性能。</span><br><span class="line">    在 redis.conf 中有一行配置： maxmemory-policy volatile-lru</span><br><span class="line">    当内存不足时，自动移除最近最少使用的元素（默认策略）</span><br><span class="line">三、keys，hgetall，smembers等长时间命令一般不再生产环境使用，</span><br><span class="line">因为是单线程，容易阻塞</span><br><span class="line">四、获取多个value, 能用批量执行命令就用批量执行命令（如mget），能减少多次访问</span><br><span class="line">网络和执行命令的时间，或者用pipeline.</span><br><span class="line">五、设置慢查询的值，定期查询慢查询日志</span><br><span class="line">config set slowlog-max-len 1000  //1000微秒=1ms</span><br><span class="line">config set slowlog-log-slower-than 1000   </span><br><span class="line">六、默认会进行内存压缩，用cpu换时间的方式。（集合中）如果某个值超过了配置文件中</span><br><span class="line">设置的最大值，redis将自动把它（集合）转换为正常的散列表。</span><br><span class="line">更改阈值的方法：</span><br><span class="line">hash-max-zipmap-entries 64 (2.6以上使用hash-max-ziplist-entries)</span><br><span class="line">hash-max-zipmap-value 512  (2.6以上使用hash-max-ziplist-value)</span><br><span class="line">list-max-ziplist-entries 512</span><br><span class="line">list-max-ziplist-value 64</span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line">set-max-intset-entries 512</span><br><span class="line"></span><br><span class="line">七、尽可能使用散列表（hashes），存储对象能用hashes就不用string,这样能能省接近90%内存。</span><br><span class="line"></span><br><span class="line">TODO: redis内部具体实现原理。</span><br><span class="line"> Redis设计与实现（作者：黄建宏）</span><br><span class="line">redis底层原理：https://blog.csdn.net/wcf373722432/article/details/78678504</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line"> * Redis 对象 </span><br><span class="line"> */  </span><br><span class="line">typedef struct redisObject &#123;  </span><br><span class="line">  </span><br><span class="line">    // 类型（五种，string、list、hash、set、zset）  </span><br><span class="line">    unsigned type:4;          </span><br><span class="line">  </span><br><span class="line">    // 不使用(对齐位)  </span><br><span class="line">    unsigned notused:2;  </span><br><span class="line">  </span><br><span class="line">    // 编码方式 (八种，long类型整数、embstr SDS、SDS、字典（映射）、压缩列表、</span><br><span class="line">双端链表、跳跃表、整数集合) </span><br><span class="line">    unsigned encoding:4;  </span><br><span class="line">  </span><br><span class="line">    // LRU 时间（相对于 server.lruclock）  </span><br><span class="line">    unsigned lru:22;  </span><br><span class="line">  </span><br><span class="line">    // 引用计数  </span><br><span class="line">    int refcount;  </span><br><span class="line">  </span><br><span class="line">    // 指向对象的值  </span><br><span class="line">    void *ptr;  </span><br><span class="line">  </span><br><span class="line">&#125; robj;  </span><br><span class="line"></span><br><span class="line">字符串对象的编码可以是int、raw或者embstr。</span><br><span class="line"></span><br><span class="line">字符串对象的长度小于39字节，就用embstr对象。否则用传统的raw对象。</span><br><span class="line">redis并未提供任何修改embstr的方式，即embstr是只读的形式。对embstr的</span><br><span class="line">修改实际上是先转换为raw再进行修改。</span><br><span class="line">embstr和raw的区别在于embstr更能充分的利用空间，不会预留空间，而raw是</span><br><span class="line">预留空间的。</span><br><span class="line"></span><br><span class="line">列表对象的编码是ziplist或linkedlist</span><br><span class="line"></span><br><span class="line">ziplist是压缩列表，空间连续，能节省空间，对象元素不大时用ziplist，</span><br><span class="line">但缺点也明显，插入复杂度是O(n)，linkedlist是双端链表。</span><br><span class="line"></span><br><span class="line">哈希对象的底层实现可以是ziplist或者hashtable。</span><br><span class="line"></span><br><span class="line">ziplist中的哈希对象是按照key1,value1,key2,value2这样的顺序存放来存储的</span><br><span class="line">hashtable的是由dict这个字典结构来实现的，dict包含两个指针，指向两个哈希表，</span><br><span class="line">分别是dicht[0] 是用于真正存放数据，dicht[1]一般在哈希表元素过多进行</span><br><span class="line">rehash的时候用于中转数据。</span><br><span class="line"></span><br><span class="line">集合对象的编码可以是intset或者hashtable(保证快速新增、删除、查找)。</span><br><span class="line"></span><br><span class="line">有序集合的编码可能两种，一种是ziplist，另一种是skiplist与dict（字典，保证score顺序）的结合。</span><br><span class="line"></span><br><span class="line">ziplist作为集合和作为哈希对象是一样的，member和score顺序存放。按照score</span><br><span class="line">从小到大顺序排列。</span><br><span class="line">skiplist是一种跳跃表，它实现了有序集合中的快速查找。</span><br><span class="line">想如果单一用dict(hashtable)，那可以快速查找（主要）、添加和</span><br><span class="line">删除元素，但没法保持集合的有序性。如果单一用skiplist，有序性</span><br><span class="line">可以得到保障，但查找的速度太慢O（logN）。</span><br><span class="line"></span><br><span class="line">redis各个配置参数详解：</span><br><span class="line">https://blog.csdn.net/ljl890705/article/details/51540427</span><br><span class="line">https://www.cnblogs.com/chenmh/p/5121849.html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">redis的持久化</span><br><span class="line"></span><br><span class="line">aof文件不会丢数据，rdb文件会丢数据。</span><br><span class="line">aof文件大，恢复慢，rdb文件快。</span><br><span class="line"></span><br><span class="line">redis架构</span><br><span class="line">单线程模型避免上下文，纯内存操作响应时间大概是100纳秒，采用epoll多路复用的非阻塞io,在连接、读写、关闭上尽可能的节省时间。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">redis回收策略</span><br><span class="line"></span><br><span class="line">volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑</span><br><span class="line">  选最近最少使用的数据淘汰</span><br><span class="line">volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑</span><br><span class="line">  选将要过期的数据淘汰</span><br><span class="line">volatile-random：从已设置过期时间的数据集（server.db[i].expires）</span><br><span class="line"> 中任意选择数据淘汰</span><br><span class="line">allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数</span><br><span class="line"> 据淘汰</span><br><span class="line">allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</span><br><span class="line">no-enviction（驱逐）：禁止驱逐数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">缓存更新策略</span><br><span class="line"></span><br><span class="line">1、被动失效</span><br><span class="line">缓存数据主要是服务读请求的，通常会设置一个过期时间，或者当数据库</span><br><span class="line">状态改变时，通过一个简单的delete操作，使数据失效掉；当下次再去读</span><br><span class="line">取时，如果发现数据过期了或者不存在了，那么就重新去数据库读取，</span><br><span class="line">然后更新到缓存中，这即是所谓的被动失效策略。被动策略有一个很大的</span><br><span class="line">风险，从缓存失效到数据再次被预热到cache这段时间，所有的读请求会</span><br><span class="line">直接打到DB上，对于一个高访问量的系统，很容易被击垮。</span><br><span class="line"></span><br><span class="line">2、主动更新</span><br><span class="line">主动更新，很容易理解，就是数据库存储发生变化时，会直接同步更新到</span><br><span class="line">Cache，主要是为了解决cache空窗期引发的问题。比如电商的卖家修改商</span><br><span class="line">品详情，具有读多写少特点。但如果是读多写多，同样会带来另一个问题，</span><br><span class="line">就是并发更新。多台应用服务器同时访问一份数据是很正常的，这样就会</span><br><span class="line">存在一台服务器读取并修改了缓存数据，但是还没来得及写入的情况下，</span><br><span class="line">另一台服务器也读取并修改旧的数据，这时候，后写入的将会覆盖前面的，</span><br><span class="line">从而导致数据丢失。解决的方式可以有：锁控制，如redisson；版本号。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">影响命中率的可能因素：</span><br><span class="line"></span><br><span class="line">1、设置过期时间太短。</span><br><span class="line">2、空间不足，频繁有效的缓存按照回收策略被剔除</span><br><span class="line">3、key确实不存在</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">性能指标</span><br><span class="line"></span><br><span class="line">缓存空间的使用率</span><br><span class="line">topN 命令的执行次数</span><br><span class="line">缓存的命中率</span><br><span class="line">缓存的接口平均RT，最大RT，最小RT</span><br><span class="line">缓存的QPS</span><br><span class="line">网络出口流量</span><br><span class="line">客户端连接数</span><br><span class="line">key个数统计</span><br><span class="line">演练结果（如果缓存服务全部或个别宕掉的情况）</span><br><span class="line"></span><br><span class="line">5、如何保证高可用和一致性等等？</span><br><span class="line">主从集群+哨兵模式来保证高可用。</span><br><span class="line">先操作数据库，再操作redis ，来保证数据库和缓存之间的一致性。如果redis</span><br><span class="line">操作失败，mysql就会回滚，</span><br><span class="line">不会出现数据不一致的问题。并发问题通过互斥锁的形式解决。</span><br><span class="line"></span><br><span class="line">6、用这门技术可能会有什么坑？亲身经历有什么坑？如何解决？？有没备选或者</span><br><span class="line">应急方案？一些知名的公司是怎么用这门技术的？它们的心得体会及经验是怎么样的？</span><br><span class="line">举例：</span><br><span class="line">https://github.com/aalansehaiyang/technology-talk/blob/master/system-architecture/architecture-experience.md</span><br><span class="line">（可以看看缓存那一块）</span><br><span class="line"></span><br><span class="line">坑一：</span><br><span class="line">僵尸连接: 服务端连接数上限了，但是客户端连接数没有上限，线上部署的时候。</span><br><span class="line">缓兵之计：通过脚本命令清除连接，不用担心客户端，客户端会重连。</span><br><span class="line">我们重新给客户端设了最大超时，如果连接一直处于空闲状态，大概 5 分钟就会</span><br><span class="line">断开与服务器之间的长连接，但奇怪的是服务端不承认客户端的断连状态，一直保</span><br><span class="line">持该连接，结果从客户端的服务器看不到这种连接，但在 Redis 服务器上却看到</span><br><span class="line">大量这种连接，最终导致服务端连接数被占满，无法再创建新连接对外提供服务。</span><br><span class="line">原因：给服务端设置Timeout和客户端设置的Timeout不一致，服务端的时间更长一些。</span><br><span class="line"></span><br><span class="line">坑二：</span><br><span class="line">内存飙升</span><br><span class="line">内存最大值（maxmemory）限制：起初缓存的数据比较少，一直没配最大内存限制。</span><br><span class="line">这是一个小错误。系统除了报 Cluster down 外，并没更清晰的报错，当时我们一</span><br><span class="line">脸迷惘，莫名其妙地查了 1 个多小时后才发现服务器内存被耗光了。后面作分片</span><br><span class="line">处理。或者说部分不确定数据量大小的业务部门搭建自己的redis。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">此外，通过查看监控和查询日志，还可能是客户端滥用monitor命令。</span><br><span class="line">monitor的模型是这样的，它会将所有在Redis服务器执行的命令进行输出，通常来讲</span><br><span class="line">Redis服务器的QPS是很高的，也就是如果执行了monitor命令，Redis服务器在Monitor</span><br><span class="line">这个客户端的输出缓冲区又会有大量“存货”，也就占用了大量Redis内存。</span><br><span class="line">预防方法：禁止掉一些危险的命令(shutdown,flushall, monitor, keys *)。</span><br><span class="line">添加command-rename配置，将一些危险的命令(flushall, monitor, keys * , flushdb)</span><br><span class="line">做rename。</span><br><span class="line"></span><br><span class="line">坑三：</span><br><span class="line">连接数过多</span><br><span class="line">可以用netty重新写一个代理层</span><br><span class="line">或者各个业务部门自己搭建缓存系统，存储各自的业务热数据。</span><br><span class="line">各个业务部门都应该写个预热数据脚本。</span><br><span class="line"></span><br><span class="line">坑四：</span><br><span class="line">aof 文件占满磁盘空间，单机多实例可能存在Swap和OOM的隐患</span><br><span class="line">（提示：aof重写,aof存各种执行命令，aof重写也叫去冗余命令，重新生成一个新的脚本）</span><br><span class="line">此后每天执行BGREWRITEAOF指令脚本（异步操作，不会阻塞单线程）的同时并监控磁盘空</span><br><span class="line">间，减少服务器上 Redis 的实例数并腾空一半内存，因为一台机上部署多个 Redis 实例</span><br><span class="line">会有个隐患，万一多个实例扎堆做 AOF 重写会导致 swap 或者 oom，导致重写失败，这种</span><br><span class="line">失败会不断重复，直至 aof 文件像滚雪球似的变大，最终塞满磁盘，另外重写体积较大的</span><br><span class="line"> aof 文件时，Redis 会进入 IO 阻塞状态，停止对外服务</span><br><span class="line"></span><br><span class="line">坑五：</span><br><span class="line">缓存穿透：指的是对某个一定不存在的数据进行请求，该请求将会穿透缓存到达数据库。</span><br><span class="line">这是一种恶意操作的行为，往往表现在黑客或者懂相关技术的人去操作。</span><br><span class="line">解决方案：</span><br><span class="line">1、对这类请求进行过滤，用布隆过滤器，将数据库中所有的对应redis的key,进行hash, </span><br><span class="line">存到redis的bitmaps存储结构中，</span><br><span class="line">  然后操作redis具体数据前先请求bitmap中有没有相关的数据，没有直接返回。</span><br><span class="line">  具体操作请自行搜索：&quot;布隆过滤器 redis&quot;,</span><br><span class="line">  但用这个难免会有命中误差率，假设“abc”的hash值是587，而“19f”的hash值也是587, </span><br><span class="line">  那么如果19f在数据库中没有对应的数据，也是会穿透的，对于这类问题，</span><br><span class="line">  可以采用回设的方式，如果第一次数据库中没有查询到，设置一个默认值</span><br><span class="line">  存到redis中，第二次甚至往后的n次就可以直接在redis上catch住了。</span><br><span class="line">2、对这些不存在的数据缓存一个空数据或者指定的默认值。</span><br><span class="line"></span><br><span class="line">坑六：</span><br><span class="line">缓存雪崩：指的是由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效</span><br><span class="line">（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库。在有缓存的系统中，</span><br><span class="line">系统非常依赖于缓存，缓存分担了很大一部分的数据请求。当发生缓存雪崩时，数据库</span><br><span class="line">无法处理这么大的请求，导致数据库崩溃。这可以理解成是一种善意行为，是指用户请</span><br><span class="line">求量大而使请求越过缓存跳向数据库导致数据库宕机（TPS:1500左右）的行为。</span><br><span class="line">解决方案：</span><br><span class="line">1、为了防止缓存在同一时间大面积过期导致的缓存雪崩，可以通过观察用户行为，合理</span><br><span class="line">设置缓存过期时间（错隔时间，在某个时间内来个随机时间值）来实现；</span><br><span class="line">2、为了防止缓存服务器宕机出现的缓存雪崩，可以使用分布式缓存，分布式缓存中每一</span><br><span class="line">个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用。</span><br><span class="line">3、也可以进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓</span><br><span class="line">存雪崩。</span><br><span class="line"></span><br><span class="line">坑七：</span><br><span class="line">缓存 “无底洞” 现象：指的是为了满足业务要求添加了大量缓存节点，但是性能不但没有</span><br><span class="line">好转反而下降了的现象。</span><br><span class="line">解决方案：</span><br><span class="line">1、优化批量数据操作命令，尽量不设置过期时间及持久化操作，单线程只处理内存操作即可；</span><br><span class="line">2、减少网络通信次数；</span><br><span class="line">3、降低接入成本，使用长连接 / 连接池，NIO 等。</span><br><span class="line"></span><br><span class="line">坑八：</span><br><span class="line">缓存并发：有时候如果网站并发访问高，一个缓存如果失效，可能出现多个进程同时查询DB，</span><br><span class="line">  同时设置缓存的情况，如果并发确实很大，这也可能造成DB压力过大，还有缓存</span><br><span class="line">  频繁更新的问题。</span><br><span class="line">解决方法：互斥锁。我现在的想法是对缓存查询加锁，如果KEY不存在，就加锁，然后查DB</span><br><span class="line">入缓存，然后解锁；</span><br><span class="line">其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询。</span><br><span class="line"></span><br><span class="line">这种情况和刚才说的预先设定值问题有些类似，只不过利用锁的方式，会造成部分请求等待。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如何从零设计缓存服务？</span><br><span class="line"></span><br><span class="line">尽量不用持久化（提前预热），过期时间（带时间戳，必要时起定时任务剔除）。</span><br><span class="line"></span><br><span class="line">并发访问大的页面相关数据要提前预热。</span><br><span class="line"></span><br><span class="line">修改keys，hgetall，smembers，shutdown,flushall, monitor，flushdb等长时</span><br><span class="line">间命令，使其无法使用批量耗时操作命令。</span><br><span class="line"></span><br><span class="line">设置慢查询的值，定期查询慢查询日志。</span><br><span class="line"></span><br><span class="line">尽可能使用散列表，而不是将对象转换成json字符串的形式。</span><br><span class="line"></span><br><span class="line">上线前演练如果缓存宕掉对系统的影响。</span><br><span class="line"></span><br><span class="line">做好监控及告警：命中率、内存使用情况、客户端连接数、峰值，请求和响应时间。</span><br><span class="line"></span><br><span class="line">搭建主从集群和哨兵模式环境。</span><br><span class="line"></span><br><span class="line">设置连接超时时间和请求超时时间。</span><br><span class="line"></span><br><span class="line">对数据库中不存在的数据回源给缓存一个空数据或者指定的默认值。</span><br><span class="line"></span><br><span class="line">对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁。</span><br><span class="line"></span><br><span class="line">做好缓存系统的设计和评审指标。</span><br><span class="line"></span><br><span class="line">规范来限制各个应用使用的key有唯一的前缀。</span><br><span class="line"></span><br><span class="line">缓存数据过大，建议序列化，或者拆分。</span><br><span class="line"></span><br><span class="line">额外：</span><br><span class="line">缓存系统的设计和评审指标</span><br><span class="line">举例: 设计缓存系统要考虑的问题：容量评估、客户端长连接数、</span><br><span class="line">  并发量（平均、最高）、最慢响应时间、使用成本、容灾性、</span><br><span class="line">  缓存对象粒度大小（太大要考虑序列化，如果protobuf,kryo）</span><br><span class="line">1、容量规划（根据容量评估的结果来申请和分配缓存资源，否则会造成资源浪费或者缓存空间不够）</span><br><span class="line">缓存内容的数量、大小、数据结构、失效时间</span><br><span class="line">淘汰策略</span><br><span class="line">每秒的读、写峰值</span><br><span class="line"></span><br><span class="line">2、性能优化</span><br><span class="line">线程模型：配置成NIO形式</span><br><span class="line">预热方法</span><br><span class="line">缓存分片（尽量不用，比较复杂）</span><br><span class="line">冷热数据的比例</span><br><span class="line"></span><br><span class="line">3、高可用</span><br><span class="line"></span><br><span class="line">4、缓存监控</span><br><span class="line">缓存服务监控</span><br><span class="line">缓存容量监控（内存使用）</span><br><span class="line">缓存请求监控（大对象会影响请求响应。）</span><br><span class="line">缓存响应时间监控（慢查询）</span><br><span class="line"></span><br><span class="line">5、注意事项举例</span><br><span class="line">是否有可能发生缓存穿透</span><br><span class="line">是否有大对象</span><br><span class="line">是否使用缓存实现分布式锁</span><br><span class="line">是否避免了Race Condition（竞争条件，并发）</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">建议将使用缓存的业务进行分离，核心业务和非核心业务使用不同的</span><br><span class="line">缓存实例，从物理上进行隔离，如果有条件，则请对每个业务使用单</span><br><span class="line">独的实例或者集群，以减小应用之间互相影响的可能性。</span><br><span class="line"></span><br><span class="line">如果缓存设置了超时时间，如果超时设置得较长，从而拖垮服务的线</span><br><span class="line">程池，最终导致服务雪崩的情况。</span><br><span class="line"></span><br><span class="line">如果多个业务共享一套缓存服务，我们得规范来限制各个应用使用的</span><br><span class="line">key有唯一的前缀，并进行隔离设计，避免产生缓存互相覆盖的问题。</span><br><span class="line"></span><br><span class="line">任何缓存的key都必须设定缓存失效时间，且失效时间不能集中在某</span><br><span class="line">一点，否则会导致缓存占满内存或者缓存雪崩。</span><br><span class="line"></span><br><span class="line">对于存储较多value的key，尽量不要使用HGETALL、keys等集合批量</span><br><span class="line">命令操作(可用scan命令)，该操作会造成请求阻塞，影响其他应用的访问。</span><br><span class="line"></span><br><span class="line">缓存的数据不易过大，尤其是Redis，因为Redis使用的是单线程模型，</span><br><span class="line">在单个缓存key的数据过大时，会阻塞其他请求的处理。</span><br><span class="line"></span><br><span class="line">在使用本地缓存（如Ehcache）时，一定要严格控制缓存对象的个数及</span><br><span class="line">声明周期。由于JVM的特性，过多的缓存对象会极大影响JVM的性能，</span><br><span class="line">甚至导致内存溢出等。</span><br><span class="line"></span><br><span class="line">在使用缓存时，一定要有降级处理，否则请求并发过高容易拖垮应用</span><br><span class="line">服务。（代码层面如try catch，设置连接及访问redis的超时时间）</span><br><span class="line"></span><br><span class="line">利益化：面试时会问什么样的问题？（高级开发，架构师，cto不同的角色）</span><br><span class="line">TODO</span><br><span class="line"></span><br><span class="line">通过在github上搜索&quot;架构&quot;或者&quot;java面试&quot; 里面会有对应的资源（redis）可以深入学习。</span><br><span class="line">或者https://github.com/aalansehaiyang/technology-talk/blob/master/system-architecture/architecture-experience.md</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;耗时1个多月空闲出来的时间学习整理的redis相关知识。&lt;br&gt;
    
    </summary>
    
      <category term="缓存" scheme="https://ouzhrm.github.io/categories/%E7%BC%93%E5%AD%98/"/>
    
    
      <category term="redis" scheme="https://ouzhrm.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>学习一门技术的思路过程</title>
    <link href="https://ouzhrm.github.io/2019/08/22/%E5%AD%A6%E4%B9%A0%E6%9F%90%E4%B8%80%E9%97%A8%E6%8A%80%E6%9C%AF%E7%9A%84%E6%80%9D%E8%B7%AF%E8%BF%87%E7%A8%8B/"/>
    <id>https://ouzhrm.github.io/2019/08/22/学习某一门技术的思路过程/</id>
    <published>2019-08-22T03:40:58.000Z</published>
    <updated>2019-08-22T04:10:32.691Z</updated>
    
    <content type="html"><![CDATA[<p>在学习一门技术之前，<br>是不是应该思考这门技术对我们的项目有那些用处，<br>解决了那些痛点，如何系统的去学习这门技术？<br>好，废话不多说，聊聊我最近的一些思考！<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">干货来了，可以按照下面的顺序问题去学习！</span><br><span class="line">1、为什么要用这门技术？之前的项目遇到过什么样的问题？</span><br><span class="line">2、这门技术相对于其他的同类技术，为什么选用这门技术？两者或者多者的比较？有哪些优缺点？</span><br><span class="line">    举例：</span><br><span class="line">如自身的相关数值：数据量、TPS、响应时间。</span><br><span class="line">缓存相关的有：本地缓存、分布式缓存（redis、mamcached）、客户端缓存、数据库缓存。</span><br><span class="line">选型指标：容量、并发量、响应时间、使用成本、扩展性、容灾。</span><br><span class="line">3、这门技术可以运用在什么场景上？</span><br><span class="line">4、如何运用这门技术？这门技术是怎么实现的？？</span><br><span class="line">5、如何保证高可用和一致性等等？</span><br><span class="line">6、用这门技术可能会有什么坑？亲身经历有什么坑？如何解决？？有没备选或者应急方案？？</span><br><span class="line">举例：</span><br><span class="line">https://github.com/aalansehaiyang/technology-talk/blob/master/system-architecture/architecture-experience.md</span><br><span class="line">（可以看看缓存那一块）</span><br><span class="line">7、利益化：面试时会问什么样的问题？（高级开发，架构师，cto不同的角色）</span><br><span class="line"></span><br><span class="line">参考示例文章如：https://data.qq.com/article?id=2879</span><br></pre></td></tr></table></figure></p><font color="#A52A2A" size="2"><br>思路决定出路，思想决定高度！<br>磨刀不误砍柴工！<br>高级开发看到技术，架构看到未来，cto看到价值！<br></font>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在学习一门技术之前，&lt;br&gt;是不是应该思考这门技术对我们的项目有那些用处，&lt;br&gt;解决了那些痛点，如何系统的去学习这门技术？&lt;br&gt;好，废话不多说，聊聊我最近的一些思考！&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://ouzhrm.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>springcloud集成protocol buffer传输协议一些总结</title>
    <link href="https://ouzhrm.github.io/2018/12/04/springcloud%E9%9B%86%E6%88%90protocol-buffer%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/"/>
    <id>https://ouzhrm.github.io/2018/12/04/springcloud集成protocol-buffer传输协议一些总结/</id>
    <published>2018-12-04T13:36:07.000Z</published>
    <updated>2018-12-04T14:29:40.897Z</updated>
    
    <content type="html"><![CDATA[<p>protocol buffer是什么？<br>protocol buffer是google定义的一种传输格式协议，类似json和xml，它的<br>优势在于它的传输体积小，解析速度快，如果传输的数据特别大，它传输的<br>速度及解析的速度是json和xml解析的指数级别。之前有记得看过一本书，<br>是用Gzip压缩数据来传输，从而实现传输体积小的目的，但是它有一个缺点<br>就是解压缩的时候特别耗计算机cpu性能。而protocol buffer它是通过对对<br>象进行序列化和反序列化的。<br><a id="more"></a></p><p>protocol buffer序列化和反序列化的原理？<br>本质还是对象与字节之间转换的传输，比如入参通过把字节转换成对象，<br>通过双方定义的格式，而出参是通过将对象转换成字节。也就是在网络中<br>传输还是通过字节的形式，可以想象一下字母转换成0101010001类似的格<br>式。笔者对四层tcp/ip网络协议，七层osi网络协议不是特别理解，大家<br>有特别懂的，私信我一下，万分感激。字节具体可以理解成二进制串。类似<br>映射键值对那种，中间加个长度。如k1-1-v1-k2-6-v2-…（这一块后面我再<br>仔细研究，深入它为什么解析速度会这么快的原理）</p><p>springcloud是怎么集成protocol buffer的？（重点描述！！）<br>因为用spring全家桶的原因，eureka作为配置和注册发现中心，feign消费方<br>是怎么通过protobuf来调用生产方的呢？<br>1.下载protobuf<br><a href="https://github.com/google/protobuf/releases" target="_blank" rel="noopener">https://github.com/google/protobuf/releases</a><br>选择protoc-xxx-win32.zip下载<br>2.将解压出来的protoc.exe放在C:\Windows\System32目录下，<br>同时在windows环境变量中新建proto_path变量，值为C:\Windows\System32\protoc.exe的路径<br>3.在所使用的proto文件路径下打开cmd窗口执行以下命令<br>4.执行protoc –version命令检查是否安装成功<br>protoc –version<br>5.然后写proto文件，生成一个RetreatCouponReqConvert.proto文件<br>文件内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto2&quot;;</span><br><span class="line">package com.carlife.coupon.proto.model; //输出路径</span><br><span class="line">option java_outer_classname = &quot;RetreatCouponReqConvertModel&quot;;  //输出的类名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">message RetreatCouponReqConvert&#123;</span><br><span class="line">    required string orderId = 1 ;</span><br><span class="line">    required string couponCode   = 2 ;</span><br><span class="line">    required string srcPartnerId   = 3 ;</span><br><span class="line">    required string sign   = 4 ;</span><br><span class="line">    required string caller   = 5 ;</span><br><span class="line">    required string noise   = 6 ;</span><br><span class="line">    required string reqId   = 7 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个文件对应的java文件如：RetreatCouponReqConvert.java<br>内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class RetreatCouponReqConvert extends BaseReq implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">  private static final Long serialVersionUID = 5797586702757567145L;</span><br><span class="line"></span><br><span class="line">  @NotBlank</span><br><span class="line">  @ApiModelProperty(value = &quot;订单id&quot;,required = true)</span><br><span class="line">  private String orderId; // required</span><br><span class="line"></span><br><span class="line">  @NotBlank</span><br><span class="line">  @ApiModelProperty(value = &quot;券码&quot;,required = true)</span><br><span class="line">  private String couponCode; // required</span><br><span class="line"></span><br><span class="line">  @NotBlank</span><br><span class="line">  @ApiModelProperty(value = &quot;退款商户ID&quot;,required = true)</span><br><span class="line">  private String srcPartnerId;</span><br><span class="line">  </span><br><span class="line">   /**</span><br><span class="line">     * 签名</span><br><span class="line">     */</span><br><span class="line">    @ApiModelProperty(value = &quot;【必填】签名&quot;)</span><br><span class="line">    @NotBlank</span><br><span class="line">    private String sign;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 调用者，和签名一起传入，用于校验</span><br><span class="line">     */</span><br><span class="line">    @ApiModelProperty(value = &quot;【必填】调用者，和签名一起传入，用于校验&quot;)</span><br><span class="line">    @NotBlank</span><br><span class="line">    private String caller;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 随机数（例如 访问时间戳）</span><br><span class="line">     */</span><br><span class="line">    @ApiModelProperty(value = &quot;【必填】随机数（例如 访问时间戳）&quot;)</span><br><span class="line">    @NotBlank</span><br><span class="line">    private String noise;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 访问请求ID</span><br><span class="line">     */</span><br><span class="line">    @ApiModelProperty(value = &quot;【必填】访问请求ID&quot;)</span><br><span class="line">    @NotBlank</span><br><span class="line">    private String reqId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后跑一下这个文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.carlife.common.utils;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * protoc.exe -I=proto的输入目录 --java_out=java类输出目录 proto的输入目录包括包括proto文件</span><br><span class="line"> * </span><br><span class="line"> * @author Administrator</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class GenerateClass &#123;</span><br><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">String protoFile = &quot;RetreatCouponReqConvert.proto&quot;;</span><br><span class="line">String path = &quot;D:/cashier-master/cashier-master/cashier-sdk/src/main/java/com/carlife/coupon/proto&quot;;</span><br><span class="line">String out =  &quot;D:/cashier-master/cashier-master/cashier-sdk/src/main/java&quot;;</span><br><span class="line">String strCmd = &quot;C:/Windows/System32/protoc.exe -I=&quot; + path +</span><br><span class="line">&quot; --java_out=&quot; + out + &quot; &quot; + path + &quot;/&quot; + protoFile;</span><br><span class="line">System.out.println(strCmd);</span><br><span class="line">Runtime.getRuntime().exec(strCmd);</span><br><span class="line">System.out.println(&quot;完成&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果RetreatCouponReqConvertModel.java没有生成，粘strCmd出来到git命令行窗口跑,找下原因</p><p>依赖jar包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.protobuf&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;protobuf-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.6.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.googlecode.protobuf-java-format&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;protobuf-java-format&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.protobuf&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;protobuf-java-util&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.6.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;gson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.8.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>feign（调用者）端在启动如SpringApplication.java启动文件同级目录下增加以下配置文件</p><p>内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package com.carlife;</span><br><span class="line"></span><br><span class="line">import feign.codec.Decoder;</span><br><span class="line">import feign.codec.Encoder;</span><br><span class="line">import org.springframework.beans.factory.ObjectFactory;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.autoconfigure.web.HttpMessageConverters;</span><br><span class="line">import org.springframework.cloud.netflix.feign.support.ResponseEntityDecoder;</span><br><span class="line">import org.springframework.cloud.netflix.feign.support.SpringDecoder;</span><br><span class="line">import org.springframework.cloud.netflix.feign.support.SpringEncoder;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.http.converter.protobuf.ProtobufHttpMessageConverter;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class ProtoFeignConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ObjectFactory&lt;HttpMessageConverters&gt; messageConverters;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    ProtobufHttpMessageConverter protobufHttpMessageConverter() &#123;</span><br><span class="line">        return new ProtobufHttpMessageConverter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Encoder springEncoder()&#123;</span><br><span class="line">        return new SpringEncoder(this.messageConverters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Decoder springDecoder()&#123;</span><br><span class="line">        return new ResponseEntityDecoder(new SpringDecoder(this.messageConverters));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>生产者（被调用者）端同样在启动如SpringApplication.java启动文件同级目录下增加以下配置文件<br>内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.carlife.coupon;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.http.converter.protobuf.ProtobufHttpMessageConverter;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class ProtoBufServerConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    ProtobufHttpMessageConverter protobufHttpMessageConverter() &#123;</span><br><span class="line">        return new ProtobufHttpMessageConverter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后一步，编写消费接口和生产接口<br>消费接口类似的内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(method = RequestMethod.POST, value = &quot;/retreatCouponPb&quot;, consumes = &quot;application/x-protobuf&quot;,produces=&quot;application/x-protobuf&quot;)</span><br><span class="line">RetreatCouponRspModel.RetreatCouponRsp retreatCouponPb(RetreatCouponReqConvertModel.RetreatCouponReqConvert req);</span><br></pre></td></tr></table></figure></p><p>生产接口类似的内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(value = &quot;retreatCouponPb&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public RetreatCouponRspModel.RetreatCouponRsp retreatCouponPb(@RequestBody RetreatCouponReqConvertModel.RetreatCouponReqConvert req) &#123;</span><br><span class="line">String couponCode = req.getCouponCode();</span><br><span class="line">System.out.println(&quot;couponCode : &quot;+couponCode);</span><br><span class="line">RetreatCouponRspModel.RetreatCouponRsp.Builder builder = RetreatCouponRspModel.RetreatCouponRsp.newBuilder();</span><br><span class="line">builder.setMsg(&quot;-----OK----&quot;);</span><br><span class="line">builder.setCode(RspMsgCodeEnum.SUCCESS.getValue());</span><br><span class="line">return builder.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后用下面来调用消费接口即可，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(value = &quot;testProto&quot;)</span><br><span class="line">public void testProto(@RequestBody RefundOrderReq refundOrderReq) &#123;</span><br><span class="line">RetreatCouponReqConvertModel.RetreatCouponReqConvert build = RetreatCouponReqConvertModel.RetreatCouponReqConvert.newBuilder()</span><br><span class="line">.setCaller(&quot;123&quot;).setCouponCode(&quot;888888888888888888&quot;)</span><br><span class="line">.setNoise(&quot;123&quot;).setOrderId(&quot;123&quot;).setReqId(&quot;123&quot;)</span><br><span class="line">.setSign(&quot;123&quot;).setSrcPartnerId(&quot;123&quot;).build();</span><br><span class="line">RetreatCouponRspModel.RetreatCouponRsp retreatCouponRsp = couponProviderV2.retreatCouponPb(build);</span><br><span class="line">System.out.println(&quot;code = &quot;+retreatCouponRsp.getCode()+&quot;msg = &quot;+retreatCouponRsp.getMsg());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上可能不是写的很详细，深感抱歉，但希望能帮助到有需要的人。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;protocol buffer是什么？&lt;br&gt;protocol buffer是google定义的一种传输格式协议，类似json和xml，它的&lt;br&gt;优势在于它的传输体积小，解析速度快，如果传输的数据特别大，它传输的&lt;br&gt;速度及解析的速度是json和xml解析的指数级别。之前有记得看过一本书，&lt;br&gt;是用Gzip压缩数据来传输，从而实现传输体积小的目的，但是它有一个缺点&lt;br&gt;就是解压缩的时候特别耗计算机cpu性能。而protocol buffer它是通过对对&lt;br&gt;象进行序列化和反序列化的。&lt;br&gt;
    
    </summary>
    
    
      <category term="springcloud" scheme="https://ouzhrm.github.io/tags/springcloud/"/>
    
      <category term="protocol buffer" scheme="https://ouzhrm.github.io/tags/protocol-buffer/"/>
    
      <category term="eureka" scheme="https://ouzhrm.github.io/tags/eureka/"/>
    
  </entry>
  
  <entry>
    <title>mybatis源码分析《二》 - 接口实现原理</title>
    <link href="https://ouzhrm.github.io/2018/07/31/mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%8A%E4%BA%8C%E3%80%8B-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://ouzhrm.github.io/2018/07/31/mybatis源码分析《二》-接口实现原理/</id>
    <published>2018-07-31T12:34:37.000Z</published>
    <updated>2018-07-31T12:38:13.257Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><img src="/images/mybatis_jiekou_shixianyuanli/mybatis_jiekou_01.png" alt="图片不存在了，请联系博主更新图片"><br><img src="/images/mybatis_jiekou_shixianyuanli/mybatis_jiekou_02.png" alt="图片不存在了，请联系博主更新图片"><br><img src="/images/mybatis_jiekou_shixianyuanli/mybatis_jiekou_03.png" alt="图片不存在了，请联系博主更新图片"><br><img src="/images/mybatis_jiekou_shixianyuanli/mybatis_jiekou_04.png" alt="图片不存在了，请联系博主更新图片"><br><img src="/images/mybatis_jiekou_shixianyuanli/mybatis_jiekou_05.png" alt="图片不存在了，请联系博主更新图片"><br><img src="/images/mybatis_jiekou_shixianyuanli/mybatis_jiekou_06.png" alt="图片不存在了，请联系博主更新图片"><br><img src="/images/mybatis_jiekou_shixianyuanli/mybatis_jiekou_07.png" alt="图片不存在了，请联系博主更新图片"><br><img src="/images/mybatis_jiekou_shixianyuanli/mybatis_jiekou_08.png" alt="图片不存在了，请联系博主更新图片"><br><img src="/images/mybatis_jiekou_shixianyuanli/mybatis_jiekou_09.png" alt="图片不存在了，请联系博主更新图片"><br><img src="/images/mybatis_jiekou_shixianyuanli/mybatis_jiekou_10.png" alt="图片不存在了，请联系博主更新图片"><br><img src="/images/mybatis_jiekou_shixianyuanli/mybatis_jiekou_11.png" alt="图片不存在了，请联系博主更新图片"><br><img src="/images/mybatis_jiekou_shixianyuanli/mybatis_jiekou_12.png" alt="图片不存在了，请联系博主更新图片"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;/images/mybatis_jiekou_shixianyuanli/mybatis_jiekou_01.png&quot; alt=&quot;图片不存在了，请联系博主更新图片&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/myba
      
    
    </summary>
    
    
      <category term="mybatis" scheme="https://ouzhrm.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis源码分析《一》 - 整体结构</title>
    <link href="https://ouzhrm.github.io/2018/07/24/mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%8A%E4%B8%80%E3%80%8B-%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84/"/>
    <id>https://ouzhrm.github.io/2018/07/24/mybatis源码分析《一》-整体结构/</id>
    <published>2018-07-24T03:09:58.000Z</published>
    <updated>2019-09-23T10:06:22.764Z</updated>
    
    <content type="html"><![CDATA[<p>在学习mybatis之前我们先了解一下jdbc。<br>Jdbc操作数据库的步骤：<br>1、    加载驱动<br>2、    获取数据库连接<br>3、    根据数据库连接操作数据库，实现增删改查<br>4、    关闭资源。<br><a id="more"></a><br>举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">String URL = &quot;jdbc:mysql://127.0.0.1:3306/bootdo?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;;</span><br><span class="line">String USER = &quot;root&quot;;</span><br><span class="line">String PASSWORD = &quot;root&quot;;</span><br><span class="line">//1.加载驱动程序</span><br><span class="line">try &#123;</span><br><span class="line">    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">//2.获得数据库链接</span><br><span class="line">Connection conn = DriverManager.getConnection(URL, USER, PASSWORD);</span><br><span class="line">//3.通过数据库的连接操作数据库，实现增删改查（使用Statement类）</span><br><span class="line">Statement st = conn.createStatement();</span><br><span class="line"></span><br><span class="line">ResultSet resultSet = st.executeQuery(&quot;select * from student&quot;);</span><br><span class="line">long age = 0;</span><br><span class="line">while (resultSet.next()) &#123;</span><br><span class="line">    age = resultSet.getLong(&quot;age&quot;);</span><br><span class="line">    age++;</span><br><span class="line">&#125;</span><br><span class="line">boolean rs = st.execute(&quot;update student set age = &quot; + age + &quot; where id = 13&quot;);</span><br><span class="line">System.out.println(rs);</span><br><span class="line">//关闭资源</span><br><span class="line">st.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure></p><p>mybatis是由jdbc演变而来的，目的是简化jdbc操作步骤，提高jdbc操作性能。</p><h4 id="mybatis解决了jdbc的什么问题？"><a href="#mybatis解决了jdbc的什么问题？" class="headerlink" title="mybatis解决了jdbc的什么问题？"></a>mybatis解决了jdbc的什么问题？</h4><p>1、    使用连接池代替了获取数据库连接，有效的循环利用连接资源。<br>我们知道，以mysql为例，如果mysql的连接数大于设置的最大连接数，就会因资源占用<br>而导致数据库宕机。<br>我们可以修改mysql最大连接数：打开my.ini，修改max_connections=100(默认为100)。<br>此外还有执行sql来设置最大连接数，此处就不多讲。<br>2、    操作方便，使用简单，简单数据库操作可以使用面向接口编程，特别适合一些大型<br>企业项目，减少重复性代码。<br>3、    待补充。。</p><h4 id="mybatis的整体结构"><a href="#mybatis的整体结构" class="headerlink" title="mybatis的整体结构"></a>mybatis的整体结构</h4><p>在分析mybatis源码之前，我们先看看mybatis的整体结构，这样在深入读源码的时候不会绕晕。<br>mybatis可以整体分成四层分析。</p><p>接口层，也是最上层，提供了给咋们用的增删改查的接口，而接口的调用方式分成，<br>第一种基于Mapper接口，也就是我们常常说的dao层映射到xml映射文件，或者采用<br>注解的形式，接口化编程的风格，也是我们集成spring的时候最常用的一种形式。<br>此外第二种是mybatis传统的调用方式，如sqlSession.selectList(statementId， Map形式的参数)，<br>statementId一般是类的全限定名。</p><p>数据处理层，分别是参数映射，sql解析，sql执行，结果集映射。参数映射是java数据格式转<br>化成sql参数格式，期间也会通过TypeHandler来操作java格式和sql格式参数之间的转换。但<br>主要的操作是在ParameterHandler这个类中进行的。它会调起TypeHandler进行操作。Sql解析，<br>也就是将sql和参数拼凑起来形成一个完整的可执行的sql，它的操作是在sqlSource中进行的。<br>而sql执行，是在Executor类中执行的，它底层封装了Statement相关实现类。调用的是statement<br>类的execute方法或者是executeQuery方法。最后是结果集映射，我们知道jdbc执行sql后生成的<br>结果集，我们还得自己去转成java数据格式或者封装对象属性相关的数据。这时mybatis提供了<br>结果集映射成java类型的ResultSetHandler类，期间也会调用TypeHandler来完成原生结果集转<br>换成我们想要的java数据格式。</p><p>框架支撑层，无非就是连接池、事务、和缓存，这些来支撑我们执行sql提供了一系列相关的保障。<br>连接池保证了咋们的宝贵的连接资源可重复利用。事务保证了执行sql的一致性、隔离性、永久性、</p><p>原子性。缓存提高了相同查询结果的性能。<br>引导层，不多说了，怎么用这个框架，引导去用的相关问题。</p><h4 id="下面是结构图："><a href="#下面是结构图：" class="headerlink" title="下面是结构图："></a>下面是结构图：</h4><p><img src="/images/jiegoutu.png" alt="图片不存在了，请联系博主更新图片"></p><h4 id="下面是各层次的调用图。"><a href="#下面是各层次的调用图。" class="headerlink" title="下面是各层次的调用图。"></a>下面是各层次的调用图。</h4><p><img src="/images/cengcidiaoyongtu.png" alt="图片不存在了，请联系博主更新图片"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在学习mybatis之前我们先了解一下jdbc。&lt;br&gt;Jdbc操作数据库的步骤：&lt;br&gt;1、    加载驱动&lt;br&gt;2、    获取数据库连接&lt;br&gt;3、    根据数据库连接操作数据库，实现增删改查&lt;br&gt;4、    关闭资源。&lt;br&gt;
    
    </summary>
    
    
      <category term="mybatis" scheme="https://ouzhrm.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>代码规范的一些总结</title>
    <link href="https://ouzhrm.github.io/2018/07/10/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/"/>
    <id>https://ouzhrm.github.io/2018/07/10/代码规范的一些总结/</id>
    <published>2018-07-10T09:41:09.000Z</published>
    <updated>2018-07-10T09:43:25.008Z</updated>
    
    <content type="html"><![CDATA[<p>IDEA先安装alibaba coding插件和FindBug的插件。<br>然后下面的一些问题：<br>阿里巴巴代码规范插件扫描出来的问题：</p><p>1、不能name.equals(“”)，而应该””.equals(name) ，否则容易报空指针<br><a id="more"></a><br>2、不能这样写：<br>if(x&gt;1) return msg;<br>或者<br>if(x&gt;1)<br>return msg;<br>应该<br>if(x&gt;1){<br>return msg;<br>}</p><p>3、不能使用过时的类和方法<br>如：org.apache.http.conn.ssl.SSLContexts这个类已经过时了</p><p>4、常量因为都是大写<br>如：<br>public static final String Algorithm_Dsa= “DSA”;<br>而应该：<br>public static final String ALGORITHM_DSA = “DSA”;</p><p>5、变量应该遵循驼峰<br>如：public static String sign(Object data, String private_key) throws Exception {}<br>而应该<br>public static String sign(Object data, String privateKey) throws Exception {}</p><p>6、long型常量应该以大写L结尾<br>如：public static final long TIME_LENGTH= 864000l;<br>而应该：<br>public static final long TIME_LENGTH= 864000L;</p><p>7、重写equals()、toString()、hashcode()方法上方应该加@Override</p><p>8、枚举类对应的字段都要加上注释，不然以后自己都可能会忘记。</p><p>9、集合初始化时，应该指定集合初始值大小。如果HashMap不填默认长度为16，默认阈值为0.75，一旦超过12个元素就会触发扩容。<br>毕竟集合扩容也挺耗性能的嘛</p><p>10、所有类都必须添加创建者信息，不然出了问题不好确定时，还得去git上查历史记录。</p><p>11、等等….</p><p>此外还有FindBugs插件的使用，这里具体就不说了，挺好用额，扫出来的问题能更好的提高代码的健壮性。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;IDEA先安装alibaba coding插件和FindBug的插件。&lt;br&gt;然后下面的一些问题：&lt;br&gt;阿里巴巴代码规范插件扫描出来的问题：&lt;/p&gt;
&lt;p&gt;1、不能name.equals(“”)，而应该””.equals(name) ，否则容易报空指针&lt;br&gt;
    
    </summary>
    
    
      <category term="代码规范" scheme="https://ouzhrm.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>数据传输中的安全性的一点思考</title>
    <link href="https://ouzhrm.github.io/2018/06/30/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/"/>
    <id>https://ouzhrm.github.io/2018/06/30/数据传输中的安全性的一点思考/</id>
    <published>2018-06-30T04:20:55.000Z</published>
    <updated>2018-07-01T07:17:30.292Z</updated>
    
    <content type="html"><![CDATA[<p>本次总结主要以技术为主，到了6月30号了，转眼间，收银台项目已经建立起来有两个多月了，<br>从刚开始的我负责，到两个人负责，现在是4个人负责，建立起来了支付组。后边还得继续<br>招小伙伴，很累，但也收获很多，现在收银台包含支付网关、券系统、账户系统、交易系统、<br>收银台入口等多个模块，说白了，只要涉及到钱的功能，都得过我们这一边。废话不多说，<br>技术撸上：<br><a id="more"></a><br>首先是安全性，收银台跟钱相关的，所以我们把安全性作为项目第一位考虑的，数据对内部<br>要防篡改，对外部数据传输要加密，为什么安全性排第一位呢？就是数据传输过程中，黑客把数据<br>拦截了下来，然后对数据进行一番改造，假设充值时，把0.1元字段改成10000元，黑客实际支付了<br>0.1元，然后在提现时就可能提出10000元来，当然这是简单的假设举例，而实际上提现更为复杂，<br>经过多重校验和多重审核。我们实现的是防篡改和防破解的思想是这样的：先用工具生成非对称性的<br>公私钥对，私钥加密，公钥解密，数据在网络传输前先用私钥加密，到达服务端时用公钥解密，而防<br>破解私钥，我们在数据的传输前加入一个随机数字段，这样保证每一次密文都是不一样的。但我们如<br>果供对内部的系统调用则主要是防篡改，干货来了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></td><td class="code"><pre><span class="line">package com.carlife.common.sign.utils;</span><br><span class="line"></span><br><span class="line">import com.carlife.cashier.vo.CashierPrepayReq;</span><br><span class="line">import sun.misc.BASE64Decoder;</span><br><span class="line">import sun.misc.BASE64Encoder;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.security.*;</span><br><span class="line">import java.security.interfaces.DSAPrivateKey;</span><br><span class="line">import java.security.interfaces.DSAPublicKey;</span><br><span class="line">import java.security.spec.PKCS8EncodedKeySpec;</span><br><span class="line">import java.security.spec.X509EncodedKeySpec;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 签名验签算法:DSA</span><br><span class="line"> * 1、生成密钥对</span><br><span class="line"> * 2、签名</span><br><span class="line"> * 3、验签</span><br><span class="line"> */</span><br><span class="line">public class DSASignaureUtil &#123;</span><br><span class="line">    public static final String  Algorithm_DSA=&quot;DSA&quot;;</span><br><span class="line">    //默认密钥字节数</span><br><span class="line">    private static final int key_size=1024;</span><br><span class="line">    //默认种子</span><br><span class="line">    public static final String default_seed=&quot;0f22507a10bbddd07d8a3082122966e3&quot;;</span><br><span class="line"></span><br><span class="line">    public static final String public_key = &quot;DSAPublicKey&quot;;</span><br><span class="line">    public static final String private_key = &quot;DSAPrivateKey&quot;;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 生成密钥种子</span><br><span class="line">     * @param seed</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static Map initKey(String seed) throws Exception&#123;</span><br><span class="line">        KeyPairGenerator keygen = KeyPairGenerator.getInstance(Algorithm_DSA);</span><br><span class="line">        //　初始化随机产生器</span><br><span class="line">        SecureRandom secureRandom = new SecureRandom();</span><br><span class="line">        secureRandom.setSeed(seed.getBytes());</span><br><span class="line">        keygen.initialize(key_size,secureRandom);</span><br><span class="line">        KeyPair keys = keygen.genKeyPair();</span><br><span class="line">        DSAPublicKey publicKey = (DSAPublicKey) keys.getPublic();</span><br><span class="line">        DSAPrivateKey privateKey = (DSAPrivateKey) keys.getPrivate();</span><br><span class="line">        Map map = new HashMap(2);</span><br><span class="line">        map.put(public_key,publicKey);</span><br><span class="line">        map.put(private_key,privateKey);</span><br><span class="line"></span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * description: 加签名方法 &lt;p&gt;</span><br><span class="line">    * param: [data, private_key] &lt;p&gt;</span><br><span class="line">    * return: java.lang.String &lt;p&gt;</span><br><span class="line">    * author: shicong yang&lt;p&gt;</span><br><span class="line">    * date: 2018/6/28 &lt;p&gt;</span><br><span class="line">    */</span><br><span class="line">    public static String sign(Object data,String private_key)throws Exception&#123;</span><br><span class="line">       return  sign(getData(data),private_key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 用私钥对信息生成数字签名</span><br><span class="line">     * @param data 加密数据</span><br><span class="line">     * @param privateKey 私钥</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static String sign(byte[] data,String privateKey)throws Exception&#123;</span><br><span class="line">        //　解密由base64编码的私钥</span><br><span class="line">        byte[] keyBytes = decryptBASE64(privateKey);</span><br><span class="line">        //　构造PKCS8EncodedKeySpec对象</span><br><span class="line">        //PKCS#8:描述私有密钥信息格式，该信息包括公开密钥算法的私有密钥以及可选的属性集等[27]。</span><br><span class="line">        PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes);</span><br><span class="line">        //　KEY_ALGORITHM　指定的加密算法</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(Algorithm_DSA);</span><br><span class="line">        //　取私钥匙对象</span><br><span class="line">        PrivateKey priKey = keyFactory.generatePrivate(pkcs8KeySpec);</span><br><span class="line">        //用私钥对信息生成数字签名</span><br><span class="line">        Signature signature = Signature.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        signature.initSign(priKey);</span><br><span class="line">        signature.update(data);</span><br><span class="line"></span><br><span class="line">        return encryptBASE64(signature.sign());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean verify(Object data,String publicKey,String sign) throws Exception &#123;</span><br><span class="line">        return verify(getData(data),publicKey,sign);</span><br><span class="line">    &#125;</span><br><span class="line">    /***</span><br><span class="line">     * 校验数字签名</span><br><span class="line">     * @param data 加密数据</span><br><span class="line">     * @param publicKey 公钥</span><br><span class="line">     * @param sign 数据签名</span><br><span class="line">     * @return 校验成功返回true　失败返回false</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static boolean verify(byte[] data,String publicKey,String sign) throws Exception &#123;</span><br><span class="line">        // 　解密由base64编码的公钥</span><br><span class="line">        byte[] keyBytes = decryptBASE64(publicKey);</span><br><span class="line">        // 　构造X509EncodedKeySpec对象</span><br><span class="line">        X509EncodedKeySpec keySpec = new X509EncodedKeySpec(keyBytes);</span><br><span class="line">        // 　ALGORITHM　指定的加密算法</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(Algorithm_DSA);</span><br><span class="line">        // 　取公钥匙对象</span><br><span class="line">        PublicKey pubKey = keyFactory.generatePublic(keySpec);</span><br><span class="line">        Signature signature = Signature.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        signature.initVerify(pubKey);</span><br><span class="line">        signature.update(data);</span><br><span class="line">        // 　验证签名是否正常</span><br><span class="line">        return signature.verify(decryptBASE64(sign));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 默认生成密钥</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static Map initKey() throws Exception &#123;</span><br><span class="line">        return initKey(default_seed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 取得私钥</span><br><span class="line">     * @param keyMap</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static String getPrivateKey(Map keyMap)throws Exception &#123;</span><br><span class="line">        Key key = (Key) keyMap.get(private_key);</span><br><span class="line">        return encryptBASE64(key.getEncoded());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 取得公钥</span><br><span class="line">     * @param keyMap</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static String getPublicKey(Map keyMap) throws Exception &#123;</span><br><span class="line">        Key key = (Key) keyMap.get(public_key);</span><br><span class="line">        return encryptBASE64(key.getEncoded());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * BASE64解密</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static byte[] decryptBASE64(String key) throws Exception &#123;</span><br><span class="line">        return (new BASE64Decoder()).decodeBuffer(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * BASE64 加密</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static String encryptBASE64(byte[] key) throws Exception &#123;</span><br><span class="line">        return (new BASE64Encoder()).encodeBuffer(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static byte[] getData(Object obj) throws IllegalAccessException &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">        //遍历本类</span><br><span class="line">        Class cls = obj.getClass();</span><br><span class="line">        Field[] fields = cls.getDeclaredFields();</span><br><span class="line">        for (Field f : fields) &#123;</span><br><span class="line">            f.setAccessible(true);</span><br><span class="line">            if (f.get(obj) != null &amp;&amp; f.get(obj) != &quot;&quot; &amp;&amp; !f.getName().equals(&quot;sign&quot;) &amp;&amp; !f.getName().equals(&quot;caller&quot;)) &#123;</span><br><span class="line">                list.add(f.getName() + &quot;=&quot; + f.get(obj) + &quot;&amp;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //遍历超类</span><br><span class="line">        Class superclass = cls.getSuperclass();</span><br><span class="line">        Field[] superclassfields = superclass.getDeclaredFields();</span><br><span class="line">        for (Field f : superclassfields) &#123;</span><br><span class="line">            f.setAccessible(true);</span><br><span class="line">            if (f.get(obj) != null &amp;&amp; f.get(obj) != &quot;&quot; &amp;&amp; !f.getName().equals(&quot;sign&quot;) &amp;&amp; !f.getName().equals(&quot;caller&quot;)) &#123;</span><br><span class="line">                list.add(f.getName() + &quot;=&quot; + f.get(obj) + &quot;&amp;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int size = list.size();</span><br><span class="line">        String[] arrayToSort = list.toArray(new String[size]);</span><br><span class="line">        Arrays.sort(arrayToSort, String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            sb.append(arrayToSort[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        String result = sb.toString();</span><br><span class="line">        result = result.substring(0,result.length() -1);</span><br><span class="line">        System.err.println(result);</span><br><span class="line">        return result.getBytes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line"></span><br><span class="line">        CashierPrepayReq obj = new CashierPrepayReq();</span><br><span class="line">        obj.setOrderNo(&quot;111111&quot;);</span><br><span class="line">        obj.setPayChannel(2);</span><br><span class="line">        obj.setProductLine(&quot;auto&quot;);</span><br><span class="line">        obj.setOrderBody(&quot;测试&quot;);</span><br><span class="line">        obj.setSubject(&quot;测试&quot;);</span><br><span class="line">        obj.setOrderOwnerUserId(&quot;999&quot;);</span><br><span class="line">        obj.setTotalFee(1L);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;入参实体类:&quot;+obj.toString());</span><br><span class="line"></span><br><span class="line">        byte[] data = getData(obj);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String inputStr = &quot;Hello,你好啊！&quot;;</span><br><span class="line">        //byte[] data = inputStr.getBytes();</span><br><span class="line">        // 构建密钥</span><br><span class="line">        Map&lt;String, Object&gt; keyMap = DSASignaureUtil.initKey();</span><br><span class="line">        // 获得密钥</span><br><span class="line">        String publicKey = DSASignaureUtil.getPublicKey(keyMap);</span><br><span class="line">        String privateKey = DSASignaureUtil.getPrivateKey(keyMap);</span><br><span class="line">        System.err.println(&quot;公钥:\r&quot; + publicKey);</span><br><span class="line">        System.err.println(&quot;私钥:\r&quot; + privateKey);</span><br><span class="line">        // 产生签名</span><br><span class="line">        String sign = DSASignaureUtil.sign(data, privateKey);</span><br><span class="line">        System.err.println(&quot;签名:\r&quot; + sign);</span><br><span class="line">        // 验证签名</span><br><span class="line">        boolean status = DSASignaureUtil.verify(data, publicKey, sign);</span><br><span class="line">        System.err.println(&quot;状态:\r&quot; + status);</span><br><span class="line">        if(status)&#123;</span><br><span class="line">            System.out.println(&quot;原文:&quot;+new String(data));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以后，还要讨论收银台的稳定性（服务器宕机就没办法收钱？）、扩展性（需求如何快速加入？）、<br>统一性（收银台几个子系统操作步骤如何规划统一？）、高效性（用户体验？？）等等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本次总结主要以技术为主，到了6月30号了，转眼间，收银台项目已经建立起来有两个多月了，&lt;br&gt;从刚开始的我负责，到两个人负责，现在是4个人负责，建立起来了支付组。后边还得继续&lt;br&gt;招小伙伴，很累，但也收获很多，现在收银台包含支付网关、券系统、账户系统、交易系统、&lt;br&gt;收银台入口等多个模块，说白了，只要涉及到钱的功能，都得过我们这一边。废话不多说，&lt;br&gt;技术撸上：&lt;br&gt;
    
    </summary>
    
    
      <category term="安全" scheme="https://ouzhrm.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>秒杀系统的设计与实践《一》</title>
    <link href="https://ouzhrm.github.io/2018/05/20/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8A%E4%B8%80%E3%80%8B/"/>
    <id>https://ouzhrm.github.io/2018/05/20/秒杀系统的设计与实践《一》/</id>
    <published>2018-05-20T08:24:58.000Z</published>
    <updated>2018-05-20T08:40:06.401Z</updated>
    
    <content type="html"><![CDATA[<p>秒杀系统的设计思路。</p><p>1、下单过程：<br>校验库存<br>更新库存<br>创建订单<br>支付（本文暂先不考虑）<br><a id="more"></a><br>2、表的概要设计<br>库存表：id、名称、库存数、已售数，版本号（防止超卖）。<br>订单表：id、订单名称、库存表id，订单创建时间。</p><p>3、考虑到的问题。<br>首先，超卖问题，也就是说原来计划最大卖30个，结果卖了1000多个。<br>解决方法：采用乐观锁(CAS,比较并交换的意思，只有比较相等才能交换，否则不交换)。<br>更新库存的数据库语句可以这么设计，<br>update 库存表 set 版本号= 版本号+1,已售数 = 已售数+1<br>where 版本号 = 版本号 and id = 传过来的id<br>注：version_old_query是通过id查询出来的。</p><p>其次，数据库宕机和系统报错（查询数据库因为版本号不对，更新库存失败导致的报错）的问题，<br>数据库宕机往往是连接数不够导致的宕机，毕竟并发数比较大。<br>解决方法：限流+缓存。本身redis有限流，快速失败返回的策略，也就是限制访问数，每次访问<br>数只能是固定的，如果访问不到，则直接返回，这个限流类似java的信号量这个类。通过和<br>springmvc集成即可，而采用先查缓存，缓存里如果没有则去查数据库，这样，通过redis限流<br>把大部分流量拦截在上游，使之不能到达数据库，缓存提高查询效率等。很好的解决了数据层的<br>访问问题了，但redis最好采用集群的模式，毕竟秒杀的访问量还是很大的，我认为redis的限流<br>措施往往起到的保护系统的作用，限流最好用nginx、springcloud或者dubbo横向扩展来实现。</p><p>最后，如果进来到下单的并发量还是很大，可以将同步下单改成异步下单的形式。<br>解决方法：采用kafka发送库存的实体，然后马上返回，kafka和springboot集成的消费端，<br>采用线程池消费任务,对库存进行缓存和落地更新及创建订单，然后回调通知。</p><p>—— 未完待续 ——</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;秒杀系统的设计思路。&lt;/p&gt;
&lt;p&gt;1、下单过程：&lt;br&gt;校验库存&lt;br&gt;更新库存&lt;br&gt;创建订单&lt;br&gt;支付（本文暂先不考虑）&lt;br&gt;
    
    </summary>
    
    
      <category term="秒杀" scheme="https://ouzhrm.github.io/tags/%E7%A7%92%E6%9D%80/"/>
    
      <category term="并发" scheme="https://ouzhrm.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="电商" scheme="https://ouzhrm.github.io/tags/%E7%94%B5%E5%95%86/"/>
    
      <category term="订单" scheme="https://ouzhrm.github.io/tags/%E8%AE%A2%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>做收银台模块的经验总结</title>
    <link href="https://ouzhrm.github.io/2018/05/09/%E5%81%9A%E6%94%B6%E9%93%B6%E5%8F%B0%E6%A8%A1%E5%9D%97%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    <id>https://ouzhrm.github.io/2018/05/09/做收银台模块的经验总结/</id>
    <published>2018-05-09T09:37:10.000Z</published>
    <updated>2018-05-20T08:37:15.348Z</updated>
    
    <content type="html"><![CDATA[<p>1、仔细阅读官方文档，如预支付、退款、支付回调、查询模块，相关的请求参数、响应<br>参数以及开发的步骤，api字典等，还有应用公私密钥的生成方式（2048长度、java适用）、<br>注意应用公钥、应用私钥、支付宝公钥这几个别搞混了。<br><a id="more"></a><br>2、引进alipay sdk包的最好用maven方式。不要单独添加到项目来，然后build path<br>依赖一下，不然上线的时候会有很多的麻烦，报ClassNotFound等很多异常。<br>3、公网内网的问题，在回调响应的时候，如果配置成内网的地址，外网会访问不进来的，<br>所以最好配成域名的格式，这里困了大半天，晕。。。<br>4、app支付相关，如果只申请app支付的方式，那么只能用app支付，用官方的android或<br>者ios的demo支付，不然会根据订单号查询不出来，显示这个记录不存在。<br>5、java获取linux和windows系统当前ip的方式是不同的，如果想动态配置ip地址的，<br>这个最好了解一下。</p><p>————-     未完待续    —————</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、仔细阅读官方文档，如预支付、退款、支付回调、查询模块，相关的请求参数、响应&lt;br&gt;参数以及开发的步骤，api字典等，还有应用公私密钥的生成方式（2048长度、java适用）、&lt;br&gt;注意应用公钥、应用私钥、支付宝公钥这几个别搞混了。&lt;br&gt;
    
    </summary>
    
    
      <category term="支付" scheme="https://ouzhrm.github.io/tags/%E6%94%AF%E4%BB%98/"/>
    
  </entry>
  
</feed>
