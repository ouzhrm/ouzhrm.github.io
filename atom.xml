<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kevin Chow&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ouzhrm.github.io/"/>
  <updated>2018-07-24T03:28:21.820Z</updated>
  <id>https://ouzhrm.github.io/</id>
  
  <author>
    <name>Kevin Chow</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mybatis源码分析《一》 - 整体结构</title>
    <link href="https://ouzhrm.github.io/2018/07/24/mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%8A%E4%B8%80%E3%80%8B-%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84/"/>
    <id>https://ouzhrm.github.io/2018/07/24/mybatis源码分析《一》-整体结构/</id>
    <published>2018-07-24T03:09:58.000Z</published>
    <updated>2018-07-24T03:28:21.820Z</updated>
    
    <content type="html"><![CDATA[<p>在学习mybatis之前我们先了解一下jdbc。<br>Jdbc操作数据库的步骤：<br>1、    加载驱动<br>2、    获取数据库连接<br>3、    根据数据库连接操作数据库，实现增删改查<br>4、    关闭资源。<br><a id="more"></a><br>举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">String URL = &quot;jdbc:mysql://127.0.0.1:3306/bootdo?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;;</span><br><span class="line">String USER = &quot;root&quot;;</span><br><span class="line">String PASSWORD = &quot;root&quot;;</span><br><span class="line">//1.加载驱动程序</span><br><span class="line">try &#123;</span><br><span class="line">    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">//2.获得数据库链接</span><br><span class="line">Connection conn = DriverManager.getConnection(URL, USER, PASSWORD);</span><br><span class="line">//3.通过数据库的连接操作数据库，实现增删改查（使用Statement类）</span><br><span class="line">Statement st = conn.createStatement();</span><br><span class="line"></span><br><span class="line">ResultSet resultSet = st.executeQuery(&quot;select * from student&quot;);</span><br><span class="line">long age = 0;</span><br><span class="line">while (resultSet.next()) &#123;</span><br><span class="line">    age = resultSet.getLong(&quot;age&quot;);</span><br><span class="line">    age++;</span><br><span class="line">&#125;</span><br><span class="line">boolean rs = st.execute(&quot;update student set age = &quot; + age + &quot; where id = 13&quot;);</span><br><span class="line">System.out.println(rs);</span><br><span class="line">//关闭资源</span><br><span class="line">st.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure></p><p>mybatis是由jdbc演变而来的，目的是简化jdbc操作步骤，提高jdbc操作性能。</p><h4 id="mybatis解决了jdbc的什么问题？"><a href="#mybatis解决了jdbc的什么问题？" class="headerlink" title="mybatis解决了jdbc的什么问题？"></a>mybatis解决了jdbc的什么问题？</h4><p>1、    使用连接池代替了获取数据库连接，有效的循环利用连接资源。<br>我们知道，以mysql为例，如果mysql的连接数大于设置的最大连接数，就会因资源占用<br>而导致数据库宕机。<br>我们可以修改mysql最大连接数：打开my.ini，修改max_connections=100(默认为100)。<br>此外还有执行sql来设置最大连接数，此处就不多讲。<br>2、    操作方便，使用简单，简单数据库操作可以使用面向接口编程，特别适合一些大型<br>企业项目，减少重复性代码。<br>3、    待补充。。</p><h4 id="mybatis的整体结构"><a href="#mybatis的整体结构" class="headerlink" title="mybatis的整体结构"></a>mybatis的整体结构</h4><p>在分析mybatis源码之前，我们先看看mybatis的整体结构，这样在深入读源码的时候不会绕晕。<br>mybatis可以整体分成四层分析。</p><p>接口层，也是最上层，提供了给咋们用的增删改查的接口，而接口的调用方式分成，<br>第一种基于Mapper接口，也就是我们常常说的dao层映射到xml映射文件，或者采用<br>注解的形式，接口化编程的风格，也是我们集成spring的时候最常用的一种形式。<br>此外第二种是mybatis传统的调用方式，如sqlSession.selectList(statementId， Map形式的参数)，<br>statementId一般是类的全限定名。</p><p>数据处理层，分别是参数映射，sql解析，sql执行，结果集映射。参数映射是java数据格式转<br>化成sql参数格式，期间也会通过TypeHandler来操作java格式和sql格式参数之间的转换。但<br>主要的操作是在ParameterHandler这个类中进行的。它会调起TypeHandler进行操作。Sql解析，<br>也就是将sql和参数拼凑起来形成一个完整的可执行的sql，它的操作是在sqlSource中进行的。<br>而sql执行，是在Executor类中执行的，它底层封装了Statement相关实现类。调用的是statement<br>类的execute方法或者是executeQuery方法。最后是结果集映射，我们知道jdbc执行sql后生成的<br>结果集，我们还得自己去转成java数据格式或者封装对象属性相关的数据。这时mybatis提供了<br>结果集映射成java类型的ResultSetHandler类，期间也会调用TypeHandler来完成原生结果集转<br>换成我们想要的java数据格式。</p><p>框架支撑层，无非就是连接池、事务、和缓存，这些来支撑我们执行sql提供了一系列相关的保障。<br>连接池保证了咋们的宝贵的连接资源可重复利用。事务保证了执行sql的一致性、隔离性、永久性、</p><p>原子性。缓存提高了相同查询结果的性能。<br>引导层，不多说了，怎么用这个框架，引导去用的相关问题。</p><h4 id="下面是结构图："><a href="#下面是结构图：" class="headerlink" title="下面是结构图："></a>下面是结构图：</h4><p><img src="/images/jiegoutu.png" alt="图片不存在了，请联系博主更新图片"></p><h4 id="下面是各层次的调用图。"><a href="#下面是各层次的调用图。" class="headerlink" title="下面是各层次的调用图。"></a>下面是各层次的调用图。</h4><p><img src="/images/cengcidiaoyongtu.png" alt="图片不存在了，请联系博主更新图片"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在学习mybatis之前我们先了解一下jdbc。&lt;br&gt;Jdbc操作数据库的步骤：&lt;br&gt;1、    加载驱动&lt;br&gt;2、    获取数据库连接&lt;br&gt;3、    根据数据库连接操作数据库，实现增删改查&lt;br&gt;4、    关闭资源。&lt;br&gt;
    
    </summary>
    
    
      <category term="mybatis" scheme="https://ouzhrm.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>代码规范的一些总结</title>
    <link href="https://ouzhrm.github.io/2018/07/10/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/"/>
    <id>https://ouzhrm.github.io/2018/07/10/代码规范的一些总结/</id>
    <published>2018-07-10T09:41:09.000Z</published>
    <updated>2018-07-10T09:43:25.008Z</updated>
    
    <content type="html"><![CDATA[<p>IDEA先安装alibaba coding插件和FindBug的插件。<br>然后下面的一些问题：<br>阿里巴巴代码规范插件扫描出来的问题：</p><p>1、不能name.equals(“”)，而应该””.equals(name) ，否则容易报空指针<br><a id="more"></a><br>2、不能这样写：<br>if(x&gt;1) return msg;<br>或者<br>if(x&gt;1)<br>return msg;<br>应该<br>if(x&gt;1){<br>return msg;<br>}</p><p>3、不能使用过时的类和方法<br>如：org.apache.http.conn.ssl.SSLContexts这个类已经过时了</p><p>4、常量因为都是大写<br>如：<br>public static final String Algorithm_Dsa= “DSA”;<br>而应该：<br>public static final String ALGORITHM_DSA = “DSA”;</p><p>5、变量应该遵循驼峰<br>如：public static String sign(Object data, String private_key) throws Exception {}<br>而应该<br>public static String sign(Object data, String privateKey) throws Exception {}</p><p>6、long型常量应该以大写L结尾<br>如：public static final long TIME_LENGTH= 864000l;<br>而应该：<br>public static final long TIME_LENGTH= 864000L;</p><p>7、重写equals()、toString()、hashcode()方法上方应该加@Override</p><p>8、枚举类对应的字段都要加上注释，不然以后自己都可能会忘记。</p><p>9、集合初始化时，应该指定集合初始值大小。如果HashMap不填默认长度为16，默认阈值为0.75，一旦超过12个元素就会触发扩容。<br>毕竟集合扩容也挺耗性能的嘛</p><p>10、所有类都必须添加创建者信息，不然出了问题不好确定时，还得去git上查历史记录。</p><p>11、等等….</p><p>此外还有FindBugs插件的使用，这里具体就不说了，挺好用额，扫出来的问题能更好的提高代码的健壮性。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;IDEA先安装alibaba coding插件和FindBug的插件。&lt;br&gt;然后下面的一些问题：&lt;br&gt;阿里巴巴代码规范插件扫描出来的问题：&lt;/p&gt;
&lt;p&gt;1、不能name.equals(“”)，而应该””.equals(name) ，否则容易报空指针&lt;br&gt;
    
    </summary>
    
    
      <category term="代码规范" scheme="https://ouzhrm.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>数据传输中的安全性的一点思考</title>
    <link href="https://ouzhrm.github.io/2018/06/30/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/"/>
    <id>https://ouzhrm.github.io/2018/06/30/数据传输中的安全性的一点思考/</id>
    <published>2018-06-30T04:20:55.000Z</published>
    <updated>2018-07-01T07:17:30.292Z</updated>
    
    <content type="html"><![CDATA[<p>本次总结主要以技术为主，到了6月30号了，转眼间，收银台项目已经建立起来有两个多月了，<br>从刚开始的我负责，到两个人负责，现在是4个人负责，建立起来了支付组。后边还得继续<br>招小伙伴，很累，但也收获很多，现在收银台包含支付网关、券系统、账户系统、交易系统、<br>收银台入口等多个模块，说白了，只要涉及到钱的功能，都得过我们这一边。废话不多说，<br>技术撸上：<br><a id="more"></a><br>首先是安全性，收银台跟钱相关的，所以我们把安全性作为项目第一位考虑的，数据对内部<br>要防篡改，对外部数据传输要加密，为什么安全性排第一位呢？就是数据传输过程中，黑客把数据<br>拦截了下来，然后对数据进行一番改造，假设充值时，把0.1元字段改成10000元，黑客实际支付了<br>0.1元，然后在提现时就可能提出10000元来，当然这是简单的假设举例，而实际上提现更为复杂，<br>经过多重校验和多重审核。我们实现的是防篡改和防破解的思想是这样的：先用工具生成非对称性的<br>公私钥对，私钥加密，公钥解密，数据在网络传输前先用私钥加密，到达服务端时用公钥解密，而防<br>破解私钥，我们在数据的传输前加入一个随机数字段，这样保证每一次密文都是不一样的。但我们如<br>果供对内部的系统调用则主要是防篡改，干货来了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></td><td class="code"><pre><span class="line">package com.carlife.common.sign.utils;</span><br><span class="line"></span><br><span class="line">import com.carlife.cashier.vo.CashierPrepayReq;</span><br><span class="line">import sun.misc.BASE64Decoder;</span><br><span class="line">import sun.misc.BASE64Encoder;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.security.*;</span><br><span class="line">import java.security.interfaces.DSAPrivateKey;</span><br><span class="line">import java.security.interfaces.DSAPublicKey;</span><br><span class="line">import java.security.spec.PKCS8EncodedKeySpec;</span><br><span class="line">import java.security.spec.X509EncodedKeySpec;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 签名验签算法:DSA</span><br><span class="line"> * 1、生成密钥对</span><br><span class="line"> * 2、签名</span><br><span class="line"> * 3、验签</span><br><span class="line"> */</span><br><span class="line">public class DSASignaureUtil &#123;</span><br><span class="line">    public static final String  Algorithm_DSA=&quot;DSA&quot;;</span><br><span class="line">    //默认密钥字节数</span><br><span class="line">    private static final int key_size=1024;</span><br><span class="line">    //默认种子</span><br><span class="line">    public static final String default_seed=&quot;0f22507a10bbddd07d8a3082122966e3&quot;;</span><br><span class="line"></span><br><span class="line">    public static final String public_key = &quot;DSAPublicKey&quot;;</span><br><span class="line">    public static final String private_key = &quot;DSAPrivateKey&quot;;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 生成密钥种子</span><br><span class="line">     * @param seed</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static Map initKey(String seed) throws Exception&#123;</span><br><span class="line">        KeyPairGenerator keygen = KeyPairGenerator.getInstance(Algorithm_DSA);</span><br><span class="line">        //　初始化随机产生器</span><br><span class="line">        SecureRandom secureRandom = new SecureRandom();</span><br><span class="line">        secureRandom.setSeed(seed.getBytes());</span><br><span class="line">        keygen.initialize(key_size,secureRandom);</span><br><span class="line">        KeyPair keys = keygen.genKeyPair();</span><br><span class="line">        DSAPublicKey publicKey = (DSAPublicKey) keys.getPublic();</span><br><span class="line">        DSAPrivateKey privateKey = (DSAPrivateKey) keys.getPrivate();</span><br><span class="line">        Map map = new HashMap(2);</span><br><span class="line">        map.put(public_key,publicKey);</span><br><span class="line">        map.put(private_key,privateKey);</span><br><span class="line"></span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * description: 加签名方法 &lt;p&gt;</span><br><span class="line">    * param: [data, private_key] &lt;p&gt;</span><br><span class="line">    * return: java.lang.String &lt;p&gt;</span><br><span class="line">    * author: shicong yang&lt;p&gt;</span><br><span class="line">    * date: 2018/6/28 &lt;p&gt;</span><br><span class="line">    */</span><br><span class="line">    public static String sign(Object data,String private_key)throws Exception&#123;</span><br><span class="line">       return  sign(getData(data),private_key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 用私钥对信息生成数字签名</span><br><span class="line">     * @param data 加密数据</span><br><span class="line">     * @param privateKey 私钥</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static String sign(byte[] data,String privateKey)throws Exception&#123;</span><br><span class="line">        //　解密由base64编码的私钥</span><br><span class="line">        byte[] keyBytes = decryptBASE64(privateKey);</span><br><span class="line">        //　构造PKCS8EncodedKeySpec对象</span><br><span class="line">        //PKCS#8:描述私有密钥信息格式，该信息包括公开密钥算法的私有密钥以及可选的属性集等[27]。</span><br><span class="line">        PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes);</span><br><span class="line">        //　KEY_ALGORITHM　指定的加密算法</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(Algorithm_DSA);</span><br><span class="line">        //　取私钥匙对象</span><br><span class="line">        PrivateKey priKey = keyFactory.generatePrivate(pkcs8KeySpec);</span><br><span class="line">        //用私钥对信息生成数字签名</span><br><span class="line">        Signature signature = Signature.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        signature.initSign(priKey);</span><br><span class="line">        signature.update(data);</span><br><span class="line"></span><br><span class="line">        return encryptBASE64(signature.sign());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean verify(Object data,String publicKey,String sign) throws Exception &#123;</span><br><span class="line">        return verify(getData(data),publicKey,sign);</span><br><span class="line">    &#125;</span><br><span class="line">    /***</span><br><span class="line">     * 校验数字签名</span><br><span class="line">     * @param data 加密数据</span><br><span class="line">     * @param publicKey 公钥</span><br><span class="line">     * @param sign 数据签名</span><br><span class="line">     * @return 校验成功返回true　失败返回false</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static boolean verify(byte[] data,String publicKey,String sign) throws Exception &#123;</span><br><span class="line">        // 　解密由base64编码的公钥</span><br><span class="line">        byte[] keyBytes = decryptBASE64(publicKey);</span><br><span class="line">        // 　构造X509EncodedKeySpec对象</span><br><span class="line">        X509EncodedKeySpec keySpec = new X509EncodedKeySpec(keyBytes);</span><br><span class="line">        // 　ALGORITHM　指定的加密算法</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(Algorithm_DSA);</span><br><span class="line">        // 　取公钥匙对象</span><br><span class="line">        PublicKey pubKey = keyFactory.generatePublic(keySpec);</span><br><span class="line">        Signature signature = Signature.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        signature.initVerify(pubKey);</span><br><span class="line">        signature.update(data);</span><br><span class="line">        // 　验证签名是否正常</span><br><span class="line">        return signature.verify(decryptBASE64(sign));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 默认生成密钥</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static Map initKey() throws Exception &#123;</span><br><span class="line">        return initKey(default_seed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 取得私钥</span><br><span class="line">     * @param keyMap</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static String getPrivateKey(Map keyMap)throws Exception &#123;</span><br><span class="line">        Key key = (Key) keyMap.get(private_key);</span><br><span class="line">        return encryptBASE64(key.getEncoded());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 取得公钥</span><br><span class="line">     * @param keyMap</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static String getPublicKey(Map keyMap) throws Exception &#123;</span><br><span class="line">        Key key = (Key) keyMap.get(public_key);</span><br><span class="line">        return encryptBASE64(key.getEncoded());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * BASE64解密</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static byte[] decryptBASE64(String key) throws Exception &#123;</span><br><span class="line">        return (new BASE64Decoder()).decodeBuffer(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * BASE64 加密</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static String encryptBASE64(byte[] key) throws Exception &#123;</span><br><span class="line">        return (new BASE64Encoder()).encodeBuffer(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static byte[] getData(Object obj) throws IllegalAccessException &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">        //遍历本类</span><br><span class="line">        Class cls = obj.getClass();</span><br><span class="line">        Field[] fields = cls.getDeclaredFields();</span><br><span class="line">        for (Field f : fields) &#123;</span><br><span class="line">            f.setAccessible(true);</span><br><span class="line">            if (f.get(obj) != null &amp;&amp; f.get(obj) != &quot;&quot; &amp;&amp; !f.getName().equals(&quot;sign&quot;) &amp;&amp; !f.getName().equals(&quot;caller&quot;)) &#123;</span><br><span class="line">                list.add(f.getName() + &quot;=&quot; + f.get(obj) + &quot;&amp;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //遍历超类</span><br><span class="line">        Class superclass = cls.getSuperclass();</span><br><span class="line">        Field[] superclassfields = superclass.getDeclaredFields();</span><br><span class="line">        for (Field f : superclassfields) &#123;</span><br><span class="line">            f.setAccessible(true);</span><br><span class="line">            if (f.get(obj) != null &amp;&amp; f.get(obj) != &quot;&quot; &amp;&amp; !f.getName().equals(&quot;sign&quot;) &amp;&amp; !f.getName().equals(&quot;caller&quot;)) &#123;</span><br><span class="line">                list.add(f.getName() + &quot;=&quot; + f.get(obj) + &quot;&amp;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int size = list.size();</span><br><span class="line">        String[] arrayToSort = list.toArray(new String[size]);</span><br><span class="line">        Arrays.sort(arrayToSort, String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            sb.append(arrayToSort[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        String result = sb.toString();</span><br><span class="line">        result = result.substring(0,result.length() -1);</span><br><span class="line">        System.err.println(result);</span><br><span class="line">        return result.getBytes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line"></span><br><span class="line">        CashierPrepayReq obj = new CashierPrepayReq();</span><br><span class="line">        obj.setOrderNo(&quot;111111&quot;);</span><br><span class="line">        obj.setPayChannel(2);</span><br><span class="line">        obj.setProductLine(&quot;auto&quot;);</span><br><span class="line">        obj.setOrderBody(&quot;测试&quot;);</span><br><span class="line">        obj.setSubject(&quot;测试&quot;);</span><br><span class="line">        obj.setOrderOwnerUserId(&quot;999&quot;);</span><br><span class="line">        obj.setTotalFee(1L);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;入参实体类:&quot;+obj.toString());</span><br><span class="line"></span><br><span class="line">        byte[] data = getData(obj);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String inputStr = &quot;Hello,你好啊！&quot;;</span><br><span class="line">        //byte[] data = inputStr.getBytes();</span><br><span class="line">        // 构建密钥</span><br><span class="line">        Map&lt;String, Object&gt; keyMap = DSASignaureUtil.initKey();</span><br><span class="line">        // 获得密钥</span><br><span class="line">        String publicKey = DSASignaureUtil.getPublicKey(keyMap);</span><br><span class="line">        String privateKey = DSASignaureUtil.getPrivateKey(keyMap);</span><br><span class="line">        System.err.println(&quot;公钥:\r&quot; + publicKey);</span><br><span class="line">        System.err.println(&quot;私钥:\r&quot; + privateKey);</span><br><span class="line">        // 产生签名</span><br><span class="line">        String sign = DSASignaureUtil.sign(data, privateKey);</span><br><span class="line">        System.err.println(&quot;签名:\r&quot; + sign);</span><br><span class="line">        // 验证签名</span><br><span class="line">        boolean status = DSASignaureUtil.verify(data, publicKey, sign);</span><br><span class="line">        System.err.println(&quot;状态:\r&quot; + status);</span><br><span class="line">        if(status)&#123;</span><br><span class="line">            System.out.println(&quot;原文:&quot;+new String(data));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以后，还要讨论收银台的稳定性（服务器宕机就没办法收钱？）、扩展性（需求如何快速加入？）、<br>统一性（收银台几个子系统操作步骤如何规划统一？）、高效性（用户体验？？）等等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本次总结主要以技术为主，到了6月30号了，转眼间，收银台项目已经建立起来有两个多月了，&lt;br&gt;从刚开始的我负责，到两个人负责，现在是4个人负责，建立起来了支付组。后边还得继续&lt;br&gt;招小伙伴，很累，但也收获很多，现在收银台包含支付网关、券系统、账户系统、交易系统、&lt;br&gt;收银台入口等多个模块，说白了，只要涉及到钱的功能，都得过我们这一边。废话不多说，&lt;br&gt;技术撸上：&lt;br&gt;
    
    </summary>
    
    
      <category term="安全" scheme="https://ouzhrm.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>秒杀系统的设计与实践《一》</title>
    <link href="https://ouzhrm.github.io/2018/05/20/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8A%E4%B8%80%E3%80%8B/"/>
    <id>https://ouzhrm.github.io/2018/05/20/秒杀系统的设计与实践《一》/</id>
    <published>2018-05-20T08:24:58.000Z</published>
    <updated>2018-05-20T08:40:06.401Z</updated>
    
    <content type="html"><![CDATA[<p>秒杀系统的设计思路。</p><p>1、下单过程：<br>校验库存<br>更新库存<br>创建订单<br>支付（本文暂先不考虑）<br><a id="more"></a><br>2、表的概要设计<br>库存表：id、名称、库存数、已售数，版本号（防止超卖）。<br>订单表：id、订单名称、库存表id，订单创建时间。</p><p>3、考虑到的问题。<br>首先，超卖问题，也就是说原来计划最大卖30个，结果卖了1000多个。<br>解决方法：采用乐观锁(CAS,比较并交换的意思，只有比较相等才能交换，否则不交换)。<br>更新库存的数据库语句可以这么设计，<br>update 库存表 set 版本号= 版本号+1,已售数 = 已售数+1<br>where 版本号 = 版本号 and id = 传过来的id<br>注：version_old_query是通过id查询出来的。</p><p>其次，数据库宕机和系统报错（查询数据库因为版本号不对，更新库存失败导致的报错）的问题，<br>数据库宕机往往是连接数不够导致的宕机，毕竟并发数比较大。<br>解决方法：限流+缓存。本身redis有限流，快速失败返回的策略，也就是限制访问数，每次访问<br>数只能是固定的，如果访问不到，则直接返回，这个限流类似java的信号量这个类。通过和<br>springmvc集成即可，而采用先查缓存，缓存里如果没有则去查数据库，这样，通过redis限流<br>把大部分流量拦截在上游，使之不能到达数据库，缓存提高查询效率等。很好的解决了数据层的<br>访问问题了，但redis最好采用集群的模式，毕竟秒杀的访问量还是很大的，我认为redis的限流<br>措施往往起到的保护系统的作用，限流最好用nginx、springcloud或者dubbo横向扩展来实现。</p><p>最后，如果进来到下单的并发量还是很大，可以将同步下单改成异步下单的形式。<br>解决方法：采用kafka发送库存的实体，然后马上返回，kafka和springboot集成的消费端，<br>采用线程池消费任务,对库存进行缓存和落地更新及创建订单，然后回调通知。</p><p>—— 未完待续 ——</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;秒杀系统的设计思路。&lt;/p&gt;
&lt;p&gt;1、下单过程：&lt;br&gt;校验库存&lt;br&gt;更新库存&lt;br&gt;创建订单&lt;br&gt;支付（本文暂先不考虑）&lt;br&gt;
    
    </summary>
    
    
      <category term="秒杀" scheme="https://ouzhrm.github.io/tags/%E7%A7%92%E6%9D%80/"/>
    
      <category term="并发" scheme="https://ouzhrm.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="电商" scheme="https://ouzhrm.github.io/tags/%E7%94%B5%E5%95%86/"/>
    
      <category term="订单" scheme="https://ouzhrm.github.io/tags/%E8%AE%A2%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>做收银台模块的经验总结</title>
    <link href="https://ouzhrm.github.io/2018/05/09/%E5%81%9A%E6%94%B6%E9%93%B6%E5%8F%B0%E6%A8%A1%E5%9D%97%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    <id>https://ouzhrm.github.io/2018/05/09/做收银台模块的经验总结/</id>
    <published>2018-05-09T09:37:10.000Z</published>
    <updated>2018-05-20T08:37:15.348Z</updated>
    
    <content type="html"><![CDATA[<p>1、仔细阅读官方文档，如预支付、退款、支付回调、查询模块，相关的请求参数、响应<br>参数以及开发的步骤，api字典等，还有应用公私密钥的生成方式（2048长度、java适用）、<br>注意应用公钥、应用私钥、支付宝公钥这几个别搞混了。<br><a id="more"></a><br>2、引进alipay sdk包的最好用maven方式。不要单独添加到项目来，然后build path<br>依赖一下，不然上线的时候会有很多的麻烦，报ClassNotFound等很多异常。<br>3、公网内网的问题，在回调响应的时候，如果配置成内网的地址，外网会访问不进来的，<br>所以最好配成域名的格式，这里困了大半天，晕。。。<br>4、app支付相关，如果只申请app支付的方式，那么只能用app支付，用官方的android或<br>者ios的demo支付，不然会根据订单号查询不出来，显示这个记录不存在。<br>5、java获取linux和windows系统当前ip的方式是不同的，如果想动态配置ip地址的，<br>这个最好了解一下。</p><p>————-     未完待续    —————</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、仔细阅读官方文档，如预支付、退款、支付回调、查询模块，相关的请求参数、响应&lt;br&gt;参数以及开发的步骤，api字典等，还有应用公私密钥的生成方式（2048长度、java适用）、&lt;br&gt;注意应用公钥、应用私钥、支付宝公钥这几个别搞混了。&lt;br&gt;
    
    </summary>
    
    
      <category term="支付" scheme="https://ouzhrm.github.io/tags/%E6%94%AF%E4%BB%98/"/>
    
  </entry>
  
  <entry>
    <title>再议索引</title>
    <link href="https://ouzhrm.github.io/2018/05/05/%E5%86%8D%E8%AE%AE%E7%B4%A2%E5%BC%95/"/>
    <id>https://ouzhrm.github.io/2018/05/05/再议索引/</id>
    <published>2018-05-05T10:23:03.000Z</published>
    <updated>2018-05-20T08:37:00.932Z</updated>
    
    <content type="html"><![CDATA[<h5 id="关于索引的使用"><a href="#关于索引的使用" class="headerlink" title="关于索引的使用"></a>关于索引的使用</h5><p>1、最适合建索引的列有：where后边的、联接（join）条件相关的列、<br>order by相关的列、group by 相关的列。<br>2、数据量区分度要大些，如男女数据量各占50%的就不需要建索引。<br><a id="more"></a><br>3、索引的长度(体积)尽可能的小。<br>4、复合索引要充分满足最左前缀。如：建的复合索引为</p><p>（state、city、zip），则能命中索引的条件有：<br>state、city、zip<br>state、city<br>state<br>5、索引建的数量要适当，因为索引多的话，查询快了，但是更新慢。<br>6、InnoDB，MYISAM总是使用B+树索引。MEMORY存储引擎默认使用Hash索引.<br>Hash索引在使用“=”，“&lt;=&gt;”比较快，范围查找比较慢，如：id&lt;30或者weight<br> between 100 and 150.而“B树”范围查找比较快</p><h5 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h5><p>1.普通索引 index<br>创建：CREATE INDEX index_name ON table(column(length))。<br>修改：ALTER TABLE table_name ADD INDEX index_name ON (column(length))<br>创建表的时候同时创建索引：<br>CREATE TABLE <code>table</code> (<br>    <code>id</code> int(11) NOT NULL AUTO_INCREMENT ,<br>    <code>title</code> char(255) CHARACTER NOT NULL ,<br>    <code>content</code> text CHARACTER NULL ,<br>    <code>time</code> int(10) NULL DEFAULT NULL ,<br>    PRIMARY KEY (<code>id</code>),<br>    INDEX index_name (title(length))<br>)<br>删除：DROP INDEX index_name ON table。</p><p>2.唯一索引 unique index<br>索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。<br>创建：CREATE UNIQUE INDEX indexName ON table(column(length))<br>修改：ALTER TABLE table_name ADD UNIQUE indexName ON (column(length))<br>创建表的时候直接指定：<br>CREATE TABLE <code>table</code> (<br>    <code>id</code> int(11) NOT NULL AUTO_INCREMENT ,<br>    <code>title</code> char(255) CHARACTER NOT NULL ,<br>    <code>content</code> text CHARACTER NULL ,<br>    <code>time</code> int(10) NULL DEFAULT NULL ,<br>    UNIQUE indexName (title(length))<br>);</p><p>3.主键索引 key index<br>CREATE TABLE <code>table</code> (<br>    <code>id</code> int(11) NOT NULL AUTO_INCREMENT ,<br>    <code>title</code> char(255) NOT NULL ,<br>    PRIMARY KEY (<code>id</code>)<br>);</p><p>4.组合索引<br>ALTER TABLE <code>table</code> ADD INDEX name_city_age (name,city,age); </p><p>5.全文索引 fulltext index<br>主要用来查找文本中的关键字，而不是直接与索引中的值相比较。<br>先建表后加全文索引比建表的同时创建全文索引，写入的速度要快很多。<br>CREATE FULLTEXT INDEX index_content ON article(content)</p><p>CREATE TABLE <code>table</code> (<br>    <code>id</code> int(11) NOT NULL AUTO_INCREMENT ,<br>    <code>title</code> char(255) CHARACTER NOT NULL ,<br>    <code>content</code> text CHARACTER NULL ,<br>    <code>time</code> int(10) NULL DEFAULT NULL ,<br>    PRIMARY KEY (<code>id</code>),<br>    FULLTEXT (content)<br>);</p><p>ALTER TABLE article ADD FULLTEXT index_content(content)。</p><h4 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h4><p>开启慢查询日志，可以让MySQL记录下查询超过指定时间的语句，<br>通过定位分析性能的瓶颈，才能更好的优化数据库系统的性能。</p><p>//查询mysql的查询相关的启动配置参数<br>show variables like ‘query%’;<br>set global slow_query_log=’ON’; //开启慢查询日志<br>//慢查询日志存放位置<br>set global slow_query_log_file=’/usr/local/mysql/data/slow.log’;<br>set global long_query_time=1;//查询超过1秒就记录</p><p>select sleep(4);//执行一条慢查询SQL语句</p><h4 id="MySQL索引方法"><a href="#MySQL索引方法" class="headerlink" title="MySQL索引方法"></a>MySQL索引方法</h4><p>MySQL目前主要有以下几种索引方法：B-Tree，Hash，R-Tree。</p><p>B-Tree索引<br>B-Tree是最常见的索引类型，所有值（被索引的列）都是<strong>排过序</strong>的，<br>每个叶节点到根节点距离相等。所以B-Tree适合用来查找某一<strong>范围</strong><br>内的数据，而且可以直接<strong>支持数据排序</strong>（ORDER BY）<br>B-Tree在MyISAM里的形式和Innodb稍有不同：<br>MyISAM表数据文件和索引文件是分离的，<strong>索引文件仅保存数据记录的磁盘地址</strong><br>InnoDB表数据文件本身就是主索引，叶节点data域保存了完整的数据记录</p><p>Hash索引<br>1.<strong>仅支持”=”,”IN”和”&lt;=&gt;”精确查询，不能使用范围查询</strong>：<br>2.<strong>不支持排序</strong>：<br>3.在任何时候都不能避免表扫描。<br>通过访问表中的实际数据进行相应的比较，并得到相应的结果。<br>4.检索效率<strong>高</strong>，索引的检索可以一次定位，Hash索引的查询效率要远高于B-Tree索引。<br>5.只有Memory引擎支持显式的Hash索引，它也支持B-Tree索引。</p><p>R-Tree索引<br>略</p><p>———–<a href="http://www.cnblogs.com/luyucheng/category/920876.html-------------" target="_blank" rel="noopener">http://www.cnblogs.com/luyucheng/category/920876.html-------------</a><br>——-未完，待续——-</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;关于索引的使用&quot;&gt;&lt;a href=&quot;#关于索引的使用&quot; class=&quot;headerlink&quot; title=&quot;关于索引的使用&quot;&gt;&lt;/a&gt;关于索引的使用&lt;/h5&gt;&lt;p&gt;1、最适合建索引的列有：where后边的、联接（join）条件相关的列、&lt;br&gt;order by相关的列、group by 相关的列。&lt;br&gt;2、数据量区分度要大些，如男女数据量各占50%的就不需要建索引。&lt;br&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="https://ouzhrm.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>工作中如何做好知识积累</title>
    <link href="https://ouzhrm.github.io/2018/04/25/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/"/>
    <id>https://ouzhrm.github.io/2018/04/25/工作中如何做好知识积累/</id>
    <published>2018-04-25T01:54:32.000Z</published>
    <updated>2018-05-20T08:36:20.959Z</updated>
    
    <content type="html"><![CDATA[<p>今天在网上本身奔着美团点评的sql索引优化工具去的，在它们的博客找了找，<br>无意中浏览到<a href="https://tech.meituan.com/study_vs_work.html" target="_blank" rel="noopener">工作中如何做好技术积累</a>这篇文章，好奇心让我点开看了一遍。<br>发现有些还是可以借鉴的，但是有一些让人无法琢磨的，也就是说一半留一半的感觉，<br><a id="more"></a><br>作为同行，都是程序员，这点我是不太喜欢的。下面是我读这篇文章的一些小小总结。<br>1、重视基础理论知识，万变不离其宗。（20%的时间）<br>2、重视工作中的实践。（70%的时间）<br>3、实践中解决问题可以通过博客记录或者分享出来。<br>4、项目最好积极讨论，毕竟和高手过招的机会不是很多。<br>5、项目的空档期，要提高项目的深度，多方位考虑系统的健壮性，可扩展性（功能的增减对系统的影响），<br>可伸缩性（线上服务器的增减对系统的影响）等。注：这点是我读这篇文章收获最大的。<br>6、架构师的几种能力：在线运维、性能优化、架构设计、编程能力</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在网上本身奔着美团点评的sql索引优化工具去的，在它们的博客找了找，&lt;br&gt;无意中浏览到&lt;a href=&quot;https://tech.meituan.com/study_vs_work.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;工作中如何做好技术积累&lt;/a&gt;这篇文章，好奇心让我点开看了一遍。&lt;br&gt;发现有些还是可以借鉴的，但是有一些让人无法琢磨的，也就是说一半留一半的感觉，&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://ouzhrm.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://ouzhrm.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>mysql执行计划</title>
    <link href="https://ouzhrm.github.io/2018/04/24/mysql%20%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/"/>
    <id>https://ouzhrm.github.io/2018/04/24/mysql 执行计划/</id>
    <published>2018-04-24T02:21:51.000Z</published>
    <updated>2018-05-20T08:35:30.414Z</updated>
    
    <content type="html"><![CDATA[<p>实际项目开发中，由于我们不知道实际查询的时候数据库里发生了什么事情，<br>数据库软件是怎样扫描表、怎样使用索引的，因此，在写sql语句的时候就<br>很少考虑到性能的问题。但是当数据规模增大，如千万、亿的时候，我们运<br><a id="more"></a><br>行同样的sql语句时却发现迟迟没有结果，这个时候才知道数据规模已经限<br>制了我们查询的速度。所以，查询优化和索引也就显得很重要了。</p><p>MySql提供了EXPLAIN语法用来进行查询分析，在SQL语句前加一个”EXPLAIN”<br>即可。<br>如：explain select * from table where table.id = 1 </p><p>运行上面的sql语句后你会看到，下面的表头信息：<br>id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra</p><p>id : id列数字越大越先执行，如果说数字一样大，那么就从上往下依次执行</p><p>(select_type看不懂的，可以了解一下即可)<br>select_type列常见的有：<br>A：simple：表示不需要union操作或者不包含子查询的简单select查询。<br>有连接查询时，外层的查询为simple，且只有一个。<br>B：primary：一个需要union操作或者含有子查询的select，位于最外层的<br>单位查询的select_type即为primary。且只有一个。<br>C：union：union连接的两个select查询，第一个查询是dervied派生表，除<br>了第一个表外，第二个以后的表select_type都是union。<br>D：dependent union：与union一样，出现在union 或union all语句中，但<br>是这个查询要受到外部查询的影响。<br>E：union result：包含union的结果集，在union和union all语句中,因为它<br>不需要参与查询，所以id字段为null。<br>F：subquery：除了from字句中包含的子查询外，其他地方出现的子查询都可<br>能是subquery。<br>G：dependent subquery：与dependent union类似，表示这个subquery的查询<br>要受到外部表查询的影响。<br>H：derived：from字句中出现的子查询，也叫做派生表，其他数据库中可能叫<br>做内联视图或嵌套select。</p><p>table ：显示这一行的数据是关于哪张表的。</p><p>type ：显示连接使用了何种类型。从最好到最差的连接类型为const、<br>eq_ref、ref、range、index和ALL。</p><p>const： 表示通过索引一次就找到了。</p><p>eq_ref： 联表操作，外表的一条元组，内表只有唯一一条元组与之对应。</p><p>ref：  联表操作，外表的一条元组，内表可有若干条元组与之对应。</p><p>range： 表示这个连接类型使用索引返回一个范围中的行，比如使<br>用BETWEEN，IN，&gt;=，LIKE等查找东西时发生的情况。</p><p>index：索引全表扫描，把索引从头到尾扫一遍。</p><p>all： 表示为全表扫描； </p><p>possible_keys：查询可能使用到的索引都会在这里列出来</p><p>key :显示MySQL实际决定使用的键。如果没有索引被选择，键是NULL。<br>key=primary的话，表示使用了主键；<br>key=null表示没用到索引。    </p><p>key_len:显示MySQL决定使用的键长度，表示索引中使用的字节数。</p><p>ref ：如果是使用的常数等值查询，这里会显示const；如果是连<br>接查询，被驱动表的执行计划这里会显示驱动表的关联字段；如<br>果是条件使用了表达式或者函数，或者条件列发生了内部隐式转<br>换，这里可能显示为func。</p><p>rows：这里是执行计划中估算的扫描行数，不是精确值    </p><p>extra：关于MYSQL如何解析查询的额外信息。<br>这里可以看到的坏的例子是Using temporary和Using filesort，<br>意思MYSQL根本不能使用索引，结果是检索会很慢。</p><p>这个列可以显示的信息非常多，有几十种，常用的有<br>A：distinct：在select部分使用了distinc关键字</p><p>B：no tables used：不带from字句的查询或者From dual查询</p><p>C：使用not in()形式子查询或not exists运算符的连接查询，<br>这种叫做反连接。即，一般连接查询是先查询内表，再查询外<br>表，反连接就是先查询外表，再查询内表。</p><p>D：using filesort：排序时无法使用到索引时，就会出现这个。<br>常见于order by和group by语句中</p><p>E：using index：查询时不需要回表查询，直接通过索引就可以<br>获取查询的数据。</p><p>F：using join buffer（block nested loop），using join buffer<br>（batched key accss）：5.6.x之后的版本优化关联查询的BNL，BKA<br>特性。主要是减少内表的循环数量以及比较顺序地扫描查询。</p><p>G：using sort_union，using_union，using intersect，<br>using sort_intersection：<br>using intersect：表示使用and的各个索引的条件时，该信息表示是<br>从处理结果获取交集<br>using union：表示使用or连接各个使用索引的条件时，该信息表示从<br>处理结果获取并集<br>using sort_union和using sort_intersection：与前面两个对应的类<br>似，只是他们是出现在用and和or查询信息量大时，先查询主键，然后<br>进行排序合并后，才能读取记录并返回。</p><p>H：using temporary：表示使用了临时表存储中间结果。临时表可以是<br>内存临时表和磁盘临时表，执行计划中看不出来，需要查看status变量，<br>used_tmp_table，used_tmp_disk_table才能看出来。</p><p>I：using where：表示存储引擎返回的记录并不是所有的都满足查询条<br>件，需要在server层进行过滤。查询条件中分为限制条件和检查条件，<br>5.6之前，存储引擎只能根据限制条件扫描数据并返回，然后server层根<br>据检查条件进行过滤再返回真正符合查询的数据。5.6.x之后支持ICP特<br>性，可以把检查条件也下推到存储引擎层，不符合检查条件和限制条件<br>的数据，直接不读取，这样就大大减少了存储引擎扫描的记录数量。<br>extra列显示using index condition</p><p>J：firstmatch(tb_name)：5.6.x开始引入的优化子查询的新特性之一，<br>常见于where字句含有in()类型的子查询。如果内表的数据量比较大，<br>就可能出现这个</p><p>K：loosescan(m..n)：5.6.x之后引入的优化子查询的新特性之一，在in()<br>类型的子查询中，子查询返回的可能有重复记录时，就可能出现这个</p><p>除了这些之外，还有很多查询数据字典库，执行计划过程中就发现不可<br>能存在结果的一些提示信息</p><p>11）filtered<br>使用explain extended时会出现这个列，5.7之后的版本默认就有这个<br>字段，不需要使用explain extended了。这个字段表示存储引擎返回的<br>数据在server层过滤后，剩下多少满足查询的记录数量的比例，注意是<br>百分比，不是具体记录数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实际项目开发中，由于我们不知道实际查询的时候数据库里发生了什么事情，&lt;br&gt;数据库软件是怎样扫描表、怎样使用索引的，因此，在写sql语句的时候就&lt;br&gt;很少考虑到性能的问题。但是当数据规模增大，如千万、亿的时候，我们运&lt;br&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="https://ouzhrm.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql存储引擎的选择及使用场景</title>
    <link href="https://ouzhrm.github.io/2018/04/22/mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E9%80%89%E6%8B%A9%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>https://ouzhrm.github.io/2018/04/22/mysql存储引擎的选择及使用场景/</id>
    <published>2018-04-22T07:16:15.000Z</published>
    <updated>2018-05-20T08:35:53.607Z</updated>
    
    <content type="html"><![CDATA[<p>mysql常用的存储引擎有InnoDB、MYISAM、Archive、Memory<br><strong>InnoDB</strong><br>支持事务以及外键，其他的三种存储引擎是不支持的。锁的粒度是行锁，最大存储<br>容量为64TB，采用MVCC来支持高并发的。默认的隔离级别是可重复读，并通过间隙<br><a id="more"></a><br>锁来防止幻读的。另外最关键的是它支持热备份，其他存储引擎是不支持的，集群<br>的一般选择这种引擎。</p><p><strong>MYISAM</strong><br>MYISAM存储引擎的锁粒度是表锁。物理文件结构是frm文件存储表的结构，myd文件<br>存储表的数据，myi文件存储索引。这三个文件分别放在不同的位置，以获取更快的<br>查询和插入的速度。最大的索引数为64，索引可以为null值，这个值占0~1个字节。<br>每个MyISAM类型的表都有一个AUTO_INCREMENT的内部列，当INSERT和UPDATE操作的<br>时候该列被更新，同时AUTO_INCREMENT列将被刷新。所以说，MyISAM类型表的<br>AUTO_INCREMENT列更新比InnoDB类型的AUTO_INCREMENT更快。<br><strong>Archive</strong><br>Archive引擎支持高并发的批量插入，但是不支持事务、索引和缓存，所以带有不<br>安全性。由于数据可压缩，所以占空间比较小。<br><strong>Memory</strong><br>数据存在内存中，所以数据查询起来的速度很快，但如果断电或者宕机等外界因素<br>的存在，数据会丢失。不支持BLOB或TEXT类型的列，<br>每行的长度是固定的，所以会使部分内存浪费。</p><p>####使用场景<br>InnoDB由于支持事务、热备份等特性，所以对数据严谨性较高的，比如支付、订<br>单、mysql集群等场景使用。<br>MYISAM和archive，如果数据表主要用来插入和查询记录，比如日志的记录，那么<br>用MYISAM或者archive比较合适。<br>Memory主要用于创建临时表，存放查询的中间结果，对数据安全性是否会出现数<br>据丢失等要求不高时，可以用Memory存储引擎。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mysql常用的存储引擎有InnoDB、MYISAM、Archive、Memory&lt;br&gt;&lt;strong&gt;InnoDB&lt;/strong&gt;&lt;br&gt;支持事务以及外键，其他的三种存储引擎是不支持的。锁的粒度是行锁，最大存储&lt;br&gt;容量为64TB，采用MVCC来支持高并发的。默认的隔离级别是可重复读，并通过间隙&lt;br&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="https://ouzhrm.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>高并发环境下mysql的配置参数调优</title>
    <link href="https://ouzhrm.github.io/2018/04/21/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8Bmysql%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98/"/>
    <id>https://ouzhrm.github.io/2018/04/21/高并发环境下mysql的配置参数调优/</id>
    <published>2018-04-21T04:04:47.000Z</published>
    <updated>2018-05-20T08:36:09.642Z</updated>
    
    <content type="html"><![CDATA[<p><strong>skip-locking</strong><br>避免MySQL的外部锁定，减少出错几率增强稳定性。<br><a id="more"></a><br><strong>back_log = 384</strong><br>back_log 参数的值指出在MySQL暂时停止响应新<br>请求之前的短时间内多少个请求可以被存在堆栈中。<br>对于Linux系统推荐设置为小于512的整数。  </p><p><strong>key_buffer_size = 256M</strong><br>key_buffer_size指定用于索引的缓冲区大小，增<br>加它可得到更好的索引处理性能。对于内存在4GB<br>左右的服务器该参数可设置为256M或384M。注意：<br>该参数值设置的过大反而会是服务器整体效率降低！  </p><p><strong>sort_buffer_size = 6M</strong><br><strong>查询排序时所能使用的缓冲区大小</strong>。注意：该参数<br>对应的分配内存是每连接独占，如果有100个连接，<br>那么实际分配的总共排序缓冲区大小为100 × 6 ＝<br>600MB。内存在4GB左右的服务器推荐设置为6-8M。  </p><p><strong>read_buffer_size = 4M</strong><br>读查询操作所能使用的缓冲区大小。<br>和sort_buffer_size一样，该参数对应的分配内存<br>也是每连接独享。 </p><p><strong>join_buffer_size = 8M</strong><br>联合查询操作所能使用的缓冲区大小，和<br>sort_buffer_size一样，该参数对应的分<br>配内存也是每连接独享。  </p><p><strong>query_cache_size = 64M</strong><br>指定MySQL查询缓冲区的大小</p><p><strong>max_connections = 768</strong><br>指定MySQL允许的最大连接进程数。如果在<br>访问论坛时经常出现Too Many Connections<br>的错误提 示，则需要增大该参数值</p><p><strong>wait_timeout = 10</strong><br>指定一个连接请求的最大等待时间，对于4GB左右<br>内存的服务器可以设置为5-10。  </p><p><strong>thread_concurrency = 8</strong><br>该参数取值为服务器逻辑CPU数量<em>2，在本例中，<br>服务器有2颗物理CPU，而每颗物理CPU又支持H.T<br>超线程，所以实际取值为4</em>2=8  </p><p><strong>table_cache=1024</strong><br>物理内存越大,设置就越大.默认为2402,<br>调到512-1024最佳。</p><p><strong>innodb_thread_concurrency=8</strong><br>你的服务器CPU有几个就设置为几,建议用默认一般为8  </p><h5 id="MyISAM和InnoDB优化"><a href="#MyISAM和InnoDB优化" class="headerlink" title="MyISAM和InnoDB优化"></a>MyISAM和InnoDB优化</h5><p><strong>key_buffer_size</strong><br>这对MyISAM表来说非常重要。如果只是使用<br>MyISAM表，可以把它设置为可用内存的 30-40%。<br>合理的值取决于索引大小、数据量以及负载<br>如果很少使用MyISAM表，那么也保留低于16-32MB<br>的key_buffer_size以适应给予磁盘的临时表索引所需。</p><p><strong>innodb_buffer_pool_size</strong><br>Innodb相比MyISAM表对缓冲更为敏感。<br>一般设置它高达70-80%的可用内存。</p><p><strong>innodb_log_file_size </strong><br>在高写入负载尤其是大数据集的情况下很重要。<br>这个值越大则性能相对越高，但是要注意到可能<br>会增加恢复时间。我经常设置为 64-512MB，<br>跟据服务器大小而异</p><p><strong>innodb_log_buffer_size</strong><br> 默认的设置在中等强度写入负载以及较短事务的情<br> 况下，服务器性能还可以。如果存在更新操作峰值<br> 或者负载较大，就应该考虑加大它的值了。如果它的<br> 值设置太高了，可能会浪费内存 — 它每秒都会刷新<br> 一次，因此无需设置超过1秒所需的内存空间。通常<br> 8-16MB 就足够了。越小的系统它的值越小。</p><p><strong>innodb_flush_logs_at_trx_commit </strong><br>把它的值设置为2就可以了，也就是不把日志刷新到磁盘上，<br>而只刷新到操作系统的缓存上。日志仍然会每秒刷新到磁盘中<br>去，因此通常不会丢失每秒1-2次更新的消耗。</p><p><strong>table_cache</strong><br>表缓存<br>如果你有200多个表的话，那么设置为 1024 也许比较合适（<br>每个线程都需要打开表），如果连接数比较大那么就加大它<br>的值。我曾经见过设置为 100,000 的情况。</p><p><strong>thread_cache</strong><br>线程的创建和销毁的开销可能很大，<br>因为每个线程的连接/断开都需要。<br>我通常至少设置为 16。如果应用程序中有大量的跳跃<br>并发连接并且 Threads_Created 的值也比较大，<br>加大它的值目的是在通常的操作中无需创建新线程。</p><p><strong>query_cache</strong><br>如果你的应用程序有大量读，而且没<br>有应用程序级别的缓存，那么这很有用。不要把它设<br>置太大了，因为想要维护它也需要不少开销，这会导<br>致MySQL变慢。通 常设置为 32-512Mb。设置完之后最<br>好是跟踪一段时间，查看是否运行良好。在一定的负载<br>压力下，如果缓存命中率太低了，就启用它。</p><h4 id="下面是一些常见参数优化案例"><a href="#下面是一些常见参数优化案例" class="headerlink" title="下面是一些常见参数优化案例"></a>下面是一些常见参数优化案例</h4><p><strong>thread_concurrency = 4 </strong><br>服务器cpu内核数(真实的并发处理数)</p><h5 id="各种缓存大小"><a href="#各种缓存大小" class="headerlink" title="各种缓存大小"></a>各种缓存大小</h5><p><strong>key_buffer = 384M </strong> 索引块缓存<br><strong>max_allowed_packet = 1M  </strong><br>mysql服务器端和客户端在一次传送数据包的过程当中数据包的大小<br><strong>table_cache = 2048 </strong><br>所有线程打开表的数量<br><strong>sort_buffer_size = 2M</strong> 对排列缓存<br><strong>read_buffer_size = 2M</strong> 读缓存<br><strong>read_rnd_buffer_size = 8M </strong> 随即读排序缓存<br><strong>myisam_sort_buffer_size = 64M </strong><br>排序MyISAM索引分配的缓冲区<br><strong>thread_cache_size = 8 </strong><br>可以复用的保存在缓存中的线程的数量<br><strong>query_cache_size = 32M</strong> 查询缓存<br><strong>tmp_table_size = 256M</strong> 临时表大小<br><strong>max_heap_table_size = 256M</strong> 内存表大小</p><h5 id="延时等待"><a href="#延时等待" class="headerlink" title="延时等待"></a>延时等待</h5><p><strong>interactive_timeout=2880000</strong>  对后续起的交互链接有效；<br><strong>wait_timeout=2880000</strong> 对当前交互链接有效；</p><h5 id="连接数"><a href="#连接数" class="headerlink" title="连接数"></a>连接数</h5><p><strong>max_connections= 5000 </strong> 最大并发数<br><strong>max_connect_errors = 6000 </strong><br>是MySQL中与安全有关的计数器值，它负责阻止过<br>多尝试失败的客户端以防止暴力破解密码的情况。<br><strong>back_log=500</strong> 堆栈队列大小</p><h5 id="域名相关"><a href="#域名相关" class="headerlink" title="域名相关"></a>域名相关</h5><p><strong>skip-name-resolve</strong>  跳过反响解析</p><h5 id="下面是一些查询语句"><a href="#下面是一些查询语句" class="headerlink" title="下面是一些查询语句"></a>下面是一些查询语句</h5><p>在主库上查看主库的状态：<br>show master status;</p><p>查看从库的状态：<br>show slave status；</p><h5 id="数据库主从复制原理："><a href="#数据库主从复制原理：" class="headerlink" title="数据库主从复制原理："></a>数据库主从复制原理：</h5><p>数据库的主从复制就是从master数据库复制到<br>slave数据库，在master与slave之间实现整个<br>复制需要三个线程来完成，其中两个在slave<br>端一个在master端。在master端必须打开binlog<br>功能，因为从数据库需要获得主数据的完整的<br>操作日志然后再自身上顺序的执行日志中的各种操作。</p><p>概要步骤：将master的bin-log写到slave的relay-log中，<br>然后执行里面的语句。</p><p>详细步骤：<br>1、将slave的io线程连上master，请求获得指定日志文<br>件的指定位置之后的操作日志的内容；<br>2、master获得slave的io线程请求后，将请求中读取到<br>的指定日志的指定位置之后的内容返回给slave端的io<br>线程，其中包括binlog 的位置以及名称；<br>3、slave端的io线程在接收到信息后，将接收到的日志<br>内容写入slave端的relay log文件的末端，并将binlog<br>的文件名和位置记录到master-info文件中，以便下一<br>次请求时向master提出请求；<br>4、slave的sql线程会检测到relay log中新增的一些日<br>志内容并加以解析成为可执行的query语句在slave端执<br>行，从而达到master与slave端的数据一致性。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;skip-locking&lt;/strong&gt;&lt;br&gt;避免MySQL的外部锁定，减少出错几率增强稳定性。&lt;br&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="https://ouzhrm.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql常用配置参数</title>
    <link href="https://ouzhrm.github.io/2018/04/19/mysql%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0/"/>
    <id>https://ouzhrm.github.io/2018/04/19/mysql常用配置参数/</id>
    <published>2018-04-19T08:34:21.000Z</published>
    <updated>2018-05-20T08:35:41.330Z</updated>
    
    <content type="html"><![CDATA[<p>mysql在启动的时候，会加载my.ini（Linux系统下是my.cnf），即当mysql服务器启动时它会读取这<br>个文件，设置相关的运行环境参数。<br><a id="more"></a><br>查询当前全部参数设置sql语句为：show variables<br>下面是一些常用的配置参数：<br><strong>port=3306</strong><br>mysql使用的端口号</p><p><strong>atadir=/data/mysql</strong><br>数据文档存储目录,默认为/var/lib/mysql</p><p><strong>skip-slave-start</strong><br>禁止slave复制进程随Mysql数据库启动而启动，默认为未启用</p><p><strong>skip-name-resolve</strong><br>禁止Mysql进行DNS反向解析,默认为未启用,安装的MySql开启了DNS的反向解析,<br>禁止DNS反向解析后,只能通过Mysql授权表中IP来访问,可以提高Mysql访问速度.</p><p><strong>sort_buffer_size = 4M</strong><br>connection级参数，一个连接分配多少内存，默认为256KB。</p><p><strong>join_buffer_size = 2M</strong><br>默认为128KB，用于表间关联缓存的大小，和sort_buffer_size一样，该参数对应的分配内存也是每<br>个连接独享。如果应用中，很少出现join语句，则可以不用太在乎join_buffer_size参数的设置大小。<br>如果join语句不是很少的话，个人建议可以适当增大join_buffer_size到1MB左右，如果内存充足可以<br>设置为2MB</p><p><strong>table_open_cache = 5000</strong><br>打开表的缓存数量，默认为64。也不是定义内存的大小的。而是定义可以缓存多少打开的表的文件<br>句柄信息。如果定义的太小，那么mysql在需要打开新表的时候就要不断的关闭已经打开的表和打开<br>此次需要打开的表。性能会受到影响。</p><p><strong>table_definition_cache = 5000</strong><br>默认值为256 (Myslq5.12后，之前128)，表定义信息缓存是从MySQL5.1.3 版本才开始引入的一个<br>新的缓存区，用来存放表定义信息，设置好的话能提高对表定义信息的访问效率。</p><p><strong>thread_cache_size = 512</strong><br>定义缓存了的线程数量<br>只要设置的大小除以8小于物理内存就可以的。</p><p><strong>query_cache_size = 32M</strong><br>用来缓存特定Query 的结果集（Result Set）信息，默认值为0。在数据库写入量或是更新量也比较<br>大的系统，该参数不适合分配过大。而且在高并发，写入量大的系统，建议把该功能禁掉。</p><p><strong>query_cache_limit = 2M</strong><br>默认值为1MB<br>指定单个查询能够使用的缓冲区大小</p><p><strong>max_allowed_packet = 100M</strong><br>默认值为4M。<br>接受的数据包大小</p><p><strong>max_connect_errors = 1000000</strong><br>默认值为10<br>一个MySQL中与安全有关的计数器值，它负责阻止过多尝试失败的客户端以防止暴力破解密码的<br>情况。max_connect_errors的值与性能并无太大关系，mysqladmin flush-hosts命令来解锁已经<br>被屏蔽的主机</p><p><strong>max_connections = 1500</strong><br>默认值为100<br>MySQL允许最大的进程连接数，如果经常出现Too Many Connections的错误提示，则需要增大此值。</p><p><strong>tmp_table_size = 256M</strong><br>默认值大小为32M<br>临时表使用内存<br>如果一张临时表超出该大小，MySQL产生一个 The table tbl_name is full 形式的错误，如果你<br>做很多高级 GROUP BY 查询，增加 tmp_table_size 值。如果超过该值，则会将临时表写入磁盘。</p><p><strong>max_heap_table_size = 256M</strong><br>定义了用户可以创建的内存表(memory table)的大小。这个值用来计算内存表的最大行数值。这个<br>变量支持动态改变其大小还小于 tmp_table_size 的时候，MySQL 将使用 max_heap_table_size<br>参数所设置大小作为最大的内存临时表大小，而忽略 tmp_table_size 所设置的值。</p><h4 id="——–log———"><a href="#——–log———" class="headerlink" title="——–log———"></a>——–log———</h4><p><strong>slow_query_log=1</strong><br>slow quere log的开关，当值为1的时候说明开启慢查询。</p><p><strong>slow_query_log_file=slow.log</strong><br>慢查询日志位置及其文件名字</p><p><strong>long_query_time = 1</strong><br>慢查询时间 超过1秒则为慢查询</p><p><strong>log-error = mysql-error.log</strong><br>Mysql错误日志开关<br>错误日志位置及错误日志文件名</p><p><strong>log_slave_updates = 1</strong><br>默认为0(关闭状态)<br>控制从库通过I0线程读取主库二进制日志文件，<br>然后通过SQL线程写入的数据时候是否写入从库自身的binlog日志</p><p><strong>relay_log_purge = 0</strong><br>默认为1(自动删除状态)<br>控制SQL线程在执行完一个relay log后是否自动将其删除</p><p><strong>read_only = 1</strong><br>默认为0 (读写状态)<br>设置数据库为只读模式，只对普通用户起作用。对root或拥有super权限的无效果。</p><h4 id="——–binlog———"><a href="#——–binlog———" class="headerlink" title="——–binlog———"></a>——–binlog———</h4><p><strong>expire_logs_days = 30</strong><br>默认为0 (不自动删除)<br>设置binlog自动删除过期时间</p><p><strong>log-bin=mysql-bin</strong><br>默认为关闭<br>Mysql的binlog日志开关<br>设置binlog日志位置及日志文件名</p><p><strong>binlog_format=mixed</strong><br>默认为statement<br>binlog日志格式，建议使用mixed</p><p><strong>server-id = 1055</strong><br>Mysql server唯一标示，一般以时间戳就可以<br>主从同步中使用<br>mysql的同步的数据中是包含server-id的，用于标识该语句最初是从哪个server写入的。</p><h4 id="——–innodb———"><a href="#——–innodb———" class="headerlink" title="——–innodb———"></a>——–innodb———</h4><p><strong>innodb_data_home_dir = /data/mysql/ibdata</strong><br>默认使用MySQL的 datadir 目录为缺省目录<br>InnoDB表的目录共用设置<br>如果设定一个空字串,可以在 innodb_data_file_path 中设定绝对路径</p><p><strong>innodb_file_per_table = 1</strong><br>默认为关闭(值为0)<br>控制是否使用独立表空间模式</p><p><strong>innodb_autoextend_increment = 256</strong><br>默认是8M<br>当自动扩展表空间被填满之时，为扩展而增加的尺寸（MB为单位）<br>mysql 5.6.5版本之前默认值是8Mb，从5.6.6版本之后默认为64Mb，最小值为1Mb，最大值为1000Mb。<br>这个参数受到innodb_file_per_table参数的影响</p><p><strong>innodb_data_file_path=ibdata1:10M;ibdata2:10M:autoexte</strong><br>指定表数据和索引存储的空间，可以是一个或者多个文件。最后一个数据文件必须是自动扩充的，也<br>只有最后一个文件允许自动扩充。<br>例子：<br>假设希望创建一个数据文件ibdata1，初始大小为100MB，并希望在每次达到当前大小限制时，自动增加<br>8MB（8MB是指定autoextend时的默认扩展大小).但是，不希望此文件超过1GB，可以使用如下配置:<br>innodb_data_home_dir =<br>innodb_data_file_path = /data/ ibdata1:100M:autoextend:8M: max:1GB<br>如果此文件增加到预定的1G的限制，可以再增加另外一个数据文件,如下:<br>innodb_data_file_path = /data/ibdata1:100M:autoextend:8M: max:1GB;<br>innodb_data_file_path = /data2/ibdata2:100M:autoextend:8M: max:2GB</p><p><strong>innodb_table_locks = 0</strong><br>默认值为1<br>如果autocommit=1,Innodb的内部表锁可能会导致deadlock,可以通过设置innodb_table_locks=0来解决这<br>个问题，设置innodb_lock_wait_timeout变量,使deadlock超时后rollback</p><p><strong>innodb_lock_wait_timeout = 10</strong><br>MySQL在允许其他事务修改那些最终受事务回滚的数据之前要等待多长时间(秒数)</p><p><strong>innodb_buffer_pool_size = 16G</strong><br>默认为8M<br>InnoDB 用来高速缓冲数据和索引内存缓冲大小<br>可以设置60-80%的内存</p><p><strong>innodb_additional_mem_pool_size = 20M</strong><br>默认值为1MB<br>InnoDB 用来存储数据字典(data dictionary)信息和其它内部数据结构(internal data structures)的存<br>储器组合(memory pool)大小参数对系统整体性能并无太大的影响，只要能存放需要的数据就好，否则只会<br>浪费内存几百个Innodb 表的，推荐20M以内就足以了。<br>此参数在5.7中已经移除</p><p><strong>innodb_read_io_threads = 6</strong><br>后台读线程, 主要处理INNODB 数据文件异步读请求<br>每个read线程最多可以pend 256个任务(Linux平台中)</p><p><strong>innodb_write_io_threads = 6</strong><br>后台写线程数, 主要处理INNODB 数据文件异步写请求<br>每个write线程最多可以pend 256个任务(Linux平台中)</p><p><strong>innodb_flush_method=O_DIRECT</strong><br>默认为fdatasync<br>fdatasync：调用fsync()去刷数据文件与redo log的buffer<br>O_DSYNC：innodb会使用O_SYNC方式打开和刷写redo log,使用fsync()刷写数据文件<br>O_DIRECT：innodb使用O_DIRECT打开数据文件，使用fsync()刷写数据文件跟redo log</p><p><strong>innodb_log_files_in_group = 2</strong><br>默认为2<br>控制日志文件数</p><p><strong>innodb_log_file_size = 1G</strong><br>默认为 5M<br>用来在mysql crash后的恢复.所以设置合理的大小对于mysql的性能非常重要<br>通过show engine innodb status;可以查看mysql checkpoint情况，可以算<br>出上次checkpoint和最后一次checkpoint的中间值，官方文档建议最好不要超过<br>innodb_log_files_in_group*innodb_log_file_size的0.75<br>由此可以推算出innodb_log_file_size比较合适的值。<br>在mysql 5.5和5.5以前innodb的logfile最大设置为4GB,在5.6以后的版本中logfile<br>最大的可以设为512GB<br>当mysql crash后，在重启之前需要将老的innodb logfile删除。</p><p><strong>innodb_log_buffer_size = 48M</strong><br>默认为8M<br>当事务提交时，保存脏数据到内存中，后续再刷新保存到磁盘<br>适当调整此参数大小，可以减少磁盘I/O</p><p><strong>innodb_flush_log_at_trx_commit=2</strong><br>默认为1<br>控制log buffer写入log file和控制flush操作<br>innodb_flush_log_at_trx_commit=0，log buffer将每秒一次地写入log file中，<br>并且log file的flush(刷到磁盘)操作同时进行.该模式下，在事务提交的时候，不<br>会主动触发写入磁盘的操作。<br>innodb_flush_log_at_trx_commit=1，每次事务提交时MySQL都会把log buffer的<br>数据写入log file，并且flush(刷到磁盘)中去.<br>innodb_flush_log_at_trx_commit=2，每次事务提交时MySQL都会把log buffer的<br>数据写入log file.但是flush(刷到磁盘)操作并不会同时进行。该模式下,MySQL会<br>每秒执行一次 flush(刷到磁盘)操作。<br>注意：<br>  由于进程调度策略问题,这个“每秒执行一次 flush(刷到磁盘)操作”并不是保证<br>  100%的“每秒”。</p><p><strong>sync_binlog = 15</strong><br>默认值为0<br>像操作系统刷其他文件的机制一样，MySQL不会同步到磁盘中去而是依赖操作系统<br>来刷新binary log。当sync_binlog =N (N&gt;0) ，MySQL 在每写 N次 二进制日志<br>binary log时，会使用fdatasync()函数将它的写二进制日志binary log同步<br>到磁盘中去。<br>注:<br>   如果启用了autocommit，那么每一个语句statement就会有一次写操作；否则<br>   每个事务对应一个写操作。<br>   一般与innodb_flush_log_at_trx_commit同时设置</p><p><strong>innodb_support_xa = 0</strong><br>0表示关闭<br>分布式事务中此参数确保事务日志写入bin-log 的顺序与是事务的time-line 是<br>一致的</p><p><strong>sql_mode = NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</strong><br>默认为空<br>此参数在mysql数据库版本升级时候用比较合适</p><p><strong>binlog_cache_size=2M</strong><br>默认为32K<br>一个事务，在没有提交（uncommitted）的时候，产生的日志，记录到Cache中；<br>等到事务提交（committed）需要提交的时候，则把日志持久化到磁盘<br>在事务中存储二进制日志sql语句的缓存大小</p><p><strong>tx_isolation = READ-COMMITTED</strong><br>默认为 REPEATABLE READ<br>关于MySQL的事务处理及隔离级别<br>READ-UNCOMMITTED, READ-COMMITTED, REPEATABLE-READ, SERIALIZABLE</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mysql在启动的时候，会加载my.ini（Linux系统下是my.cnf），即当mysql服务器启动时它会读取这&lt;br&gt;个文件，设置相关的运行环境参数。&lt;br&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="https://ouzhrm.github.io/tags/mysql/"/>
    
      <category term="数据库" scheme="https://ouzhrm.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务的四种隔离级别</title>
    <link href="https://ouzhrm.github.io/2018/04/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>https://ouzhrm.github.io/2018/04/19/数据库事务的四种隔离级别/</id>
    <published>2018-04-19T02:24:31.000Z</published>
    <updated>2018-05-20T08:36:39.184Z</updated>
    
    <content type="html"><![CDATA[<p>1.读没提交<br>事务A没有提交，做了一些写入或者更新操作，事务B可以读，但如果事务B发生回滚，那么就会出现脏读现象。<br>脏读可以理解成还没提交你就开始读，真脏的意思。实际做生产的时候一般不会使用这种事务。<br><a id="more"></a><br>2.读提交<br>和读没提交恰好相反，只有事务A提交了，事务B才可以读，大部分数据库支持这一种事务。<br>3.重复读<br>事务B先读一遍数据，事务A写入id为3的数据，事务B再查一遍数据，发现没有发生变化，也就是说事务之间隔离了，<br>但事务B也想写入id为3的数据时，发现无法写入，并提醒id重复,也就是所谓的幻读，似乎发生幻觉了一样。这种<br>隔离级别是事务各干各的，但是又有点联系那种，很模糊。mysql就是默认这种隔离级别的。<br>4.串行化<br>事务A正在查询，事务B写入，会发现事务B无法写入，显示正在等待状态。这是事务隔离级别中最严格的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.读没提交&lt;br&gt;事务A没有提交，做了一些写入或者更新操作，事务B可以读，但如果事务B发生回滚，那么就会出现脏读现象。&lt;br&gt;脏读可以理解成还没提交你就开始读，真脏的意思。实际做生产的时候一般不会使用这种事务。&lt;br&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://ouzhrm.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>《大型网站技术架构 核心原理与案例分析》读书总结</title>
    <link href="https://ouzhrm.github.io/2018/04/18/%E3%80%8A%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E3%80%8B%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"/>
    <id>https://ouzhrm.github.io/2018/04/18/《大型网站技术架构-核心原理与案例分析》读书总结/</id>
    <published>2018-04-18T02:21:51.000Z</published>
    <updated>2018-05-20T08:35:11.460Z</updated>
    
    <content type="html"><![CDATA[<h4 id="我为什么读这本书？"><a href="#我为什么读这本书？" class="headerlink" title="我为什么读这本书？"></a>我为什么读这本书？</h4><p>最近在研究分布式相关，在网上聊的热火朝天，都说这本书入门好。李智慧编写，电子工业出版社出版，<br><a id="more"></a><br>豆瓣读书评分是7.9,一共有1000多人参与评论。我大概花了一个多星期的零碎时间，通读了这本书，大<br>概读到后面的后辈对晚辈的悉心嘱咐的时候，我就在豆瓣读书奉献了这本书的书评，给了三星。并作了<br>一些评论。毫无疑问，这本书真的是很适合入门，网上的兄弟们没骗我，它会在大型网站架构上给你一<br>些很全面的认识以及自己的一些经验之谈。但咋们做技术的，往往注重实用性，关注点在能不能用，怎<br>么用，用的时候注意什么，用的好不好等问题，但在这本书并没有深入。而最后，我想总结的是，这本<br>书更像一本兵书，想发力却又用不上来的那种感觉，又像师父领进门，修行看个人的感觉。如果说非要<br>给这本书来个标签，那可能是，有点失灵，但方向还基本正确的指南针，因为里面多少掺杂一些水分，<br>无关紧要的，能一句话说完，它非要说上1000来字，带点装*，自嗨的那种感觉。    </p><h4 id="这本书带给我的收获"><a href="#这本书带给我的收获" class="headerlink" title="这本书带给我的收获"></a>这本书带给我的收获</h4><p>一般后台的分三层：应用层，服务层，数据层。应用层一般是页面及控制器。服务层是一些可调用的接<br>口，可以理解成service层，而数据库层，也就是操作数据库的，可以理解成dao层。但这仅仅指的是java<br>层面上的理解。</p><p>先说应用层，也就是页面相关的。<br>流量入口，我们一般用nginx进行反向代理，负载均衡。将请求按轮询的方式或者hash方式分发到具体的<br>服务器或者网关。一些热点的静态页面（比如说主页）可以放到nginx缓存或者CDN服务器。而CDN、反向<br>代理服务器的原理都是缓存。当然，如果集群中的某一台服务器宕机了，要实现失效转移，将请求转发<br>到其他正常运行的服务器中。<br>1、页面优化<br>为减少http请求，我们要实现一个静态资源，合并css,js,以及请求数据量大的图片。其次，要通过设置<br>请求头的方式实现浏览器缓存，304重定向，防止图片，js的文件的再次加载。其次可以启用压缩，服务<br>器将文件压缩，浏览器解压缩。减少传输的数据量。其次css放在上面，js放在下面。因为加载页面<br>是从上往下加载的。<br>2、负载均衡<br>有几种方式，反向代理负载均衡，IP负载均衡，数据链路层负载均衡等。这些之后可以去了解一下，这<br>几种都是不同的。这本书也描述的不是特别清楚。然后以及负载均衡的算法，现在业内大部分是通过<br>一致性hash算法来实现请求到底去选择哪一台服务器。</p><p>然后说说服务层<br>当服务层的关系很复杂的时候，我们要对其进行解耦，解耦的方式有以下那么几种：<br>分布式服务：也就是rpc,远程方法调用，国内的Dubbo或者FaceBook通过Thrift来自主研发的框架。<br>原理简单：网络通信+编解码+服务端+客户端。<br>消息队列：消息队列是类似于生产者-消费者模式的。一头生产消息，另一头消费消息，中间来个管理消<br>息与推送消息的。也常常叫做消息中间件，jms。如：activemq，kafka等。在高并发支付场景可以使用。<br>但注意幂等性，消息重发等问题。独立部署web应用：当某一个服务与其他服务关联不大的时候，可以采<br>用单独拿出来，独立部署。</p><p>最后是数据层<br>关系型数据库往往会设计成读写分离（master写，一个或多个slave读）的模式。如mysql本身有主从热备<br>的功能，也就是数据库之间数据同步。先说下概念，热备份是主从复制，而冷备份定期存档。其次还有垂直水<br>平分库分表的方式，按业务模块分，按列，按时间等分出多个数据库或表。性能上，人为能改变的有sql优化、<br>索引设置等。然后是nosql相关的，nosql种类很多，如key-value形式，可用于存session，保证session<br>一致性的redis,文档型非关系型数据库mongoDB,此外还有mamcached等。<br>然后介绍几个概念，<br>缓存预热：将数据提前存到非关系型数据库如redis中，防止项目重新部署之后，关系型数据库如mysql访问<br>量过大而宕机。<br>缓存穿透：是指大量并发访问redis中一个不存在的数据，导致请求都往mysql上串，最终mysql访问量过大<br>而宕机，解决的方式可以是设置将redis不存在的数据立即返回null。</p><h4 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h4><p>自动化是我们的理想形态，如：自动化发布、自动化代码管理、自动化测试（安全、性能、功能），自动化<br>监控和报警（心跳检测、通知），自动化失效转移，超时转移和失效恢复、自动化降级、自动化分配资源等。</p><h4 id="大型网站要实现以下几种性质"><a href="#大型网站要实现以下几种性质" class="headerlink" title="大型网站要实现以下几种性质"></a>大型网站要实现以下几种性质</h4><p>可用性：一年内99.99%的时间里，服务器都能正常的运行及可提供功能访问。<br>伸缩性：线上增减服务器数量时对其它服务器的影响。<br>扩展性：增减功能对其他功能的影响。<br>安全性：保证网站的安全。</p><h4 id="CAP原理"><a href="#CAP原理" class="headerlink" title="CAP原理"></a>CAP原理</h4><p>C：数据一致性，保证请求在某一具体功能点上都能访问到相同或者说正确的数据。<br>A：数据可用性：任何时候请求的数据都能进行读写访问。<br>P：系统跨网络线性伸缩。</p><h4 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h4><p>每天只发布部分服务器，分多天发布。</p><h4 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h4><p>集群服务器之后，请求过来后，访问那一台服务器是具有不确定性的。</p><h5 id="秒杀系统的架构和设计"><a href="#秒杀系统的架构和设计" class="headerlink" title="秒杀系统的架构和设计"></a>秒杀系统的架构和设计</h5><p>1、秒杀系统独立部署，与网站其他功能尽量没有关联，秒杀商品页面静态化，用户请求不需要经过应用服务<br>器进行跳转或者逻辑处理，秒杀页面租借秒杀活动网络带宽，将秒杀商品页面缓存到CDN中。<br>2、部署定时任务服务器，动态生成随机下单页面的URL，推送到javascript服务器中，到点后，静态页面刷<br>新，购买按钮点亮。<br>3、设置全局计数器服务器，每次下单前都要取缓存中的数字进行比对，如果大于缓存中的数字，则直接返<br>回活动结束页面，否则提交到订单处理子系统。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>服务器配置实时更新之后的分布式配置，如用zookeeper共享配置。<br>分布式环境下实现并发访问协同的分布式锁。<br>分布式批量操作等。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;我为什么读这本书？&quot;&gt;&lt;a href=&quot;#我为什么读这本书？&quot; class=&quot;headerlink&quot; title=&quot;我为什么读这本书？&quot;&gt;&lt;/a&gt;我为什么读这本书？&lt;/h4&gt;&lt;p&gt;最近在研究分布式相关，在网上聊的热火朝天，都说这本书入门好。李智慧编写，电子工业出版社出版，&lt;br&gt;
    
    </summary>
    
      <category term="读书" scheme="https://ouzhrm.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="分布式" scheme="https://ouzhrm.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>《MySQL性能调优与架构设计》学习总结</title>
    <link href="https://ouzhrm.github.io/2018/04/18/%E3%80%8Amysql%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E3%80%8B%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"/>
    <id>https://ouzhrm.github.io/2018/04/18/《mysql高性能架构设计》读书总结/</id>
    <published>2018-04-18T02:21:51.000Z</published>
    <updated>2018-05-20T08:35:15.050Z</updated>
    
    <content type="html"><![CDATA[<h5 id="此书的详细内容"><a href="#此书的详细内容" class="headerlink" title="此书的详细内容"></a>此书的详细内容</h5><p>作者：简朝阳<br>出版社: 电子工业出版社<br>出版年: 2009-6<br><a id="more"></a></p><h2 id="mysql物理文件组成"><a href="#mysql物理文件组成" class="headerlink" title="mysql物理文件组成"></a>mysql物理文件组成</h2><h3 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h3><p>错误日志<br>错误日志记录了MyQL Server 运行过程中所有较为严重的警告和错误信息，以及MySQL<br>Server 每次启动和关闭的详细信息.<br>如果要开启系统记录错误日志的功能，需要在<br>启动时开启-log-error 选项。错误日志的默认存放位置在数据目录下，以hostname.err 命<br>名。但是可以使用命令：–log-error[=file_name]，修改其存放目录和文件名.</p><p>二进制日志<br>二进制日志，也就是我们常说的binlog，也是MySQL Server 中最为重要的日志之一。<br>当我们通过“–log-bin[=file_name]”打开了记录的功能之后，MySQL 会将所有修改数据<br>库数据的query 以二进制形式记录到日志文件中。当然，日志中并不仅限于query 语句这么<br>简单，还包括每一条query 所执行的时间，所消耗的资源，以及相关的事务信息，所以binlog<br>是事务安全的。<br>和错误日志一样，binlog 记录功能同样需要“–log-bin[=file_name]”参数的显式指<br>定才能开启，如果未指定file_name，则会在数据目录下记录为mysql-bin.<strong>**</strong>（*代表0～<br>9 之间的某一个数字，来表示该日志的序号）。</p><p>慢查询日志：slow query log<br>顾名思义，慢查询日志中记录的是执行时间较长的query，也就是我们常说的slow<br>query，通过设–log-slow-queries[=file_name]来打开该功能并设置记录位置和文件名，<br>默认文件名为hostname-slow.log，默认目录也是数据目录。<br>MySQL 还提供了专门用来分析满查询日志的工具程序mysqlslowdump，<br>用来帮助数据库管理人员解决可能存在的性能问题。</p><h3 id="数据文件"><a href="#数据文件" class="headerlink" title="数据文件"></a>数据文件</h3><p>每个数据文件的扩展名却各不一样。如MyISAM 用“.MYD”作为扩展<br>名，Innodb 用“.ibd”，Archive 用“.arc”，CSV 用“.csv”。</p><p>不论是什么存储引擎，每一个表都会有一个以表名命名的“.frm”文件，存放表结构信息。<br>所有的“.frm”文件都存放在所属数据库的文件夹下面。</p><p>“.MYD”文件是MyISAM 存储引擎专用，存放MyISAM 表的数据。</p><p>“.MYI”文件是存放MyISAM 表的索引相关信息。</p><p>.ibd文件和ibdata文件<br>这两种文件都是存放Innodb 数据的文件。独享表空间存储方式使用“.ibd”文件来存放数据，且<br>每个表一个“.ibd”文件，文件存放在和MyISAM 数据相同的位置。如果选用共享存储表空<br>间来存放数据，则会使用ibdata 文件来存放，所有表共同使用一个（或者多个，可自行配<br>置）ibdata 文件。</p><h3 id="Replication（复制）相关文件"><a href="#Replication（复制）相关文件" class="headerlink" title="Replication（复制）相关文件"></a>Replication（复制）相关文件</h3><p>master.info 文件：<br>master.info 文件存在于Slave 端的数据目录下，里面存放了该Slave 的Master 端的相关信息。</p><p>relay log<br>存放Slave 端的I/O 线程从Master 端所读取到的Binary Log 信息，<br>然后由Slave 端的SQL 线程从该relay log 中读取并解析相应的日志<br>信息，转化成Master 所执行的SQL 语句，然后在Slave端应用。</p><p>relay-log.info 文件：<br>类似于master.info，它存放通过Slave 的I/O 线程写入到本地的relay log 的相关信息。</p><h3 id="MySQL-Server-系统架构"><a href="#MySQL-Server-系统架构" class="headerlink" title="MySQL Server 系统架构"></a>MySQL Server 系统架构</h3><p>MySQL 是二层架构，第一层我们通常叫做SQL Layer，处理包括权限判断，sql 解析，执<br>行计划优化，query cache 的处理等等；第二层就是存储引擎层，我们通常叫做Storage<br>Engine Layer，也就是底层数据存取操作实现部分，由多种存储引擎共同组成。</p><h2 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>MySQL 的插件式存储引擎主要包括MyISAM，Innodb，NDB Cluster，Maria，Falcon，<br>Memory，Archive，Merge，Federated 等，其中最著名而且使用最为广泛的MyISAM 和Innodb<br>两种存储引擎。MyISAM 是MySQL 最早的ISAM 存储引擎的升级版本，也是MySQL默认的存储<br>引擎。但它不支持事务，外键等特性，我们可以重新设置InnoDB为默认引擎：在配置文件<br>my.cnf（linux,如果是windows，则是my.ini）中的 [mysqld]下面加入<br>default-storage-engine=INNODB 一句，Innodb 最大的特点是提供了事务控制等特性。</p><p>NDB Cluster 虽然也支持事务，但是主要是用于分布式环境。Memory 存储引擎所有数据<br>和索引均存储于内存中，所以主要是用于一些临时表，或者对性能要求极高，但是允许在<br>丢失数据的特定场景下。Archive 是一个数据经过高比例压缩存放的存储引擎，主要用于<br>存放过期而且很少访问的历史信息，不支持索引。Merge在严格意义上来说，并不能算作<br>一个存储引擎。因为Merge 存储引擎主要用于将几个基表merge 到一起，对外作为一个<br>表来提供服务，基表可以基于其他的几个存储引擎。</p><p>MyISAM 支持以下三种类型的索引：<br>1、B-Tree 索引<br>    B-Tree 索引，顾名思义，就是所有的索引节点都按照balance tree 的数据结构来<br>    存储，所有的索引数据节点都在叶节点。<br>2、R-Tree 索引<br>    R-Tree 索引的存储方式和b-tree 索引有一些区别，主要设计用于为存储空间和多<br>    维数据的字段做索引。<br>3、Full-text 索引<br>    Full-text 索引就是我们长说的全文索引，他的存储结构也是b-tree。主要是为了<br>    解决在我们需要用like 查询的低效问题。<br>    MyISAM 上面三种索引类型中，最经常使用的就是B-Tree 索引了，偶尔会使用到Fulltext，<br>    但是R-Tree 索引一般系统中都是很少用到的。另外MyISAM 的B-Tree 索引有一个较<br>    大的限制，那就是参与一个索引的所有字段的长度之和不能超过1000 字节。</p><p>虽然每一个MyISAM 的表都是存放在一个相同后缀名的.MYD 文件中，但是每个文件的存<br>放格式实际上可能并不是完全一样的，因为MyISAM 的数据存放格式是分为静态（FIXED）固<br>定长度、动态（DYNAMIC）可变长度以及压缩（COMPRESSED）这三种格式。当然三种格式中<br>是否压缩是完全可以任由我们自己选择的，可以在创建表的时候通过ROW_FORMAT 来指定<br>{COMPRESSED | DEFAULT}，也可以通过myisampack 工具来进行压缩，默认是不压缩的。</p><p>Innodb 存储引擎<br>有以下特点：<br>1、支持事务安装<br>2、锁定机制的改进，Innodb 改变了MyISAM 的锁机制，实现了行锁。<br>3、实现外键。</p><p>Innodb 的表空间分为两种形式。一种是共享表空间，也就是所有表和索引数据被存放<br>在同一个表空间（一个或多个数据文件）中，通过innodb_data_file_path 来指定。<br>另外一种是独享表空间，也就是每个表的数据和索引被存放在一个单独的.ibd 文件中。<br>一般建议用独享表空间。</p><p>Innodb 的所有参数基本上都带有前缀“innodb_”，我们也完全可以仅仅通过一个参数<br>（skip-innodb）来屏蔽MySQL 中的Innodb存储引擎，这样即使我们在安装编译的时候<br>将Innodb 存储引擎安装进去了，使用者也无法创建Innodb 的表。</p><p>MERGE 存储引擎，在MySQL 用户手册中也提到了，也被大家认识为MRG_MyISAM 引擎。</p><p>Memory 存储引擎，是将数据存储在内存中的存储引擎。Memory 存储引擎不会将任何<br>数据存放到磁盘上，仅仅存放了一个表结构相关信息的.frm 文件在磁盘上面。所以<br>一旦MySQL Crash 或者主机Crash 之后，Memory 的表就只剩下一个结构了。Memory<br>表支持索引，并且同时支持Hash 和B－Tree 两种格式的索引。由于是存放在内存中，<br>所以Memory 都是按照定长的空间来存储数据的，而且不支持BLOB 和TEXT类型的字段。<br>Memory 存储引擎实现页级锁定。</p><p>ARCHIVE存储引擎：<br>ARCHIVE 存储引擎主要用于通过较小的存储空间来存放过期的很少访问的历史数据。<br>ARCHIVE 表不支持索引，通过一个.frm 的结构定义文件，一个.ARZ 的数据压缩文件还有一<br>个.ARM 的meta 信息文件。由于其所存放的数据的特殊性，ARCHIVE 表不支持删除，修改操<br>作，仅支持插入和查询操作。锁定机制为行级锁定。</p><h2 id="MySQL的权限和安全"><a href="#MySQL的权限和安全" class="headerlink" title="MySQL的权限和安全"></a>MySQL的权限和安全</h2><p>略</p><h2 id="MySQL-备份与恢复"><a href="#MySQL-备份与恢复" class="headerlink" title="MySQL 备份与恢复"></a>MySQL 备份与恢复</h2><p>在介绍备份和恢复之前，先考虑以前几种情况的解决方案？<br>一、数据丢失应用场景<br>1、人为操作失误造成某些数据被误操作；<br>2、软件BUG 造成数据部分或者全部丢失；<br>3、硬件故障造成数据库数据部分或全部丢失；<br>4、安全漏洞被入侵数据被恶意破坏；</p><p>二、非数据丢失应用场景<br>5、特殊应用场景下基于时间点的数据恢复、回滚；<br>6、开发测试环境数据库搭建；<br>7、相同数据库的新环境搭建；<br>8、数据库或者数据迁移；</p><p>在MySQL 中一般都使用以下两种方法来获得可以自定义分隔符的纯文本备份文件。<br>1、通过执行SELECT … TO OUTFILE FROM …命令来实现<br>SELECT * INTO OUTFILE ‘/tmp/dump.text’<br>FIELDS TERMINATED BY ‘,’ OPTIONALLY ENCLOSED BY ‘“‘<br>FROM 表名 limit 100; </p><p>2、通过mysqldump 导出所有数据库<br>mysqldump -uroot -proot –all-databases &gt;/tmp/all.sql</p><p>思考：如何实现mysql数据不丢失备份和高效恢复方案？<br>可以采用让远程服务器实时同步bin-log日志,可以理解为主从复制。</p><p>物理备份；将.ibd文件、.myd文件、.frm等文件复制到mysql相应的位置上去。<br>逻辑备份：使用mysqldump工具，通过命令语句的形式将数据导到一个文件上。<br>热备份：线上备份数据，如主从复制。<br>冷备份：关闭数据库，然后将数据拷贝出来。</p><p>需求：一个论坛帖子总量的统计<br>附加要求：实时更新<br>在很多人看来，这个功能非常容易实现，不就是执行一条SELECT COUNT(*)的<br>Query 就可以得到结果了么？是的，确实只需要如此简单的一个Query 就可<br>以得到结果。但是，如果我们采用不是MyISAM 存储引擎，而是使用的Innodb<br>的存储引擎，那么大家可以试想一下，如果存放帖子的表中已经有上千万的帖<br>子的时候，执行这条Query 语句需要多少成本？恐怕再好的硬件设备，恐怕都<br>不可能在10 秒之内完成一次查询吧。如果我们的访问量再大一点，还有人觉得<br>这是一件简单的事情么？既然这样查询不行，那我们是不是该专门为这个功能<br>建一个表，就只有一个字段，一条记录，就存放这个统计量，每次有新的帖子<br>产生的时候，都将这个值增加1，这样我们每次都只需要查询这个表就可<br>以得到结果了，这个效率肯定能够满足要求。<br>但这种情况下，实时更新就很难确保的满足，可以这样，开启定时任务，定时<br>通过select语句更新表的统计结果。    </p><p>——————–未完待续98页——————–    </p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;此书的详细内容&quot;&gt;&lt;a href=&quot;#此书的详细内容&quot; class=&quot;headerlink&quot; title=&quot;此书的详细内容&quot;&gt;&lt;/a&gt;此书的详细内容&lt;/h5&gt;&lt;p&gt;作者：简朝阳&lt;br&gt;出版社: 电子工业出版社&lt;br&gt;出版年: 2009-6&lt;br&gt;
    
    </summary>
    
      <category term="读书" scheme="https://ouzhrm.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="mysql" scheme="https://ouzhrm.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="https://ouzhrm.github.io/2018/04/12/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>https://ouzhrm.github.io/2018/04/12/我的第一篇博客/</id>
    <published>2018-04-12T06:39:32.000Z</published>
    <updated>2018-05-20T08:36:48.513Z</updated>
    
    <content type="html"><![CDATA[<p>接触博客已经3、4年了，但是一直没有搭建过自己的一个独立的博客，曾经在github上，csdn上写过，<br>最高的那篇文章浏览量也已经过万，那是大二的时候了。今天浏览github的时候无意之中看见了搭建<br><a id="more"></a><br>博客的教程，心里突然想到的是，一味的索取他人的知识，没有奉献过自己的知识，顿时感觉到是不是<br>有点自私了？于是乎，经过三天的摸索，终于搭建了一个自己的小博客，写这篇博客的目的是，希望勉<br>励自己，不断前行，尽可能的为互联网事业奉献自己的一份微薄之力。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接触博客已经3、4年了，但是一直没有搭建过自己的一个独立的博客，曾经在github上，csdn上写过，&lt;br&gt;最高的那篇文章浏览量也已经过万，那是大二的时候了。今天浏览github的时候无意之中看见了搭建&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://ouzhrm.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://ouzhrm.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
